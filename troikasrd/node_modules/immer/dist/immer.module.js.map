{"version":3,"file":"immer.module.js","sources":["../src/env.ts","../src/extends.ts","../src/types-internal.ts","../src/common.ts","../src/scope.ts","../src/finalize.ts","../src/proxy.ts","../src/es5.ts","../src/map.ts","../src/set.ts","../src/patches.ts","../node_modules/tslib/tslib.es6.js","../src/immer.ts","../src/index.ts"],"sourcesContent":["// Should be no imports here!\n\n// SOme things that should be evaluated before all else...\nconst hasSymbol = typeof Symbol !== \"undefined\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\nexport const iteratorSymbol: typeof Symbol.iterator = hasSymbol\n\t? Symbol.iterator\n\t: (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","/* istanbul ignore next */\nvar extendStatics = function(d: any, b: any): any {\n\textendStatics =\n\t\tObject.setPrototypeOf ||\n\t\t({__proto__: []} instanceof Array &&\n\t\t\tfunction(d, b) {\n\t\t\t\td.__proto__ = b\n\t\t\t}) ||\n\t\tfunction(d, b) {\n\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t}\n\treturn extendStatics(d, b)\n}\n\n// Ugly hack to resolve #502 and inherit built in Map / Set\nexport function __extends(d: any, b: any): any {\n\textendStatics(d, b)\n\tfunction __(this: any): any {\n\t\tthis.constructor = d\n\t}\n\td.prototype =\n\t\t// @ts-ignore\n\t\t((__.prototype = b.prototype), new __())\n}\n","import {\n\tSetState,\n\tImmerScope,\n\tProxyObjectState,\n\tProxyArrayState,\n\tES5ObjectState,\n\tES5ArrayState,\n\tMapState,\n\tDRAFT_STATE\n} from \"./internal\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\nexport enum Archtype {\n\tObject,\n\tArray,\n\tMap,\n\tSet\n}\n\nexport enum ProxyType {\n\tProxyObject,\n\tProxyArray,\n\tES5Object,\n\tES5Array,\n\tMap,\n\tSet\n}\n\nexport interface ImmerBaseState {\n\tparent?: ImmerState\n\tscope: ImmerScope\n\tmodified: boolean\n\tfinalized: boolean\n\tisManual: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tProxyType,\n\tArchtype,\n\thasMap\n} from \"./internal\"\n\n/** Returns true if the given value is an Immer draft */\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\treturn !proto || proto === Object.prototype\n}\n\n/** Get the underlying object that is represented by the given draft */\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (value && value[DRAFT_STATE]) {\n\t\treturn value[DRAFT_STATE].base as any\n\t}\n\t// otherwise return undefined\n}\n\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\townKeys(obj).forEach(key => iter(key, obj[key], obj))\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\nexport function isEnumerable(base: AnyObject, prop: PropertyKey): boolean {\n\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\n\treturn desc && desc.enumerable ? true : false\n}\n\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tif (!thing) die()\n\tif (thing[DRAFT_STATE]) {\n\t\tswitch ((thing as Drafted)[DRAFT_STATE].type) {\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\t\treturn Archtype.Object\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn Archtype.Array\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn Archtype.Map\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn Archtype.Set\n\t\t}\n\t}\n\treturn Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tswitch (getArchtype(thing)) {\n\t\tcase Archtype.Map:\n\t\t\tthing.set(propOrOldValue, value)\n\t\t\tbreak\n\t\tcase Archtype.Set:\n\t\t\tthing.delete(propOrOldValue)\n\t\t\tthing.add(value)\n\t\t\tbreak\n\t\tdefault:\n\t\t\tthing[propOrOldValue] = value\n\t}\n}\n\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n\nexport function latest(state: ImmerState): any {\n\treturn state.copy || state.base\n}\n\nexport function shallowCopy<T extends AnyObject | AnyArray>(\n\tbase: T,\n\tinvokeGetters?: boolean\n): T\nexport function shallowCopy(base: any, invokeGetters = false) {\n\tif (Array.isArray(base)) return base.slice()\n\tconst clone = Object.create(Object.getPrototypeOf(base))\n\townKeys(base).forEach(key => {\n\t\tif (key === DRAFT_STATE) {\n\t\t\treturn // Never copy over draft state.\n\t\t}\n\t\tconst desc = Object.getOwnPropertyDescriptor(base, key)!\n\t\tlet {value} = desc\n\t\tif (desc.get) {\n\t\t\tif (!invokeGetters) {\n\t\t\t\tthrow new Error(\"Immer drafts cannot have computed properties\")\n\t\t\t}\n\t\t\tvalue = desc.get.call(base)\n\t\t}\n\t\tif (desc.enumerable) {\n\t\t\tclone[key] = value\n\t\t} else {\n\t\t\tObject.defineProperty(clone, key, {\n\t\t\t\tvalue,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t})\n\t\t}\n\t})\n\treturn clone\n}\n\nexport function freeze(obj: any, deep: boolean): void {\n\tif (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) return\n\tconst type = getArchtype(obj)\n\tif (type === Archtype.Set) {\n\t\tobj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t} else if (type === Archtype.Map) {\n\t\tobj.set = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (_, value) => freeze(value, true))\n}\n\nfunction dontMutateFrozenCollections() {\n\tthrow new Error(\"This object has been frozen and should not be mutated\")\n}\n\nexport function createHiddenProperty(\n\ttarget: AnyObject,\n\tprop: PropertyKey,\n\tvalue: any\n) {\n\tObject.defineProperty(target, prop, {\n\t\tvalue: value,\n\t\tenumerable: false,\n\t\twritable: true\n\t})\n}\n\n/* istanbul ignore next */\nexport function die(): never {\n\tthrow new Error(\"Illegal state, please file a bug\")\n}\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tProxyType,\n\tImmer,\n\tDRAFT_STATE\n} from \"./internal\"\n\n/** Each scope represents a `produce` call. */\nexport class ImmerScope {\n\tstatic current?: ImmerScope\n\n\tpatches?: Patch[]\n\tinversePatches?: Patch[]\n\tcanAutoFreeze: boolean\n\tdrafts: any[]\n\tparent?: ImmerScope\n\tpatchListener?: PatchListener\n\timmer: Immer\n\n\tconstructor(parent: ImmerScope | undefined, immer: Immer) {\n\t\tthis.drafts = []\n\t\tthis.parent = parent\n\t\tthis.immer = immer\n\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tthis.canAutoFreeze = true\n\t}\n\n\tusePatches(patchListener?: PatchListener) {\n\t\tif (patchListener) {\n\t\t\tthis.patches = []\n\t\t\tthis.inversePatches = []\n\t\t\tthis.patchListener = patchListener\n\t\t}\n\t}\n\n\trevoke() {\n\t\tthis.leave()\n\t\tthis.drafts.forEach(revoke)\n\t\t// @ts-ignore\n\t\tthis.drafts = null\n\t}\n\n\tleave() {\n\t\tif (this === ImmerScope.current) {\n\t\t\tImmerScope.current = this.parent\n\t\t}\n\t}\n\n\tstatic enter(immer: Immer) {\n\t\tconst scope = new ImmerScope(ImmerScope.current, immer)\n\t\tImmerScope.current = scope\n\t\treturn scope\n\t}\n}\n\nfunction revoke(draft: Drafted) {\n\tconst state = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type === ProxyType.ProxyObject ||\n\t\tstate.type === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke()\n\telse state.revoked = true\n}\n","import {\n\tImmer,\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tDrafted,\n\tPatchPath,\n\tProxyType,\n\teach,\n\thas,\n\tfreeze,\n\tgeneratePatches,\n\tshallowCopy,\n\tImmerState,\n\tisSet,\n\tisDraft,\n\tSetState,\n\tset,\n\tis,\n\tget\n} from \"./internal\"\n\nexport function processResult(immer: Immer, result: any, scope: ImmerScope) {\n\tconst baseDraft = scope.drafts![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\timmer.willFinalize(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified) {\n\t\t\tscope.revoke()\n\t\t\tthrow new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(immer, result, scope)\n\t\t\tif (!scope.parent) maybeFreeze(immer, result)\n\t\t}\n\t\tif (scope.patches) {\n\t\t\tscope.patches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [],\n\t\t\t\tvalue: result\n\t\t\t})\n\t\t\tscope.inversePatches!.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [],\n\t\t\t\tvalue: baseDraft[DRAFT_STATE].base\n\t\t\t})\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(immer, baseDraft, scope, [])\n\t}\n\tscope.revoke()\n\tif (scope.patches) {\n\t\tscope.patchListener!(scope.patches, scope.inversePatches!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(\n\timmer: Immer,\n\tdraft: Drafted,\n\tscope: ImmerScope,\n\tpath?: PatchPath\n) {\n\tconst state = draft[DRAFT_STATE]\n\tif (!state) {\n\t\tif (Object.isFrozen(draft)) return draft\n\t\treturn finalizeTree(immer, draft, scope)\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope !== scope) {\n\t\treturn draft\n\t}\n\tif (!state.modified) {\n\t\tmaybeFreeze(immer, state.base, true)\n\t\treturn state.base\n\t}\n\tif (!state.finalized) {\n\t\tstate.finalized = true\n\t\tfinalizeTree(immer, state.draft, scope, path)\n\n\t\t// We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\t\tif (immer.onDelete && state.type !== ProxyType.Set) {\n\t\t\t// The `assigned` object is unreliable with ES5 drafts.\n\t\t\tif (immer.useProxies) {\n\t\t\t\tconst {assigned} = state\n\t\t\t\teach(assigned, (prop, exists) => {\n\t\t\t\t\tif (!exists) immer.onDelete!(state, prop as any)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst {base, copy} = state\n\t\t\t\teach(base, prop => {\n\t\t\t\t\tif (!has(copy, prop)) immer.onDelete!(state, prop as any)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif (immer.onCopy) {\n\t\t\timmer.onCopy(state)\n\t\t}\n\n\t\t// At this point, all descendants of `state.copy` have been finalized,\n\t\t// so we can be sure that `scope.canAutoFreeze` is accurate.\n\t\tif (immer.autoFreeze && scope.canAutoFreeze) {\n\t\t\tfreeze(state.copy, false)\n\t\t}\n\n\t\tif (path && scope.patches) {\n\t\t\tgeneratePatches(state, path, scope.patches, scope.inversePatches!)\n\t\t}\n\t}\n\treturn state.copy\n}\n\nfunction finalizeTree(\n\timmer: Immer,\n\troot: Drafted,\n\tscope: ImmerScope,\n\trootPath?: PatchPath\n) {\n\tconst state = root[DRAFT_STATE]\n\tif (state) {\n\t\tif (\n\t\t\tstate.type === ProxyType.ES5Object ||\n\t\t\tstate.type === ProxyType.ES5Array\n\t\t) {\n\t\t\t// Create the final copy, with added keys and without deleted keys.\n\t\t\tstate.copy = shallowCopy(state.draft, true)\n\t\t}\n\t\troot = state.copy\n\t}\n\teach(root, (key, value) =>\n\t\tfinalizeProperty(immer, scope, root, state, root, key, value, rootPath)\n\t)\n\treturn root\n}\n\nfunction finalizeProperty(\n\timmer: Immer,\n\tscope: ImmerScope,\n\troot: Drafted,\n\trootState: ImmerState,\n\tparentValue: Drafted,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (childValue === parentValue) {\n\t\tthrow Error(\"Immer forbids circular references\")\n\t}\n\n\t// In the `finalizeTree` method, only the `root` object may be a draft.\n\tconst isDraftProp = !!rootState && parentValue === root\n\tconst isSetMember = isSet(parentValue)\n\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tisDraftProp &&\n\t\t\t!isSetMember && // Set objects are atomic since they have no keys.\n\t\t\t!has((rootState as Exclude<ImmerState, SetState>).assigned!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tchildValue = finalize(immer, childValue, scope, path)\n\t\tset(parentValue, prop, childValue)\n\n\t\t// Drafts from another scope must prevent auto-freezing.\n\t\tif (isDraft(childValue)) {\n\t\t\tscope.canAutoFreeze = false\n\t\t}\n\t}\n\t// Unchanged draft properties are ignored.\n\telse if (isDraftProp && is(childValue, get(rootState.base, prop))) {\n\t\treturn\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\t// TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?\n\t// especially the passing on of root and rootState doesn't make sense...\n\telse if (isDraftable(childValue)) {\n\t\teach(childValue, (key, grandChild) =>\n\t\t\tfinalizeProperty(\n\t\t\t\timmer,\n\t\t\t\tscope,\n\t\t\t\troot,\n\t\t\t\trootState,\n\t\t\t\tchildValue,\n\t\t\t\tkey,\n\t\t\t\tgrandChild,\n\t\t\t\trootPath\n\t\t\t)\n\t\t)\n\t\tif (!scope.parent) maybeFreeze(immer, childValue)\n\t}\n\n\tif (isDraftProp && immer.onAssign && !isSetMember) {\n\t\timmer.onAssign(rootState, prop, childValue)\n\t}\n}\n\nexport function maybeFreeze(immer: Immer, value: any, deep = false) {\n\tif (immer.autoFreeze && !isDraft(value)) {\n\t\tfreeze(value, deep)\n\t}\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tProxyType,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tImmerScope,\n\tDRAFT_STATE\n} from \"./internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned: {\n\t\t[property: string]: boolean\n\t}\n\tparent?: ImmerState\n\tdrafts?: {\n\t\t[property: string]: Drafted<any, any>\n\t}\n\trevoke(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype: ProxyType.ProxyObject\n\tbase: AnyObject\n\tcopy: AnyObject | null\n\tdraft: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype: ProxyType.ProxyArray\n\tbase: AnyArray\n\tcopy: AnyArray | null\n\tdraft: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified: false,\n\t\t// Used during finalization.\n\t\tfinalized: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned: {},\n\t\t// The parent draft state.\n\t\tparent,\n\t\t// The base state.\n\t\tbase,\n\t\t// The base proxy.\n\t\tdraft: null as any, // set below\n\t\t// Any property proxies.\n\t\tdrafts: {},\n\t\t// The base copy with any updated values.\n\t\tcopy: null,\n\t\t// Called by the `produce` function.\n\t\trevoke: null as any,\n\t\tisManual: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\t// TODO: optimization: might be faster, cheaper if we created a non-revocable proxy\n\t// and administrate revoking ourselves\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft = proxy as any\n\tstate.revoke = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nconst objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\t\tlet {drafts} = state\n\n\t\t// Check for existing draft in unmodified state.\n\t\tif (!state.modified && has(drafts, prop)) {\n\t\t\treturn drafts![prop as any]\n\t\t}\n\n\t\tconst value = latest(state)[prop]\n\t\tif (state.finalized || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\n\t\t// Check for existing draft in modified state.\n\t\tif (state.modified) {\n\t\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\t\tif (value !== peek(state.base, prop)) return value\n\t\t\t// Store drafts on the copy (when one exists).\n\t\t\t// @ts-ignore\n\t\t\tdrafts = state.copy\n\t\t}\n\n\t\treturn (drafts![prop as any] = state.scope.immer.createProxy(value, state))\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(state, prop: string /* strictly not, but helps TS */, value) {\n\t\tif (!state.modified) {\n\t\t\tconst baseValue = peek(state.base, prop)\n\t\t\t// Optimize based on value's truthiness. Truthy values are guaranteed to\n\t\t\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\n\t\t\t// values may be drafts, but falsy values are never drafts.\n\t\t\tconst isUnchanged = value\n\t\t\t\t? is(baseValue, value) || value === state.drafts![prop]\n\t\t\t\t: is(baseValue, value) && prop in state.base\n\t\t\tif (isUnchanged) return true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\t\tstate.assigned[prop] = true\n\t\t// @ts-ignore\n\t\tstate.copy![prop] = value\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base, prop) !== undefined || prop in state.base) {\n\t\t\tstate.assigned[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else if (state.assigned[prop]) {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy) delete state.copy[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (desc) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable =\n\t\t\t\tstate.type !== ProxyType.ProxyArray || prop !== \"length\"\n\t\t}\n\t\treturn desc\n\t},\n\tdefineProperty() {\n\t\tthrow new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base)\n\t},\n\tsetPrototypeOf() {\n\t\tthrow new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (isNaN(parseInt(prop as any))) {\n\t\tthrow new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n\t}\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (prop !== \"length\" && isNaN(parseInt(prop as any))) {\n\t\tthrow new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n\t}\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n/**\n * Map drafts\n */\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey): any {\n\tconst state = draft[DRAFT_STATE]\n\tconst desc = Reflect.getOwnPropertyDescriptor(\n\t\tstate ? latest(state) : draft,\n\t\tprop\n\t)\n\treturn desc && desc.value\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (\n\t\t\tstate.type === ProxyType.ProxyObject ||\n\t\t\tstate.type === ProxyType.ProxyArray\n\t\t) {\n\t\t\tconst copy = (state.copy = shallowCopy(state.base))\n\t\t\teach(state.drafts!, (key, value) => {\n\t\t\t\t// @ts-ignore\n\t\t\t\tcopy[key] = value\n\t\t\t})\n\t\t\tstate.drafts = undefined\n\t\t}\n\n\t\tif (state.parent) {\n\t\t\tmarkChanged(state.parent)\n\t\t}\n\t}\n}\n\nfunction prepareCopy(state: ProxyState) {\n\tif (!state.copy) {\n\t\tstate.copy = shallowCopy(state.base)\n\t}\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraft,\n\tisDraftable,\n\tisEnumerable,\n\tshallowCopy,\n\tlatest,\n\tcreateHiddenProperty,\n\tImmerScope,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tObjectish,\n\tImmerBaseState,\n\tAnyArray,\n\tProxyType,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE\n} from \"./internal\"\n\ninterface ES5BaseState extends ImmerBaseState {\n\tfinalizing: boolean\n\tassigned: {[key: string]: any}\n\tparent?: ImmerState\n\trevoked: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype: ProxyType.ES5Object\n\tdraft: Drafted<AnyObject, ES5ObjectState>\n\tbase: AnyObject\n\tcopy: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype: ProxyType.ES5Array\n\tdraft: Drafted<AnyObject, ES5ArrayState>\n\tbase: AnyArray\n\tcopy: AnyArray | null\n}\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function willFinalizeES5(\n\tscope: ImmerScope,\n\tresult: any,\n\tisReplaced: boolean\n) {\n\tscope.drafts!.forEach(draft => {\n\t\tdraft[DRAFT_STATE].finalizing = true\n\t})\n\tif (!isReplaced) {\n\t\tif (scope.patches) {\n\t\t\tmarkChangesRecursively(scope.drafts![0])\n\t\t}\n\t\t// This is faster when we don't care about which attributes changed.\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n\t// When a child draft is returned, look for changes.\n\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n}\n\nexport function createES5Proxy<T>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\tconst isArray = Array.isArray(base)\n\tconst draft = clonePotentialDraft(base)\n\n\teach(draft, prop => {\n\t\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n\t})\n\n\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\ttype: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\tmodified: false,\n\t\tfinalizing: false,\n\t\tfinalized: false,\n\t\tassigned: {},\n\t\tparent,\n\t\tbase,\n\t\tdraft,\n\t\tcopy: null,\n\t\trevoked: false,\n\t\tisManual: false\n\t}\n\n\tcreateHiddenProperty(draft, DRAFT_STATE, state)\n\treturn draft\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tif (state && !state.finalizing) {\n\t\tstate.finalizing = true\n\t\tconst value = draft[prop]\n\t\tstate.finalizing = false\n\t\treturn value\n\t}\n\treturn draft[prop]\n}\n\nfunction get(state: ES5State, prop: string | number) {\n\tassertUnrevoked(state)\n\tconst value = peek(latest(state), prop)\n\tif (state.finalizing) return value\n\t// Create a draft if the value is unmodified.\n\tif (value === peek(state.base, prop) && isDraftable(value)) {\n\t\tprepareCopy(state)\n\t\t// @ts-ignore\n\t\treturn (state.copy![prop] = state.scope.immer.createProxy(value, state))\n\t}\n\treturn value\n}\n\nfunction set(state: ES5State, prop: string | number, value: any) {\n\tassertUnrevoked(state)\n\tstate.assigned[prop] = true\n\tif (!state.modified) {\n\t\tif (is(value, peek(latest(state), prop))) return\n\t\tmarkChangedES5(state)\n\t\tprepareCopy(state)\n\t}\n\t// @ts-ignore\n\tstate.copy![prop] = value\n}\n\nexport function markChangedES5(state: ImmerState) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (state.parent) markChangedES5(state.parent)\n\t}\n}\n\nfunction prepareCopy(state: ES5State) {\n\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base: Objectish) {\n\tconst state = base && (base as any)[DRAFT_STATE]\n\tif (state) {\n\t\tstate.finalizing = true\n\t\tconst draft = shallowCopy(state.draft, true)\n\t\tstate.finalizing = false\n\t\treturn draft\n\t}\n\treturn shallowCopy(base)\n}\n\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\nconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\nfunction proxyProperty(\n\tdraft: Drafted<any, ES5State>,\n\tprop: string | number,\n\tenumerable: boolean\n) {\n\tlet desc = descriptors[prop]\n\tif (desc) {\n\t\tdesc.enumerable = enumerable\n\t} else {\n\t\tdescriptors[prop] = desc = {\n\t\t\tconfigurable: true,\n\t\t\tenumerable,\n\t\t\tget(this: any) {\n\t\t\t\treturn get(this[DRAFT_STATE], prop)\n\t\t\t},\n\t\t\tset(this: any, value) {\n\t\t\t\tset(this[DRAFT_STATE], prop, value)\n\t\t\t}\n\t\t}\n\t}\n\tObject.defineProperty(draft, prop, desc)\n}\n\nexport function assertUnrevoked(state: ES5State | MapState | SetState) {\n\tif (state.revoked === true)\n\t\tthrow new Error(\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\tJSON.stringify(latest(state))\n\t\t)\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t// The natural order of drafts in the `scope` array is based on when they\n\t// were accessed. By processing drafts in reverse natural order, we have a\n\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t// have changed, we can avoid any traversal of its ancestor nodes.\n\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\tconst state = drafts[i][DRAFT_STATE]\n\t\tif (!state.modified) {\n\t\t\tswitch (state.type) {\n\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\tif (hasArrayChanges(state)) markChangedES5(state)\n\t\t\t\t\tbreak\n\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\tif (hasObjectChanges(state)) markChangedES5(state)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction markChangesRecursively(object: any) {\n\tif (!object || typeof object !== \"object\") return\n\tconst state = object[DRAFT_STATE]\n\tif (!state) return\n\tconst {base, draft, assigned, type} = state\n\tif (type === ProxyType.ES5Object) {\n\t\t// Look for added keys.\n\t\t// TODO: looks quite duplicate to hasObjectChanges,\n\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t// unnecessary work.\n\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\teach(draft, key => {\n\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (base[key] === undefined && !has(base, key)) {\n\t\t\t\tassigned[key] = true\n\t\t\t\tmarkChangedES5(state)\n\t\t\t} else if (!assigned[key]) {\n\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\tmarkChangesRecursively(draft[key])\n\t\t\t}\n\t\t})\n\t\t// Look for removed keys.\n\t\teach(base, key => {\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (draft[key] === undefined && !has(draft, key)) {\n\t\t\t\tassigned[key] = false\n\t\t\t\tmarkChangedES5(state)\n\t\t\t}\n\t\t})\n\t} else if (type === ProxyType.ES5Array) {\n\t\tif (hasArrayChanges(state)) {\n\t\t\tmarkChangedES5(state)\n\t\t\tassigned.length = true\n\t\t}\n\n\t\tif (draft.length < base.length) {\n\t\t\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\n\t\t} else {\n\t\t\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\n\t\t}\n\n\t\t// Minimum count is enough, the other parts has been processed.\n\t\tconst min = Math.min(draft.length, base.length)\n\n\t\tfor (let i = 0; i < min; i++) {\n\t\t\t// Only untouched indices trigger recursion.\n\t\t\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\n\t\t}\n\t}\n}\n\nfunction hasObjectChanges(state: ES5ObjectState) {\n\tconst {base, draft} = state\n\n\t// Search for added keys and changed keys. Start at the back, because\n\t// non-numeric keys are ordered by time of definition on the object.\n\tconst keys = Object.keys(draft)\n\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\tconst key = keys[i]\n\t\tconst baseValue = base[key]\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (baseValue === undefined && !has(base, key)) {\n\t\t\treturn true\n\t\t}\n\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t// descriptor is erased. This branch detects any missed changes.\n\t\telse {\n\t\t\tconst value = draft[key]\n\t\t\tconst state = value && value[DRAFT_STATE]\n\t\t\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// At this point, no keys were added or changed.\n\t// Compare key count to determine if keys were deleted.\n\treturn keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state: ES5ArrayState) {\n\tconst {draft} = state\n\tif (draft.length !== state.base.length) return true\n\t// See #116\n\t// If we first shorten the length, our array interceptors will be removed.\n\t// If after that new items are added, result in the same original length,\n\t// those last items will have no intercepting property.\n\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t// the last one\n\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\tif (descriptor && !descriptor.get) return true\n\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\treturn false\n}\n","import {\n\t__extends,\n\tImmerBaseState,\n\tProxyType,\n\tAnyMap,\n\tDrafted,\n\tImmerState,\n\tDRAFT_STATE,\n\tImmerScope,\n\tlatest,\n\tassertUnrevoked,\n\tisDraftable,\n\titeratorSymbol\n} from \"./internal\"\n\nexport interface MapState extends ImmerBaseState {\n\ttype: ProxyType.Map\n\tcopy: AnyMap | undefined\n\tassigned: Map<any, boolean> | undefined\n\tbase: AnyMap\n\trevoked: boolean\n\tdraft: Drafted<AnyMap, MapState>\n}\n\nconst DraftMap = (function(_super) {\n\tif (!_super) {\n\t\t/* istanbul ignore next */\n\t\tthrow new Error(\"Map is not polyfilled\")\n\t}\n\t__extends(DraftMap, _super)\n\t// Create class manually, cause #502\n\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\tthis[DRAFT_STATE] = {\n\t\t\ttype: ProxyType.Map,\n\t\t\tparent,\n\t\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t\tmodified: false,\n\t\t\tfinalized: false,\n\t\t\tcopy: undefined,\n\t\t\tassigned: undefined,\n\t\t\tbase: target,\n\t\t\tdraft: this as any,\n\t\t\tisManual: false,\n\t\t\trevoked: false\n\t\t}\n\t\treturn this\n\t}\n\tconst p = DraftMap.prototype\n\n\t// TODO: smaller build size if we create a util for Object.defineProperty\n\tObject.defineProperty(p, \"size\", {\n\t\tget: function() {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t})\n\n\tp.has = function(key: any): boolean {\n\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t}\n\n\tp.set = function(key: any, value: any) {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tif (latest(state).get(key) !== value) {\n\t\t\tprepareCopy(state)\n\t\t\tstate.scope.immer.markChanged(state)\n\t\t\tstate.assigned!.set(key, true)\n\t\t\tstate.copy!.set(key, value)\n\t\t\tstate.assigned!.set(key, true)\n\t\t}\n\t\treturn this\n\t}\n\n\tp.delete = function(key: any): boolean {\n\t\tif (!this.has(key)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\tstate.assigned!.set(key, false)\n\t\tstate.copy!.delete(key)\n\t\treturn true\n\t}\n\n\tp.clear = function() {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\tstate.assigned = new Map()\n\t\treturn state.copy!.clear()\n\t}\n\n\tp.forEach = function(\n\t\tcb: (value: any, key: any, self: any) => void,\n\t\tthisArg?: any\n\t) {\n\t\tconst state = this[DRAFT_STATE]\n\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t})\n\t}\n\n\tp.get = function(key: any): any {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tconst value = latest(state).get(key)\n\t\tif (state.finalized || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\tif (value !== state.base.get(key)) {\n\t\t\treturn value // either already drafted or reassigned\n\t\t}\n\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\tconst draft = state.scope.immer.createProxy(value, state)\n\t\tprepareCopy(state)\n\t\tstate.copy!.set(key, draft)\n\t\treturn draft\n\t}\n\n\tp.keys = function(): IterableIterator<any> {\n\t\treturn latest(this[DRAFT_STATE]).keys()\n\t}\n\n\tp.values = function(): IterableIterator<any> {\n\t\tconst iterator = this.keys()\n\t\treturn {\n\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\tnext: () => {\n\t\t\t\tconst r = iterator.next()\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (r.done) return r\n\t\t\t\tconst value = this.get(r.value)\n\t\t\t\treturn {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue\n\t\t\t\t}\n\t\t\t}\n\t\t} as any\n\t}\n\n\tp.entries = function(): IterableIterator<[any, any]> {\n\t\tconst iterator = this.keys()\n\t\treturn {\n\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\tnext: () => {\n\t\t\t\tconst r = iterator.next()\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (r.done) return r\n\t\t\t\tconst value = this.get(r.value)\n\t\t\t\treturn {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t}\n\t\t\t}\n\t\t} as any\n\t}\n\n\tp[iteratorSymbol] = function() {\n\t\treturn this.entries()\n\t}\n\n\treturn DraftMap\n})(Map)\n\nexport function proxyMap<T extends AnyMap>(\n\ttarget: T,\n\tparent?: ImmerState\n): T & {[DRAFT_STATE]: MapState} {\n\t// @ts-ignore\n\treturn new DraftMap(target, parent)\n}\n\nfunction prepareCopy(state: MapState) {\n\tif (!state.copy) {\n\t\tstate.assigned = new Map()\n\t\tstate.copy = new Map(state.base)\n\t}\n}\n","import {\n\t__extends,\n\tImmerBaseState,\n\tProxyType,\n\tAnySet,\n\tDrafted,\n\tImmerState,\n\tDRAFT_STATE,\n\tImmerScope,\n\tlatest,\n\tassertUnrevoked,\n\titeratorSymbol,\n\tisDraftable\n} from \"./internal\"\n\nexport interface SetState extends ImmerBaseState {\n\ttype: ProxyType.Set\n\tcopy: AnySet | undefined\n\tbase: AnySet\n\tdrafts: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked: boolean\n\tdraft: Drafted<AnySet, SetState>\n}\n\nconst DraftSet = (function(_super) {\n\tif (!_super) {\n\t\t/* istanbul ignore next */\n\t\tthrow new Error(\"Set is not polyfilled\")\n\t}\n\t__extends(DraftSet, _super)\n\t// Create class manually, cause #502\n\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\tthis[DRAFT_STATE] = {\n\t\t\ttype: ProxyType.Set,\n\t\t\tparent,\n\t\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t\tmodified: false,\n\t\t\tfinalized: false,\n\t\t\tcopy: undefined,\n\t\t\tbase: target,\n\t\t\tdraft: this,\n\t\t\tdrafts: new Map(),\n\t\t\trevoked: false,\n\t\t\tisManual: false\n\t\t}\n\t\treturn this\n\t}\n\tconst p = DraftSet.prototype\n\n\tObject.defineProperty(p, \"size\", {\n\t\tget: function() {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t})\n\n\tp.has = function(value: any): boolean {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\tif (!state.copy) {\n\t\t\treturn state.base.has(value)\n\t\t}\n\t\tif (state.copy.has(value)) return true\n\t\tif (state.drafts.has(value) && state.copy.has(state.drafts.get(value)))\n\t\t\treturn true\n\t\treturn false\n\t}\n\n\tp.add = function(value: any): any {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tif (state.copy) {\n\t\t\tstate.copy.add(value)\n\t\t} else if (!state.base.has(value)) {\n\t\t\tprepareCopy(state)\n\t\t\tstate.scope.immer.markChanged(state)\n\t\t\tstate.copy!.add(value)\n\t\t}\n\t\treturn this\n\t}\n\n\tp.delete = function(value: any): any {\n\t\tif (!this.has(value)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\treturn (\n\t\t\tstate.copy!.delete(value) ||\n\t\t\t(state.drafts.has(value)\n\t\t\t\t? state.copy!.delete(state.drafts.get(value))\n\t\t\t\t: /* istanbul ignore next */ false)\n\t\t)\n\t}\n\n\tp.clear = function() {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\treturn state.copy!.clear()\n\t}\n\n\tp.values = function(): IterableIterator<any> {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\treturn state.copy!.values()\n\t}\n\n\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\treturn state.copy!.entries()\n\t}\n\n\tp.keys = function(): IterableIterator<any> {\n\t\treturn this.values()\n\t}\n\n\tp[iteratorSymbol] = function() {\n\t\treturn this.values()\n\t}\n\n\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\tconst iterator = this.values()\n\t\tlet result = iterator.next()\n\t\twhile (!result.done) {\n\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\tresult = iterator.next()\n\t\t}\n\t}\n\n\treturn DraftSet\n})(Set)\n\nexport function proxySet<T extends AnySet>(\n\ttarget: T,\n\tparent?: ImmerState\n): T & {[DRAFT_STATE]: SetState} {\n\t// @ts-ignore\n\treturn new DraftSet(target, parent)\n}\n\nfunction prepareCopy(state: SetState) {\n\tif (!state.copy) {\n\t\t// create drafts for all entries to preserve insertion order\n\t\tstate.copy = new Set()\n\t\tstate.base.forEach(value => {\n\t\t\tif (isDraftable(value)) {\n\t\t\t\tconst draft = state.scope.immer.createProxy(value, state)\n\t\t\t\tstate.drafts.set(value, draft)\n\t\t\t\tstate.copy!.add(draft)\n\t\t\t} else {\n\t\t\t\tstate.copy!.add(value)\n\t\t\t}\n\t\t})\n\t}\n}\n","import {\n\tget,\n\teach,\n\thas,\n\tdie,\n\tgetArchtype,\n\tImmerState,\n\tPatch,\n\tProxyType,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tArchtype,\n\tisMap,\n\tisSet\n} from \"./internal\"\n\nexport type PatchPath = (string | number)[]\n\nexport function generatePatches(\n\tstate: ImmerState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n): void {\n\tswitch (state.type) {\n\t\tcase ProxyType.ProxyObject:\n\t\tcase ProxyType.ES5Object:\n\t\tcase ProxyType.Map:\n\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\tstate,\n\t\t\t\tbasePath,\n\t\t\t\tpatches,\n\t\t\t\tinversePatches\n\t\t\t)\n\t\tcase ProxyType.ES5Array:\n\t\tcase ProxyType.ProxyArray:\n\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\tcase ProxyType.Set:\n\t\t\treturn generateSetPatches(\n\t\t\t\t(state as any) as SetState,\n\t\t\t\tbasePath,\n\t\t\t\tpatches,\n\t\t\t\tinversePatches\n\t\t\t)\n\t}\n}\n\nfunction generateArrayPatches(\n\tstate: ES5ArrayState | ProxyArrayState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tlet {base, assigned, copy} = state\n\t/* istanbul ignore next */\n\tif (!copy) die()\n\n\t// Reduce complexity by ensuring `base` is never longer.\n\tif (copy.length < base.length) {\n\t\t// @ts-ignore\n\t\t;[base, copy] = [copy, base]\n\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t}\n\n\tconst delta = copy.length - base.length\n\n\t// Find the first replaced index.\n\tlet start = 0\n\twhile (base[start] === copy[start] && start < base.length) {\n\t\t++start\n\t}\n\n\t// Find the last replaced index. Search from the end to optimize splice patches.\n\tlet end = base.length\n\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\n\t\t--end\n\t}\n\n\t// Process replaced indices.\n\tfor (let i = start; i < end; ++i) {\n\t\tif (assigned[i] && copy[i] !== base[i]) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: copy[i]\n\t\t\t})\n\t\t\tinversePatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: base[i]\n\t\t\t})\n\t\t}\n\t}\n\n\tconst replaceCount = patches.length\n\n\t// Process added indices.\n\tfor (let i = end + delta - 1; i >= end; --i) {\n\t\tconst path = basePath.concat([i])\n\t\tpatches[replaceCount + i - end] = {\n\t\t\top: \"add\",\n\t\t\tpath,\n\t\t\tvalue: copy[i]\n\t\t}\n\t\tinversePatches.push({\n\t\t\top: \"remove\",\n\t\t\tpath\n\t\t})\n\t}\n}\n\n// This is used for both Map objects and normal objects.\nfunction generatePatchesFromAssigned(\n\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tconst {base, copy} = state\n\teach(state.assigned!, (key, assignedValue) => {\n\t\tconst origValue = get(base, key)\n\t\tconst value = get(copy!, key)\n\t\tconst op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\"\n\t\tif (origValue === value && op === \"replace\") return\n\t\tconst path = basePath.concat(key as any)\n\t\tpatches.push(op === \"remove\" ? {op, path} : {op, path, value})\n\t\tinversePatches.push(\n\t\t\top === \"add\"\n\t\t\t\t? {op: \"remove\", path}\n\t\t\t\t: op === \"remove\"\n\t\t\t\t? {op: \"add\", path, value: origValue}\n\t\t\t\t: {op: \"replace\", path, value: origValue}\n\t\t)\n\t})\n}\n\nfunction generateSetPatches(\n\tstate: SetState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tlet {base, copy} = state\n\n\tlet i = 0\n\tbase.forEach(value => {\n\t\tif (!copy!.has(value)) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"remove\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t\tinversePatches.unshift({\n\t\t\t\top: \"add\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t}\n\t\ti++\n\t})\n\ti = 0\n\tcopy!.forEach(value => {\n\t\tif (!base.has(value)) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"add\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t\tinversePatches.unshift({\n\t\t\t\top: \"remove\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t}\n\t\ti++\n\t})\n}\n\nexport function applyPatches<T>(draft: T, patches: Patch[]): T {\n\tpatches.forEach(patch => {\n\t\tconst {path, op} = patch\n\n\t\t/* istanbul ignore next */\n\t\tif (!path.length) die()\n\n\t\tlet base: any = draft\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tbase = get(base, path[i])\n\t\t\tif (!base || typeof base !== \"object\")\n\t\t\t\tthrow new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n\t\t}\n\n\t\tconst type = getArchtype(base)\n\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\tconst key = path[path.length - 1]\n\t\tswitch (op) {\n\t\t\tcase \"replace\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\tthrow new Error('Sets cannot have \"replace\" patches.')\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t}\n\t\t\tcase \"add\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\treturn base.splice(key as any, 0, value)\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t}\n\t\t\tcase \"remove\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported patch operation: \" + op)\n\t\t}\n\t})\n\n\treturn draft\n}\n\n// TODO: optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n// E.g. auto-draft when new objects from outside are assigned and modified?\n// (See failing test when deepClone just returns obj)\nfunction deepClonePatchValue<T>(obj: T): T\nfunction deepClonePatchValue(obj: any) {\n\tif (!obj || typeof obj !== \"object\") return obj\n\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\tif (isMap(obj))\n\t\treturn new Map(\n\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t)\n\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\treturn cloned\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n\tcreateES5Proxy,\n\twillFinalizeES5,\n\tmarkChangedES5,\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\teach,\n\tDrafted,\n\tisDraftable,\n\tImmerScope,\n\tprocessResult,\n\tNOTHING,\n\tmaybeFreeze,\n\tdie,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tapplyPatches,\n\tisMap,\n\tproxyMap,\n\tisSet,\n\tproxySet,\n\tcreateProxy,\n\tmarkChanged\n} from \"./internal\"\n\n/* istanbul ignore next */\nfunction verifyMinified() {}\n\nconst configDefaults = {\n\tuseProxies:\n\t\ttypeof Proxy !== \"undefined\" &&\n\t\ttypeof Proxy.revocable !== \"undefined\" &&\n\t\ttypeof Reflect !== \"undefined\",\n\tautoFreeze:\n\t\ttypeof process !== \"undefined\"\n\t\t\t? process.env.NODE_ENV !== \"production\"\n\t\t\t: /* istanbul ignore next */\n\t\t\t  verifyMinified.name === \"verifyMinified\",\n\tonAssign: null,\n\tonDelete: null,\n\tonCopy: null\n} as const\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies: boolean = false\n\tautoFreeze: boolean = false\n\tonAssign?: (state: ImmerState, prop: string | number, value: unknown) => void\n\tonDelete?: (state: ImmerState, prop: string | number) => void\n\tonCopy?: (state: ImmerState) => void\n\n\tconstructor(config?: {\n\t\tuseProxies?: boolean\n\t\tautoFreeze?: boolean\n\t\tonAssign?: (\n\t\t\tstate: ImmerState,\n\t\t\tprop: string | number,\n\t\t\tvalue: unknown\n\t\t) => void\n\t\tonDelete?: (state: ImmerState, prop: string | number) => void\n\t\tonCopy?: (state: ImmerState) => void\n\t}) {\n\t\teach(configDefaults, (key, value) => {\n\t\t\t// @ts-ignore\n\t\t\tthis[key] = config?.[key] ?? value\n\t\t})\n\t\tthis.setUseProxies(this.useProxies)\n\t\tthis.produce = this.produce.bind(this)\n\t\tthis.produceWithPatches = this.produceWithPatches.bind(this)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce(base: any, recipe?: any, patchListener?: any) {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\t// prettier-ignore\n\t\t{\n\t\t\tif (typeof recipe !== \"function\") {\n\t\t\t\tthrow new Error(\"The first or second argument to `produce` must be a function\")\n\t\t\t}\n\t\t\tif (patchListener !== undefined && typeof patchListener !== \"function\") {\n\t\t\t\tthrow new Error(\"The third argument to `produce` must be a function or undefined\")\n\t\t\t}\n\t\t}\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = ImmerScope.enter(this)\n\t\t\tconst proxy = this.createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) scope.revoke()\n\t\t\t\telse scope.leave()\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tscope.usePatches(patchListener)\n\t\t\t\t\t\treturn processResult(this, result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tscope.revoke()\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tscope.usePatches(patchListener)\n\t\t\treturn processResult(this, result, scope)\n\t\t} else {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tmaybeFreeze(this, result, true)\n\t\t\treturn result\n\t\t}\n\t}\n\n\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\t\t// non-curried form\n\t\t/* istanbul ignore next */\n\t\tif (arg3) die()\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) {\n\t\t\tthrow new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\") // prettier-ignore\n\t\t}\n\t\tconst scope = ImmerScope.enter(this)\n\t\tconst proxy = this.createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual = true\n\t\tscope.leave()\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && draft[DRAFT_STATE]\n\t\tif (!state || !state.isManual) {\n\t\t\tthrow new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\") // prettier-ignore\n\t\t}\n\t\tif (state.finalized) {\n\t\t\tthrow new Error(\"The given draft is already finalized\") // prettier-ignore\n\t\t}\n\t\tconst {scope} = state\n\t\tscope.usePatches(patchListener)\n\t\treturn processResult(this, undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is disabled in production.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tthis.useProxies = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatches(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatches(draft, patches.slice(i + 1))\n\t\t)\n\t}\n\n\tcreateProxy<T extends Objectish>(\n\t\tvalue: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ImmerState> {\n\t\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t\tconst draft: Drafted = isMap(value)\n\t\t\t? proxyMap(value, parent)\n\t\t\t: isSet(value)\n\t\t\t? proxySet(value, parent)\n\t\t\t: this.useProxies\n\t\t\t? createProxy(value, parent)\n\t\t\t: createES5Proxy(value, parent)\n\n\t\tconst scope = parent ? parent.scope : ImmerScope.current!\n\t\tscope.drafts.push(draft)\n\t\treturn draft\n\t}\n\n\twillFinalize(scope: ImmerScope, thing: any, isReplaced: boolean) {\n\t\tif (!this.useProxies) willFinalizeES5(scope, thing, isReplaced)\n\t}\n\n\tmarkChanged(state: ImmerState) {\n\t\tif (this.useProxies) {\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\tmarkChangedES5(state)\n\t\t}\n\t}\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n"],"names":["hasSymbol","Symbol","hasMap","Map","hasSet","Set","NOTHING","_a","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","Archtype","ProxyType","isDraft","value","isDraftable","isPlainObject","isArray","isMap","isSet","proto","getPrototypeOf","original","base","ownKeys","Reflect","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","each","iter","getArchtype","forEach","key","entry","index","isEnumerable","prop","desc","getOwnPropertyDescriptor","enumerable","thing","die","type","ES5Object","ProxyObject","ES5Array","ProxyArray","has","call","get","set","propOrOldValue","delete","add","is","x","y","target","latest","state","copy","shallowCopy","invokeGetters","slice","clone","create","Error","defineProperty","writable","configurable","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","_","createHiddenProperty","parent","immer","drafts","canAutoFreeze","ImmerScope","patchListener","patches","inversePatches","leave","revoke","current","scope","draft","revoked","processResult","result","baseDraft","isReplaced","undefined","willFinalize","modified","finalize","maybeFreeze","push","op","path","finalizeTree","finalized","onDelete","useProxies","assigned","exists","copy_1","onCopy","autoFreeze","generatePatches","root","rootPath","finalizeProperty","rootState","parentValue","childValue","isDraftProp","isSetMember","grandChild","onAssign","createProxy","isManual","traps","objectTraps","arrayTraps","proxy","peek","baseValue","isUnchanged","prepareCopy","markChanged","deleteProperty","owner","fn","arguments","apply","isNaN","parseInt","willFinalizeES5","finalizing","markChangesRecursively","markChangesSweep","createES5Proxy","clonePotentialDraft","proxyProperty","assertUnrevoked","markChangedES5","descriptors","JSON","stringify","i","length","hasArrayChanges","hasObjectChanges","object","min","Math","keys","state_1","descriptor","DraftMap","_super","size","cb","thisArg","_value","_map","_this","values","r","next","done","entries","proxyMap","DraftSet","proxySet","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","_b","delta","start","end","replaceCount","assignedValue","origValue","unshift","applyPatches","patch","join","deepClonePatchValue","splice","map","from","k","v","cloned","verifyMinified","configDefaults","Proxy","revocable","process","env","NODE_ENV","name","config","setUseProxies","produce","bind","produceWithPatches","Immer","recipe","defaultBase_1","self_1","curriedProduce","_i","args","scope_1","enter","hasError","Promise","then","usePatches","error","arg1","arg2","arg3","nextState","ip","setAutoFreeze","createDraft","finishDraft","castDraft","castImmutable"],"mappings":"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"}