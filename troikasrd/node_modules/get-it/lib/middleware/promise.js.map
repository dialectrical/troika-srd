{"version":3,"sources":["../../src/middleware/promise.js"],"names":["global","require","Cancel","CancelToken","isCancel","promise","options","Promise","implementation","Error","onReturn","channels","context","resolve","reject","cancel","cancelToken","then","abort","publish","reason","error","subscribe","response","onlyBody","body","setTimeout","request","err","module","exports"],"mappings":";;AAAA,IAAMA,SAASC,QAAQ,gBAAR,CAAf;AACA,IAAMC,SAASD,QAAQ,iBAAR,CAAf;AACA,IAAME,cAAcF,QAAQ,sBAAR,CAApB;AACA,IAAMG,WAAWH,QAAQ,mBAAR,CAAjB;;AAEA,IAAMI,UAAU,SAAVA,OAAU,GAAkB;AAAA,MAAjBC,OAAiB,uEAAP,EAAO;;AAChC,MAAMC,UAAUD,QAAQE,cAAR,IAA0BR,OAAOO,OAAjD;AACA,MAAI,CAACA,OAAL,EAAc;AACZ,UAAM,IAAIE,KAAJ,CAAU,8EAAV,CAAN;AACD;;AAED,SAAO;AACLC,cAAU,kBAACC,QAAD,EAAWC,OAAX;AAAA,aACR,IAAIL,OAAJ,CAAY,UAACM,OAAD,EAAUC,MAAV,EAAqB;AAC/B,YAAMC,SAASH,QAAQN,OAAR,CAAgBU,WAA/B;AACA,YAAID,MAAJ,EAAY;AACVA,iBAAOV,OAAP,CAAeY,IAAf,CAAoB,kBAAU;AAC5BN,qBAASO,KAAT,CAAeC,OAAf,CAAuBC,MAAvB;AACAN,mBAAOM,MAAP;AACD,WAHD;AAID;;AAEDT,iBAASU,KAAT,CAAeC,SAAf,CAAyBR,MAAzB;AACAH,iBAASY,QAAT,CAAkBD,SAAlB,CAA4B,oBAAY;AACtCT,kBAAQP,QAAQkB,QAAR,GAAmBD,SAASE,IAA5B,GAAmCF,QAA3C;AACD,SAFD;;AAIA;AACAG,mBAAW,YAAM;AACf,cAAI;AACFf,qBAASgB,OAAT,CAAiBR,OAAjB,CAAyBP,OAAzB;AACD,WAFD,CAEE,OAAOgB,GAAP,EAAY;AACZd,mBAAOc,GAAP;AACD;AACF,SAND,EAMG,CANH;AAOD,OAtBD,CADQ;AAAA;AADL,GAAP;AA0BD,CAhCD;;AAkCAvB,QAAQH,MAAR,GAAiBA,MAAjB;AACAG,QAAQF,WAAR,GAAsBA,WAAtB;AACAE,QAAQD,QAAR,GAAmBA,QAAnB;;AAEAyB,OAAOC,OAAP,GAAiBzB,OAAjB","file":"promise.js","sourcesContent":["const global = require('../util/global')\nconst Cancel = require('./cancel/Cancel')\nconst CancelToken = require('./cancel/CancelToken')\nconst isCancel = require('./cancel/isCancel')\n\nconst promise = (options = {}) => {\n  const Promise = options.implementation || global.Promise\n  if (!Promise) {\n    throw new Error('`Promise` is not available in global scope, and no implementation was passed')\n  }\n\n  return {\n    onReturn: (channels, context) =>\n      new Promise((resolve, reject) => {\n        const cancel = context.options.cancelToken\n        if (cancel) {\n          cancel.promise.then(reason => {\n            channels.abort.publish(reason)\n            reject(reason)\n          })\n        }\n\n        channels.error.subscribe(reject)\n        channels.response.subscribe(response => {\n          resolve(options.onlyBody ? response.body : response)\n        })\n\n        // Wait until next tick in case cancel has been performed\n        setTimeout(() => {\n          try {\n            channels.request.publish(context)\n          } catch (err) {\n            reject(err)\n          }\n        }, 0)\n      })\n  }\n}\n\npromise.Cancel = Cancel\npromise.CancelToken = CancelToken\npromise.isCancel = isCancel\n\nmodule.exports = promise\n"]}