{"version":3,"sources":["../../src/request/browser-request.js"],"names":["sameOrigin","require","parseHeaders","noop","win","window","XmlHttpRequest","XMLHttpRequest","hasXhr2","XDomainRequest","adapter","module","exports","context","callback","opts","options","applyMiddleware","timers","cors","location","href","url","injectedResponse","undefined","cbTimer","setTimeout","cancel","clearTimeout","abort","xhr","isXdr","headers","aborted","loaded","timedOut","onerror","onError","ontimeout","onabort","onprogress","loadEvent","resetTimers","readyState","status","onLoad","open","method","withCredentials","setRequestHeader","key","hasOwnProperty","Error","rawBody","responseType","request","send","body","delays","timeout","connect","timeoutRequest","code","error","channels","publish","stopTimers","socket","err","isNetworkError","reduceResponse","statusCode","statusMessage","statusText","response","responseText","getAllResponseHeaders"],"mappings":"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","file":"browser-request.js","sourcesContent":["/* eslint max-depth: [\"error\", 4] */\nconst sameOrigin = require('same-origin')\nconst parseHeaders = require('parse-headers')\nconst noop = function() {\n  /* intentional noop */\n}\n\nconst win = window\nconst XmlHttpRequest = win.XMLHttpRequest || noop\nconst hasXhr2 = 'withCredentials' in new XmlHttpRequest()\nconst XDomainRequest = hasXhr2 ? XmlHttpRequest : win.XDomainRequest\nconst adapter = 'xhr'\n\nmodule.exports = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts)\n  const timers = {}\n\n  // Deep-checking window.location because of react native, where `location` doesn't exist\n  const cors = win && win.location && !sameOrigin(win.location.href, options.url)\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = cors ? new XDomainRequest() : new XmlHttpRequest()\n\n  const isXdr = win.XDomainRequest && xhr instanceof win.XDomainRequest\n  const headers = options.headers\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = onError\n  xhr.ontimeout = onError\n  xhr.onabort = () => {\n    aborted = true\n  }\n\n  // IE9 must have onprogress be set to a unique function\n  xhr.onprogress = () => {\n    /* intentional noop */\n  }\n\n  const loadEvent = isXdr ? 'onload' : 'onreadystatechange'\n  xhr[loadEvent] = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || (xhr.readyState !== 4 && !isXdr)) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method,\n    options.url,\n    true // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  } else if (headers && isXdr) {\n    throw new Error('Headers cannot be set on an XDomainRequest object')\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  const delays = options.timeout\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code) {\n    timedOut = true\n    xhr.abort()\n    const error = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers() {\n    // Only clear the connect timeout if we've got a connection\n    if (aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError() {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers()\n    loaded = true\n    xhr = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = new Error(`Network error while attempting to reach ${options.url}`)\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse() {\n    let statusCode = xhr.status\n    let statusMessage = xhr.statusText\n\n    if (isXdr && statusCode === undefined) {\n      // IE8 CORS GET successful response doesn't have a status field, but body is fine\n      statusCode = 200\n    } else if (statusCode > 12000 && statusCode < 12156) {\n      // Yet another IE quirk where it emits weird status codes on network errors\n      // https://support.microsoft.com/en-us/kb/193625\n      return onError()\n    } else {\n      // Another IE bug where HTTP 204 somehow ends up as 1223\n      statusCode = xhr.status === 1223 ? 204 : xhr.status\n      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage\n    }\n\n    return {\n      body: xhr.response || xhr.responseText,\n      url: options.url,\n      method: options.method,\n      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: statusCode,\n      statusMessage: statusMessage\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n"]}