import * as NodeTypes from '../nodeTypes';
import { Value } from './value';
export declare class Scope {
    params: {
        [key: string]: any;
    };
    source: any;
    value: Value;
    parent: Scope | null;
    timestamp: string;
    constructor(params: {
        [key: string]: any;
    }, source: any, value: Value, parent: Scope | null);
    createNested(value: Value): Scope;
}
export declare type Executor = (node: NodeTypes.SyntaxNode, scope: Scope) => Value | PromiseLike<Value>;
export declare type ExecutorMap = {
    This: (node: NodeTypes.ThisNode, scope: Scope) => Value | PromiseLike<Value>;
    Star: (node: NodeTypes.StarNode, scope: Scope) => Value | PromiseLike<Value>;
    Parameter: (node: NodeTypes.ParameterNode, scope: Scope) => Value | PromiseLike<Value>;
    Parent: (node: NodeTypes.ParentNode, scope: Scope) => Value | PromiseLike<Value>;
    OpCall: (node: NodeTypes.OpCallNode, scope: Scope) => Value | PromiseLike<Value>;
    FuncCall: (node: NodeTypes.FuncCallNode, scope: Scope) => Value | PromiseLike<Value>;
    PipeFuncCall: (node: NodeTypes.PipeFuncCallNode, scope: Scope) => Value | PromiseLike<Value>;
    Filter: (node: NodeTypes.FilterNode, scope: Scope) => Value | PromiseLike<Value>;
    Element: (node: NodeTypes.ElementNode, scope: Scope) => Value | PromiseLike<Value>;
    Slice: (node: NodeTypes.SliceNode, scope: Scope) => Value | PromiseLike<Value>;
    Attribute: (node: NodeTypes.AttributeNode, scope: Scope) => Value | PromiseLike<Value>;
    Identifier: (node: NodeTypes.IdentifierNode, scope: Scope) => Value | PromiseLike<Value>;
    Value: (node: NodeTypes.ValueNode, scope: Scope) => Value | PromiseLike<Value>;
    Mapper: (node: NodeTypes.MapperNode, scope: Scope) => Value | PromiseLike<Value>;
    Parenthesis: (node: NodeTypes.ParenthesisNode, scope: Scope) => Value | PromiseLike<Value>;
    Projection: (node: NodeTypes.ProjectionNode, scope: Scope) => Value | PromiseLike<Value>;
    Deref: (node: NodeTypes.DerefNode, scope: Scope) => Value | PromiseLike<Value>;
    Object: (node: NodeTypes.ObjectNode, scope: Scope) => Value | PromiseLike<Value>;
    Array: (node: NodeTypes.ArrayNode, scope: Scope) => Value | PromiseLike<Value>;
    Range: (node: NodeTypes.RangeNode, scope: Scope) => Value | PromiseLike<Value>;
    Pair: (node: NodeTypes.PairNode, scope: Scope) => Value | PromiseLike<Value>;
    Or: (node: NodeTypes.OrNode, scope: Scope) => Value | PromiseLike<Value>;
    And: (node: NodeTypes.AndNode, scope: Scope) => Value | PromiseLike<Value>;
    Not: (node: NodeTypes.NotNode, scope: Scope) => Value | PromiseLike<Value>;
    Neg: (node: NodeTypes.NegNode, scope: Scope) => Value | PromiseLike<Value>;
    Pos: (node: NodeTypes.PosNode, scope: Scope) => Value | PromiseLike<Value>;
    Asc: (node: NodeTypes.AscNode, scope: Scope) => Value | PromiseLike<Value>;
    Desc: (node: NodeTypes.DescNode, scope: Scope) => Value | PromiseLike<Value>;
    [key: string]: any;
};
interface EvaluateOptions {
    root?: any;
    dataset?: any;
    params?: {
        [key: string]: any;
    };
}
/**
 * Evaluates a query.
 */
export declare function evaluate(tree: NodeTypes.SyntaxNode, options?: EvaluateOptions): Promise<any>;
export {};
