{"version":3,"file":"sanity-diff-patch.cjs.production.min.js","sources":["../src/paths.ts","../src/diffError.ts","../src/validate.ts","../src/diffPatch.ts"],"sourcesContent":["import {KeyedSanityObject} from './diffPatch'\n\nexport type PathSegment = string | number | {_key: string} | [number | '', number | '']\nexport type Path = PathSegment[]\n\nexport function pathToString(path: Path): string {\n  return path.reduce((target: string, segment: PathSegment, i: number) => {\n    if (Array.isArray(segment)) {\n      return `${target}[${segment.join(':')}]`\n    }\n\n    if (isKeyedObject(segment)) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (typeof segment === 'number') {\n      return `${target}[${segment}]`\n    } else if (/^\\d+$/.test(segment)) {\n      return `${target}[\"${segment}\"]`\n    }\n\n    if (typeof segment === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    throw new Error(`Unsupported path segment \"${segment}\"`)\n  }, '')\n}\n\nfunction isKeyedObject(obj: any): obj is KeyedSanityObject {\n  return typeof obj === 'object' && typeof obj._key === 'string'\n}\n","import {Path, pathToString} from './paths'\n\nexport class DiffError extends Error {\n  public path: Path\n  public value: any\n  public serializedPath: string\n\n  constructor(message: string, path: Path, value?: any) {\n    const serializedPath = pathToString(path)\n    super(`${message} (at '${serializedPath}')`)\n\n    this.path = path\n    this.serializedPath = serializedPath\n    this.value = value\n  }\n}\n","import {DiffError} from './diffError'\nimport {Path} from './paths'\n\nconst idPattern = /^[a-z0-9][a-z0-9_.-]+$/i\nconst keyPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/\nconst keyStartPattern = /^[a-z_]/i\n\nexport function validateDocument(item: unknown, path: Path = []): boolean {\n  if (Array.isArray(item)) {\n    return item.every((child, i) => {\n      if (Array.isArray(child)) {\n        throw new DiffError('Multi-dimensional arrays not supported', path.concat(i))\n      }\n\n      return validateDocument(child, path.concat(i))\n    })\n  }\n\n  if (typeof item === 'object' && item !== null) {\n    const obj = item as {[key: string]: any}\n    return Object.keys(obj).every(\n      key => validateKey(key, obj[key], path) && validateDocument(obj[key], path.concat(key))\n    )\n  }\n\n  return true\n}\n\nexport function validateKey(key: string, value: any, path: Path): string {\n  if (!keyStartPattern.test(key)) {\n    throw new DiffError('Keys must start with a letter (a-z)', path.concat(key), value)\n  }\n\n  if (!keyPattern.test(key)) {\n    throw new DiffError(\n      'Keys can only contain letters, numbers and underscores',\n      path.concat(key),\n      value\n    )\n  }\n\n  if (key === '_key' || key === '_ref' || key === '_type') {\n    if (typeof value !== 'string') {\n      throw new DiffError('Keys must be strings', path.concat(key), value)\n    }\n\n    if (!idPattern.test(value)) {\n      throw new DiffError('Invalid key - use less exotic characters', path.concat(key), value)\n    }\n  }\n\n  return key\n}\n","import {diff_match_patch as DMP} from 'diff-match-patch'\nimport {DiffError} from './diffError'\nimport {Path, pathToString} from './paths'\nimport {validateKey} from './validate'\nimport {\n  Patch,\n  SetPatch,\n  UnsetPatch,\n  InsertPatch,\n  DiffMatchPatch,\n  SanityInsertPatch,\n  SanityPatch,\n  SanitySetPatch,\n  SanityUnsetPatch,\n  SanityDiffMatchPatch,\n  SanityPatchMutation\n} from './patches'\n\nconst ignoredKeys = ['_id', '_type', '_createdAt', '_updatedAt', '_rev']\n\ntype PrimitiveValue = string | number | boolean | null | undefined\n\nexport interface KeyedSanityObject {\n  [key: string]: unknown\n  _key: string\n}\n\nexport type SanityObject = KeyedSanityObject | Partial<KeyedSanityObject>\n\ninterface DocumentStub {\n  _id?: string\n  _type?: string\n  _rev?: string\n  _createdAt?: string\n  _updatedAt?: string\n  [key: string]: unknown\n}\n\ninterface DiffMatchPatchOptions {\n  enabled: boolean\n  lengthThresholdAbsolute: number\n  lengthThresholdRelative: number\n}\n\ninterface PatchOptions {\n  id?: string\n  basePath?: Path\n  ifRevisionID?: string | boolean\n  ifRevisionId?: string | boolean\n  hideWarnings?: boolean\n  diffMatchPatch: DiffMatchPatchOptions\n}\n\ntype InputOptions = {\n  id?: string\n  basePath?: Path\n  ifRevisionID?: string | boolean\n  ifRevisionId?: string | boolean\n  hideWarnings?: boolean\n  diffMatchPatch?: Partial<DiffMatchPatchOptions>\n}\n\nconst diff = new DMP()\n\nconst defaultOptions: PatchOptions = {\n  hideWarnings: false,\n  diffMatchPatch: {\n    enabled: true,\n\n    // Only use diff-match-patch if target string is longer than this threshold\n    lengthThresholdAbsolute: 30,\n\n    // Only use generated diff-match-patch if the patch length is less than or equal to\n    // (targetString * relative). Example: A 100 character target with a relative factor\n    // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,\n    // it will fall back to a regular `set` patch.\n    lengthThresholdRelative: 1.2\n  }\n}\n\nfunction mergeOptions(options: InputOptions) {\n  return {\n    ...defaultOptions,\n    ...options,\n    diffMatchPatch: {...defaultOptions.diffMatchPatch, ...(options.diffMatchPatch || {})}\n  }\n}\n\nexport function diffPatch(itemA: DocumentStub, itemB: DocumentStub, opts?: InputOptions) {\n  const options = opts ? mergeOptions(opts) : defaultOptions\n  const id = options.id || (itemA._id === itemB._id && itemA._id)\n  const revisionLocked = options.ifRevisionID || options.ifRevisionId\n  const ifRevisionID = typeof revisionLocked === 'boolean' ? itemA._rev : revisionLocked\n  const basePath = options.basePath || []\n  if (!id) {\n    throw new Error(\n      '_id on itemA and itemB not present or differs, specify document id the mutations should be applied to'\n    )\n  }\n\n  if (revisionLocked === true && !ifRevisionID) {\n    throw new Error(\n      '`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.'\n    )\n  }\n\n  if (basePath.length === 0 && itemA._type !== itemB._type) {\n    throw new Error(`_type is immutable and cannot be changed (${itemA._type} => ${itemB._type})`)\n  }\n\n  const operations = diffItem(itemA, itemB, options, basePath, [])\n  return serializePatches(operations, {id, ifRevisionID: revisionLocked ? ifRevisionID : undefined})\n}\n\nexport function diffItem(\n  itemA: unknown,\n  itemB: unknown,\n  options: PatchOptions = defaultOptions,\n  path: Path = [],\n  patches: Patch[] = []\n) {\n  if (itemA === itemB) {\n    return patches\n  }\n\n  const aType = Array.isArray(itemA) ? 'array' : typeof itemA\n  const bType = Array.isArray(itemB) ? 'array' : typeof itemB\n\n  const aIsUndefined = aType === 'undefined'\n  const bIsUndefined = bType === 'undefined'\n\n  if (aIsUndefined && !bIsUndefined) {\n    patches.push({op: 'set', path, value: itemB})\n    return patches\n  }\n\n  if (!aIsUndefined && bIsUndefined) {\n    patches.push({op: 'unset', path})\n    return patches\n  }\n\n  const dataType = aIsUndefined ? bType : aType\n  const isContainer = dataType === 'object' || dataType === 'array'\n  if (!isContainer) {\n    return diffPrimitive(itemA as PrimitiveValue, itemB as PrimitiveValue, options, path, patches)\n  }\n\n  if (aType !== bType) {\n    // Array => Object / Object => Array\n    patches.push({op: 'set', path, value: itemB})\n    return patches\n  }\n\n  return dataType === 'array'\n    ? diffArray(itemA as unknown[], itemB as unknown[], options, path, patches)\n    : diffObject(itemA as object, itemB as object, options, path, patches)\n}\n\nfunction diffObject(\n  itemA: SanityObject,\n  itemB: SanityObject,\n  options: PatchOptions,\n  path: Path,\n  patches: Patch[]\n) {\n  const atRoot = path.length === 0\n  const aKeys = Object.keys(itemA)\n    .filter(atRoot ? isNotIgnoredKey : yes)\n    .map(key => validateKey(key, itemA[key], path))\n\n  const aKeysLength = aKeys.length\n  const bKeys = Object.keys(itemB)\n    .filter(atRoot ? isNotIgnoredKey : yes)\n    .map(key => validateKey(key, itemB[key], path))\n\n  const bKeysLength = bKeys.length\n\n  // Check for deleted items\n  for (let i = 0; i < aKeysLength; i++) {\n    const key = aKeys[i]\n    if (!(key in itemB)) {\n      patches.push({op: 'unset', path: path.concat(key)})\n    }\n  }\n\n  // Check for changed items\n  for (let i = 0; i < bKeysLength; i++) {\n    const key = bKeys[i]\n    diffItem(itemA[key], itemB[key], options, path.concat([key]), patches)\n  }\n\n  return patches\n}\n\nfunction diffArray(\n  itemA: unknown[],\n  itemB: unknown[],\n  options: PatchOptions,\n  path: Path,\n  patches: Patch[]\n) {\n  // Check for new items\n  if (itemB.length > itemA.length) {\n    patches.push({\n      op: 'insert',\n      after: path.concat([-1]),\n      items: itemB.slice(itemA.length).map((item, i) => nullifyUndefined(item, path, i, options))\n    })\n  }\n\n  // Check for deleted items\n  if (itemB.length < itemA.length) {\n    const isSingle = itemA.length - itemB.length === 1\n    const unsetItems = itemA.slice(itemB.length)\n\n    // If we're revision locked, we can safely unset ranges (eg 5:<end-of-array>).\n    // Also, if we don't have unique array keys, we can't use any better approach\n    // than array indexes. If we _do_ have unique array keys, we'll want to unset\n    // by key, as this is safer in a realtime, collaborative setting\n    if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {\n      patches.push({\n        op: 'unset',\n        path: path.concat([isSingle ? itemB.length : [itemB.length, '']])\n      })\n    } else {\n      patches.push(\n        ...unsetItems.map(\n          (item): UnsetPatch => ({op: 'unset', path: path.concat({_key: item._key})})\n        )\n      )\n    }\n  }\n\n  // Check for illegal array contents\n  for (let i = 0; i < itemB.length; i++) {\n    if (Array.isArray(itemB[i])) {\n      throw new DiffError('Multi-dimensional arrays not supported', path.concat(i), itemB[i])\n    }\n  }\n\n  const overlapping = Math.min(itemA.length, itemB.length)\n  const segmentA = itemA.slice(0, overlapping)\n  const segmentB = itemB.slice(0, overlapping)\n\n  return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB)\n    ? diffArrayByKey(segmentA, segmentB, options, path, patches)\n    : diffArrayByIndex(segmentA, segmentB, options, path, patches)\n}\n\nfunction diffArrayByIndex(\n  itemA: unknown[],\n  itemB: unknown[],\n  options: PatchOptions,\n  path: Path,\n  patches: Patch[]\n) {\n  for (let i = 0; i < itemA.length; i++) {\n    diffItem(\n      itemA[i],\n      nullifyUndefined(itemB[i], path, i, options),\n      options,\n      path.concat(i),\n      patches\n    )\n  }\n\n  return patches\n}\n\nfunction diffArrayByKey(\n  itemA: KeyedSanityObject[],\n  itemB: KeyedSanityObject[],\n  options: PatchOptions,\n  path: Path,\n  patches: Patch[]\n) {\n  const keyedA = indexByKey(itemA)\n  const keyedB = indexByKey(itemB)\n\n  // There's a bunch of hard/semi-hard problems related to using keys\n  // Unless we have the exact same order, just use indexes for now\n  if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {\n    return diffArrayByIndex(itemA, itemB, options, path, patches)\n  }\n\n  for (let i = 0; i < keyedB.keys.length; i++) {\n    const key = keyedB.keys[i]\n    const valueA = keyedA.index[key]\n    const valueB = nullifyUndefined(keyedB.index[key], path, i, options)\n    diffItem(valueA, valueB, options, path.concat({_key: key}), patches)\n  }\n\n  return patches\n}\n\nfunction getDiffMatchPatch(\n  itemA: PrimitiveValue,\n  itemB: PrimitiveValue,\n  options: PatchOptions,\n  path: Path\n): DiffMatchPatch | undefined {\n  const {enabled, lengthThresholdRelative, lengthThresholdAbsolute} = options.diffMatchPatch\n  const segment = path[path.length - 1]\n  if (\n    !enabled ||\n    // Don't use for anything but strings\n    typeof itemA !== 'string' ||\n    typeof itemB !== 'string' ||\n    // Don't use for `_key`, `_ref` etc\n    (typeof segment === 'string' && segment[0] === '_') ||\n    // Don't use on short strings\n    itemB.length < lengthThresholdAbsolute\n  ) {\n    return undefined\n  }\n\n  let strPatch = ''\n  try {\n    const patch = diff.diff_main(itemA, itemB)\n    diff.diff_cleanupEfficiency(patch)\n    strPatch = diff.patch_toText(diff.patch_make(patch))\n  } catch (err) {\n    // Fall back to using regular set patch\n    return undefined\n  }\n\n  // Don't use patch if it's longer than allowed relative threshold.\n  // Allow a 120 character patch for a 100 character string,\n  // but don't allow a 800 character patch for a 500 character value.\n  //console.log('%s:\\n patch is %d, string is %d', itemB, strPatch.length, itemB.length)\n  return strPatch.length > itemB.length * lengthThresholdRelative\n    ? undefined\n    : {op: 'diffMatchPatch', path, value: strPatch}\n}\n\nfunction diffPrimitive(\n  itemA: PrimitiveValue,\n  itemB: PrimitiveValue,\n  options: PatchOptions,\n  path: Path,\n  patches: Patch[]\n): Patch[] {\n  const dmp = getDiffMatchPatch(itemA, itemB, options, path)\n\n  patches.push(\n    dmp || {\n      op: 'set',\n      path,\n      value: itemB\n    }\n  )\n\n  return patches\n}\n\nfunction isNotIgnoredKey(key: string) {\n  return ignoredKeys.indexOf(key) === -1\n}\n\nfunction serializePatches(\n  patches: Patch[],\n  options: {id: string; ifRevisionID?: string}\n): SanityPatchMutation[] {\n  if (patches.length === 0) {\n    return []\n  }\n\n  const {id, ifRevisionID} = options\n  const set = patches.filter((patch): patch is SetPatch => patch.op === 'set')\n  const unset = patches.filter((patch): patch is UnsetPatch => patch.op === 'unset')\n  const insert = patches.filter((patch): patch is InsertPatch => patch.op === 'insert')\n  const dmp = patches.filter((patch): patch is DiffMatchPatch => patch.op === 'diffMatchPatch')\n\n  const withSet =\n    set.length > 0 &&\n    set.reduce(\n      (patch: SanitySetPatch, item: SetPatch) => {\n        const path = pathToString(item.path)\n        patch.set[path] = item.value\n        return patch\n      },\n      {id, set: {}}\n    )\n\n  const withUnset =\n    unset.length > 0 &&\n    unset.reduce(\n      (patch: SanityUnsetPatch, item: UnsetPatch) => {\n        const path = pathToString(item.path)\n        patch.unset.push(path)\n        return patch\n      },\n      {id, unset: []}\n    )\n\n  const withInsert = insert.reduce((acc: SanityInsertPatch[], item: InsertPatch) => {\n    const after = pathToString(item.after)\n    return acc.concat({id, insert: {after, items: item.items}})\n  }, [])\n\n  const withDmp =\n    dmp.length > 0 &&\n    dmp.reduce(\n      (patch: SanityDiffMatchPatch, item: DiffMatchPatch) => {\n        const path = pathToString(item.path)\n        patch.diffMatchPatch[path] = item.value\n        return patch\n      },\n      {id, diffMatchPatch: {}}\n    )\n\n  const patchSet: SanityPatch[] = [withSet, withUnset, withDmp, ...withInsert].filter(\n    (item): item is SanityPatch => item !== false\n  )\n\n  return patchSet.map((patch, i) => ({\n    patch: ifRevisionID && i === 0 ? {...patch, ifRevisionID} : patch\n  }))\n}\n\nfunction isUniquelyKeyed(arr: unknown[]): arr is KeyedSanityObject[] {\n  const keys = []\n\n  for (let i = 0; i < arr.length; i++) {\n    const key = getKey(arr[i])\n    if (!key || keys.indexOf(key) !== -1) {\n      return false\n    }\n\n    keys.push(key)\n  }\n\n  return true\n}\n\nfunction getKey(obj: unknown) {\n  return typeof obj === 'object' && obj !== null && (obj as KeyedSanityObject)._key\n}\n\nfunction indexByKey(arr: KeyedSanityObject[]) {\n  return arr.reduce(\n    (acc, item) => {\n      acc.keys.push(item._key)\n      acc.index[item._key] = item\n      return acc\n    },\n    {keys: [] as string[], index: {} as {[key: string]: KeyedSanityObject}}\n  )\n}\n\nfunction arrayIsEqual(itemA: unknown[], itemB: unknown[]) {\n  return itemA.length === itemB.length && itemA.every((item, i) => itemB[i] === item)\n}\n\nfunction nullifyUndefined(item: unknown, path: Path, index: number, options: PatchOptions) {\n  if (typeof item !== 'undefined') {\n    return item\n  }\n\n  if (!options.hideWarnings) {\n    const serializedPath = pathToString(path.concat(index))\n    console.warn(`undefined value in array converted to null (at '${serializedPath}')`)\n  }\n\n  return null\n}\n\nfunction isRevisionLocked(options: PatchOptions): boolean {\n  return Boolean(options.ifRevisionID || options.ifRevisionId)\n}\n\nfunction yes(_: unknown) {\n  return true\n}\n"],"names":["pathToString","path","reduce","target","segment","i","Array","isArray","join","obj","_key","test","Error","DiffError","message","value","serializedPath","idPattern","keyPattern","keyStartPattern","validateKey","key","concat","ignoredKeys","diff","DMP","defaultOptions","hideWarnings","diffMatchPatch","enabled","lengthThresholdAbsolute","lengthThresholdRelative","diffItem","itemA","itemB","options","patches","aType","bType","aIsUndefined","bIsUndefined","push","op","dataType","length","after","items","slice","map","item","nullifyUndefined","isSingle","unsetItems","Boolean","ifRevisionID","ifRevisionId","isRevisionLocked","isUniquelyKeyed","overlapping","Math","min","segmentA","segmentB","keyedA","indexByKey","keyedB","every","arrayIsEqual","keys","diffArrayByIndex","index","diffArrayByKey","diffArray","atRoot","aKeys","Object","filter","isNotIgnoredKey","yes","aKeysLength","bKeys","bKeysLength","diffObject","dmp","strPatch","patch","diff_main","diff_cleanupEfficiency","patch_toText","patch_make","err","undefined","getDiffMatchPatch","diffPrimitive","indexOf","arr","acc","console","warn","_","opts","mergeOptions","id","_id","revisionLocked","_rev","basePath","_type","set","unset","insert","withSet","withUnset","withInsert","serializePatches","validateDocument","child"],"mappings":"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"}