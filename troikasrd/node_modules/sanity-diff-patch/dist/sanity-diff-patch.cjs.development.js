'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var diffMatchPatch = require('diff-match-patch');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function pathToString(path) {
  return path.reduce(function (target, segment, i) {
    if (Array.isArray(segment)) {
      return target + "[" + segment.join(':') + "]";
    }

    if (isKeyedObject(segment)) {
      return target + "[_key==\"" + segment._key + "\"]";
    }

    if (typeof segment === 'number') {
      return target + "[" + segment + "]";
    } else if (/^\d+$/.test(segment)) {
      return target + "[\"" + segment + "\"]";
    }

    if (typeof segment === 'string') {
      var separator = i === 0 ? '' : '.';
      return "" + target + separator + segment;
    }

    throw new Error("Unsupported path segment \"" + segment + "\"");
  }, '');
}

function isKeyedObject(obj) {
  return typeof obj === 'object' && typeof obj._key === 'string';
}

var DiffError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(DiffError, _Error);

  function DiffError(message, path, value) {
    var _this;

    var serializedPath = pathToString(path);
    _this = _Error.call(this, message + " (at '" + serializedPath + "')") || this;
    _this.path = path;
    _this.serializedPath = serializedPath;
    _this.value = value;
    return _this;
  }

  return DiffError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var idPattern = /^[a-z0-9][a-z0-9_.-]+$/i;
var keyPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
var keyStartPattern = /^[a-z_]/i;
function validateDocument(item, path) {
  if (path === void 0) {
    path = [];
  }

  if (Array.isArray(item)) {
    return item.every(function (child, i) {
      if (Array.isArray(child)) {
        throw new DiffError('Multi-dimensional arrays not supported', path.concat(i));
      }

      return validateDocument(child, path.concat(i));
    });
  }

  if (typeof item === 'object' && item !== null) {
    var obj = item;
    return Object.keys(obj).every(function (key) {
      return validateKey(key, obj[key], path) && validateDocument(obj[key], path.concat(key));
    });
  }

  return true;
}
function validateKey(key, value, path) {
  if (!keyStartPattern.test(key)) {
    throw new DiffError('Keys must start with a letter (a-z)', path.concat(key), value);
  }

  if (!keyPattern.test(key)) {
    throw new DiffError('Keys can only contain letters, numbers and underscores', path.concat(key), value);
  }

  if (key === '_key' || key === '_ref' || key === '_type') {
    if (typeof value !== 'string') {
      throw new DiffError('Keys must be strings', path.concat(key), value);
    }

    if (!idPattern.test(value)) {
      throw new DiffError('Invalid key - use less exotic characters', path.concat(key), value);
    }
  }

  return key;
}

var ignoredKeys = ['_id', '_type', '_createdAt', '_updatedAt', '_rev'];
var diff = /*#__PURE__*/new diffMatchPatch.diff_match_patch();
var defaultOptions = {
  hideWarnings: false,
  diffMatchPatch: {
    enabled: true,
    // Only use diff-match-patch if target string is longer than this threshold
    lengthThresholdAbsolute: 30,
    // Only use generated diff-match-patch if the patch length is less than or equal to
    // (targetString * relative). Example: A 100 character target with a relative factor
    // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,
    // it will fall back to a regular `set` patch.
    lengthThresholdRelative: 1.2
  }
};

function mergeOptions(options) {
  return _extends({}, defaultOptions, options, {
    diffMatchPatch: _extends({}, defaultOptions.diffMatchPatch, options.diffMatchPatch || {})
  });
}

function diffPatch(itemA, itemB, opts) {
  var options = opts ? mergeOptions(opts) : defaultOptions;
  var id = options.id || itemA._id === itemB._id && itemA._id;
  var revisionLocked = options.ifRevisionID || options.ifRevisionId;
  var ifRevisionID = typeof revisionLocked === 'boolean' ? itemA._rev : revisionLocked;
  var basePath = options.basePath || [];

  if (!id) {
    throw new Error('_id on itemA and itemB not present or differs, specify document id the mutations should be applied to');
  }

  if (revisionLocked === true && !ifRevisionID) {
    throw new Error('`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.');
  }

  if (basePath.length === 0 && itemA._type !== itemB._type) {
    throw new Error("_type is immutable and cannot be changed (" + itemA._type + " => " + itemB._type + ")");
  }

  var operations = diffItem(itemA, itemB, options, basePath, []);
  return serializePatches(operations, {
    id: id,
    ifRevisionID: revisionLocked ? ifRevisionID : undefined
  });
}
function diffItem(itemA, itemB, options, path, patches) {
  if (options === void 0) {
    options = defaultOptions;
  }

  if (path === void 0) {
    path = [];
  }

  if (patches === void 0) {
    patches = [];
  }

  if (itemA === itemB) {
    return patches;
  }

  var aType = Array.isArray(itemA) ? 'array' : typeof itemA;
  var bType = Array.isArray(itemB) ? 'array' : typeof itemB;
  var aIsUndefined = aType === 'undefined';
  var bIsUndefined = bType === 'undefined';

  if (aIsUndefined && !bIsUndefined) {
    patches.push({
      op: 'set',
      path: path,
      value: itemB
    });
    return patches;
  }

  if (!aIsUndefined && bIsUndefined) {
    patches.push({
      op: 'unset',
      path: path
    });
    return patches;
  }

  var dataType = aIsUndefined ? bType : aType;
  var isContainer = dataType === 'object' || dataType === 'array';

  if (!isContainer) {
    return diffPrimitive(itemA, itemB, options, path, patches);
  }

  if (aType !== bType) {
    // Array => Object / Object => Array
    patches.push({
      op: 'set',
      path: path,
      value: itemB
    });
    return patches;
  }

  return dataType === 'array' ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches);
}

function diffObject(itemA, itemB, options, path, patches) {
  var atRoot = path.length === 0;
  var aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map(function (key) {
    return validateKey(key, itemA[key], path);
  });
  var aKeysLength = aKeys.length;
  var bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map(function (key) {
    return validateKey(key, itemB[key], path);
  });
  var bKeysLength = bKeys.length; // Check for deleted items

  for (var i = 0; i < aKeysLength; i++) {
    var key = aKeys[i];

    if (!(key in itemB)) {
      patches.push({
        op: 'unset',
        path: path.concat(key)
      });
    }
  } // Check for changed items


  for (var _i = 0; _i < bKeysLength; _i++) {
    var _key = bKeys[_i];
    diffItem(itemA[_key], itemB[_key], options, path.concat([_key]), patches);
  }

  return patches;
}

function diffArray(itemA, itemB, options, path, patches) {
  // Check for new items
  if (itemB.length > itemA.length) {
    patches.push({
      op: 'insert',
      after: path.concat([-1]),
      items: itemB.slice(itemA.length).map(function (item, i) {
        return nullifyUndefined(item, path, i, options);
      })
    });
  } // Check for deleted items


  if (itemB.length < itemA.length) {
    var isSingle = itemA.length - itemB.length === 1;
    var unsetItems = itemA.slice(itemB.length); // If we're revision locked, we can safely unset ranges (eg 5:<end-of-array>).
    // Also, if we don't have unique array keys, we can't use any better approach
    // than array indexes. If we _do_ have unique array keys, we'll want to unset
    // by key, as this is safer in a realtime, collaborative setting

    if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {
      patches.push({
        op: 'unset',
        path: path.concat([isSingle ? itemB.length : [itemB.length, '']])
      });
    } else {
      patches.push.apply(patches, unsetItems.map(function (item) {
        return {
          op: 'unset',
          path: path.concat({
            _key: item._key
          })
        };
      }));
    }
  } // Check for illegal array contents


  for (var i = 0; i < itemB.length; i++) {
    if (Array.isArray(itemB[i])) {
      throw new DiffError('Multi-dimensional arrays not supported', path.concat(i), itemB[i]);
    }
  }

  var overlapping = Math.min(itemA.length, itemB.length);
  var segmentA = itemA.slice(0, overlapping);
  var segmentB = itemB.slice(0, overlapping);
  return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);
}

function diffArrayByIndex(itemA, itemB, options, path, patches) {
  for (var i = 0; i < itemA.length; i++) {
    diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);
  }

  return patches;
}

function diffArrayByKey(itemA, itemB, options, path, patches) {
  var keyedA = indexByKey(itemA);
  var keyedB = indexByKey(itemB); // There's a bunch of hard/semi-hard problems related to using keys
  // Unless we have the exact same order, just use indexes for now

  if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {
    return diffArrayByIndex(itemA, itemB, options, path, patches);
  }

  for (var i = 0; i < keyedB.keys.length; i++) {
    var key = keyedB.keys[i];
    var valueA = keyedA.index[key];
    var valueB = nullifyUndefined(keyedB.index[key], path, i, options);
    diffItem(valueA, valueB, options, path.concat({
      _key: key
    }), patches);
  }

  return patches;
}

function getDiffMatchPatch(itemA, itemB, options, path) {
  var _options$diffMatchPat = options.diffMatchPatch,
      enabled = _options$diffMatchPat.enabled,
      lengthThresholdRelative = _options$diffMatchPat.lengthThresholdRelative,
      lengthThresholdAbsolute = _options$diffMatchPat.lengthThresholdAbsolute;
  var segment = path[path.length - 1];

  if (!enabled || // Don't use for anything but strings
  typeof itemA !== 'string' || typeof itemB !== 'string' || // Don't use for `_key`, `_ref` etc
  typeof segment === 'string' && segment[0] === '_' || // Don't use on short strings
  itemB.length < lengthThresholdAbsolute) {
    return undefined;
  }

  var strPatch = '';

  try {
    var patch = diff.diff_main(itemA, itemB);
    diff.diff_cleanupEfficiency(patch);
    strPatch = diff.patch_toText(diff.patch_make(patch));
  } catch (err) {
    // Fall back to using regular set patch
    return undefined;
  } // Don't use patch if it's longer than allowed relative threshold.
  // Allow a 120 character patch for a 100 character string,
  // but don't allow a 800 character patch for a 500 character value.
  //console.log('%s:\n patch is %d, string is %d', itemB, strPatch.length, itemB.length)


  return strPatch.length > itemB.length * lengthThresholdRelative ? undefined : {
    op: 'diffMatchPatch',
    path: path,
    value: strPatch
  };
}

function diffPrimitive(itemA, itemB, options, path, patches) {
  var dmp = getDiffMatchPatch(itemA, itemB, options, path);
  patches.push(dmp || {
    op: 'set',
    path: path,
    value: itemB
  });
  return patches;
}

function isNotIgnoredKey(key) {
  return ignoredKeys.indexOf(key) === -1;
}

function serializePatches(patches, options) {
  if (patches.length === 0) {
    return [];
  }

  var id = options.id,
      ifRevisionID = options.ifRevisionID;
  var set = patches.filter(function (patch) {
    return patch.op === 'set';
  });
  var unset = patches.filter(function (patch) {
    return patch.op === 'unset';
  });
  var insert = patches.filter(function (patch) {
    return patch.op === 'insert';
  });
  var dmp = patches.filter(function (patch) {
    return patch.op === 'diffMatchPatch';
  });
  var withSet = set.length > 0 && set.reduce(function (patch, item) {
    var path = pathToString(item.path);
    patch.set[path] = item.value;
    return patch;
  }, {
    id: id,
    set: {}
  });
  var withUnset = unset.length > 0 && unset.reduce(function (patch, item) {
    var path = pathToString(item.path);
    patch.unset.push(path);
    return patch;
  }, {
    id: id,
    unset: []
  });
  var withInsert = insert.reduce(function (acc, item) {
    var after = pathToString(item.after);
    return acc.concat({
      id: id,
      insert: {
        after: after,
        items: item.items
      }
    });
  }, []);
  var withDmp = dmp.length > 0 && dmp.reduce(function (patch, item) {
    var path = pathToString(item.path);
    patch.diffMatchPatch[path] = item.value;
    return patch;
  }, {
    id: id,
    diffMatchPatch: {}
  });
  var patchSet = [withSet, withUnset, withDmp].concat(withInsert).filter(function (item) {
    return item !== false;
  });
  return patchSet.map(function (patch, i) {
    return {
      patch: ifRevisionID && i === 0 ? _extends({}, patch, {
        ifRevisionID: ifRevisionID
      }) : patch
    };
  });
}

function isUniquelyKeyed(arr) {
  var keys = [];

  for (var i = 0; i < arr.length; i++) {
    var key = getKey(arr[i]);

    if (!key || keys.indexOf(key) !== -1) {
      return false;
    }

    keys.push(key);
  }

  return true;
}

function getKey(obj) {
  return typeof obj === 'object' && obj !== null && obj._key;
}

function indexByKey(arr) {
  return arr.reduce(function (acc, item) {
    acc.keys.push(item._key);
    acc.index[item._key] = item;
    return acc;
  }, {
    keys: [],
    index: {}
  });
}

function arrayIsEqual(itemA, itemB) {
  return itemA.length === itemB.length && itemA.every(function (item, i) {
    return itemB[i] === item;
  });
}

function nullifyUndefined(item, path, index, options) {
  if (typeof item !== 'undefined') {
    return item;
  }

  if (!options.hideWarnings) {
    var serializedPath = pathToString(path.concat(index));
    console.warn("undefined value in array converted to null (at '" + serializedPath + "')");
  }

  return null;
}

function isRevisionLocked(options) {
  return Boolean(options.ifRevisionID || options.ifRevisionId);
}

function yes(_) {
  return true;
}

exports.DiffError = DiffError;
exports.diffItem = diffItem;
exports.diffPatch = diffPatch;
exports.pathToString = pathToString;
exports.validateDocument = validateDocument;
//# sourceMappingURL=sanity-diff-patch.cjs.development.js.map
