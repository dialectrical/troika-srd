"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasPTMemberType = hasPTMemberType;
exports.isPTSchemaType = isPTSchemaType;
exports.isHeader = isHeader;
exports.findChildDiff = findChildDiff;
exports.getChildSchemaType = getChildSchemaType;
exports.getDecorators = getDecorators;
exports.getAnnotations = getAnnotations;
exports.isDecorator = isDecorator;
exports.blockToSymbolizedText = blockToSymbolizedText;
exports.createPortableTextDiff = createPortableTextDiff;
exports.getInlineObjects = getInlineObjects;
exports.findSpanDiffFromChild = findSpanDiffFromChild;
exports.findAnnotationDiff = findAnnotationDiff;
exports.isEmptyObject = isEmptyObject;
exports.escapeRegExp = escapeRegExp;
exports.getAllMarkDefs = getAllMarkDefs;
exports.UNKNOWN_TYPE_NAME = void 0;

var _orderBy2 = _interopRequireDefault(require("lodash/orderBy"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _diffMatchPatch = require("diff-match-patch");

var TextSymbols = _interopRequireWildcard(require("./symbols"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var dmp = new _diffMatchPatch.diff_match_patch();
var UNKNOWN_TYPE_NAME = '_UNKOWN_TYPE_';
exports.UNKNOWN_TYPE_NAME = UNKNOWN_TYPE_NAME;

function hasPTMemberType(schemaType) {
  return schemaType.of.some(isPTSchemaType);
}

var startMarkSymbols = TextSymbols.DECORATOR_SYMBOLS.map(set => set[0]).concat(TextSymbols.ANNOTATION_SYMBOLS.map(set => set[0]));
var endMarkSymbols = TextSymbols.DECORATOR_SYMBOLS.map(set => set[1]).concat(TextSymbols.ANNOTATION_SYMBOLS.map(set => set[1]));
var allSymbols = startMarkSymbols.concat(endMarkSymbols).concat(TextSymbols.INLINE_SYMBOLS).concat(TextSymbols.CHILD_SYMBOL).concat(TextSymbols.SEGMENT_START_SYMBOL);
var symbolRegex = new RegExp("".concat(allSymbols.join('|')), 'g');
var segmentRegex = new RegExp("".concat(allSymbols.join('|'), "|\n"), 'g');

function isPTSchemaType(schemaType) {
  return schemaType.jsonType === 'object' && schemaType.name === 'block';
}

function isHeader(node) {
  return !!node.style && ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(node.style);
}

function findChildDiff(diff, child) {
  var childrenDiff = diff.fields.children;
  return childrenDiff.items.filter(item => item.diff.isChanged && (item.diff.toValue === child || item.diff.fromValue === child)).map(item => item.diff).map(childDiff => childDiff)[0];
}

function getChildSchemaType(fields, child) {
  var childrenField = fields.find(f => f.name === 'children');
  var cSchemaType = childrenField && childrenField.type && childrenField.type.jsonType === 'array' && childrenField.type.of.find(type => type.name === child._type) || undefined;
  return cSchemaType;
}

function getDecorators(spanSchemaType) {
  if (spanSchemaType.decorators) {
    return (0, _orderBy2.default)(spanSchemaType.decorators, ['value'], ['asc']);
  }

  return [];
}

function getAnnotations(spanSchemaType) {
  if (spanSchemaType.annotations) {
    return (0, _orderBy2.default)(spanSchemaType.annotations, ['name'], ['asc']);
  }

  return [];
}

function isDecorator(name, schemaType) {
  return getDecorators(schemaType).some(dec => dec.value === name);
}

function blockToSymbolizedText(diff, block, decoratorMap, annotationMap, inlineMap) {
  if (!block) {
    return '';
  }

  return block.children.map(child => {
    var _child$text;

    var returned = ((_child$text = child.text) === null || _child$text === void 0 ? void 0 : _child$text.replace(symbolRegex, '')) || ''; // Make sure symbols aren't in the text already

    if (child._type === 'span') {
      // Attatch stringdiff segments
      var spanDiff = findSpanDiffFromChild(diff, child);
      var textDiff = spanDiff === null || spanDiff === void 0 ? void 0 : spanDiff.fields.text;

      if (textDiff && textDiff.toValue === child.text && textDiff.type === 'string' && textDiff.action !== 'unchanged') {
        returned = textDiff.segments.filter(seg => seg.action !== 'removed').map(seg => seg.text.replace(symbolRegex, '')).join(TextSymbols.SEGMENT_START_SYMBOL);
      }

      if (child.marks) {
        child.marks.forEach(mark => {
          var _isDecorator = !!decoratorMap[mark];

          if (_isDecorator) {
            returned = "".concat(decoratorMap[mark][0]).concat(returned).concat(decoratorMap[mark][1]);
          } else if (annotationMap[mark]) {
            returned = "".concat(annotationMap[mark][0]).concat(returned).concat(annotationMap[mark][1]);
          }
        });
      }
    } else {
      returned = inlineMap[child._key];
    }

    return "".concat(TextSymbols.CHILD_SYMBOL).concat(returned);
  }).join('');
}

function createPortableTextDiff(diff, schemaType) {
  var displayValue = diff.action === 'removed' ? diff.fromValue : diff.toValue;

  var _diff = _objectSpread(_objectSpread({}, diff), {}, {
    origin: diff,
    displayValue
  });

  if (displayValue) {
    var annotationMap = {};
    var decoratorMap = {};
    var inlineMap = {};
    var spanSchemaType = getChildSchemaType(schemaType.fields, {
      _key: 'bogus',
      _type: 'span'
    });

    if (spanSchemaType) {
      getDecorators(spanSchemaType).forEach((dec, index) => {
        decoratorMap[dec.value] = TextSymbols.DECORATOR_SYMBOLS[index];
      });
    }

    var allMarkDefs = getAllMarkDefs(_diff.origin);
    allMarkDefs.forEach((markDef, index) => {
      annotationMap[markDef._key] = TextSymbols.ANNOTATION_SYMBOLS[index];
    });
    var inlines = getInlineObjects(_diff.origin);
    inlines.forEach((inline, index) => {
      inlineMap[inline._key] = TextSymbols.INLINE_SYMBOLS[index];
    });
    var fromText = blockToSymbolizedText(_diff.origin, _diff.fromValue, decoratorMap, annotationMap, inlineMap);
    var toText = blockToSymbolizedText(_diff.origin, _diff.toValue, decoratorMap, annotationMap, inlineMap);

    var toPseudoValue = _objectSpread(_objectSpread({}, displayValue), {}, {
      children: [{
        _type: 'span',
        _key: 'pseudoSpanKey',
        text: toText,
        marks: []
      }]
    });

    var fromPseudoValue = {
      displayValue,
      children: [{
        _type: 'span',
        _key: 'pseudoSpanKey',
        text: fromText,
        marks: []
      }]
    };
    var pseudoDiff = {
      origin: diff,
      action: 'changed',
      type: 'object',
      displayValue: toPseudoValue,
      fromValue: fromPseudoValue,
      toValue: toPseudoValue,
      isChanged: true,
      fields: {
        children: {
          action: 'changed',
          type: 'array',
          isChanged: true,
          items: [{
            diff: {
              action: 'changed',
              type: 'object',
              isChanged: true,
              fields: {
                text: {
                  type: 'string',
                  action: 'changed',
                  isChanged: true,
                  fromValue: fromText,
                  toValue: toText,
                  segments: buildSegments(fromText, toText).map(seg => _objectSpread(_objectSpread({}, seg), _diff.action !== 'unchanged' && _diff.annotation ? {
                    annotation: _diff.annotation
                  } // Fallback if we can't find a spesific original diff
                  : {}))
                }
              },
              fromValue: fromPseudoValue.children[0],
              toValue: toPseudoValue.children[0]
            },
            annotation: null,
            fromIndex: 0,
            toIndex: 0,
            hasMoved: false
          }],
          fromValue: fromPseudoValue.children,
          toValue: toPseudoValue.children
        }
      }
    };
    return pseudoDiff;
  }

  throw new Error('Can not display this diff');
}

function buildSegments(fromInput, toInput) {
  var segments = [];
  var dmpDiffs = dmp.diff_main(fromInput, toInput);
  dmp.diff_cleanupEfficiency(dmpDiffs);
  var fromIdx = 0;
  var toIdx = 0;

  var _iterator = _createForOfIteratorHelper(dmpDiffs),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          op = _step$value[0],
          text = _step$value[1];

      switch (op) {
        case _diffMatchPatch.DIFF_EQUAL:
          segments.push({
            type: 'stringSegment',
            action: 'unchanged',
            text
          });
          fromIdx += text.length;
          toIdx += text.length;
          break;

        case _diffMatchPatch.DIFF_DELETE:
          segments.push({
            type: 'stringSegment',
            action: 'removed',
            text: fromInput.substring(fromIdx, fromIdx + text.length),
            annotation: null
          });
          fromIdx += text.length;
          break;

        case _diffMatchPatch.DIFF_INSERT:
          segments.push({
            type: 'stringSegment',
            action: 'added',
            text: toInput.substring(toIdx, toIdx + text.length),
            annotation: null
          });
          toIdx += text.length;
          break;

        default: // Do nothing

      }
    } // Clean up so that marks / symbols are treated as an own segment

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return (0, _flatten2.default)(segments.map(seg => {
    var newSegments = [];

    if (seg.text.length > 1) {
      var markMatches = [...seg.text.matchAll(segmentRegex)];
      var lastIndex = -1;
      markMatches.forEach(match => {
        var index = match.index || 0;

        if (index > lastIndex) {
          newSegments.push(_objectSpread(_objectSpread({}, seg), {}, {
            text: seg.text.substring(lastIndex + 1, index)
          }));
          newSegments.push(_objectSpread(_objectSpread({}, seg), {}, {
            text: match[0]
          }));
        }

        if (match === markMatches[markMatches.length - 1]) {
          newSegments.push(_objectSpread(_objectSpread({}, seg), {}, {
            text: seg.text.substring(index + 1)
          }));
        }

        lastIndex = index;
      });

      if (markMatches.length === 0) {
        newSegments.push(seg);
      }
    } else {
      newSegments.push(seg);
    }

    return newSegments;
  }));
}

function getInlineObjects(diff) {
  var allChildren = [...(diff.toValue ? diff.toValue.children.filter(cld => cld._type !== 'span') : [])];
  var previousChildren = diff.fromValue ? diff.fromValue.children.filter(cld => cld._type !== 'span') : [];
  previousChildren.forEach(oCld => {
    if (!allChildren.some(cld => oCld._key === cld._key)) {
      allChildren.push(oCld);
    }
  });
  return (0, _orderBy2.default)(allChildren, ['_key'], ['asc']);
}

function findSpanDiffFromChild(diff, child) {
  // Find span in original diff which has a string segment similar to the one from the input
  var candidate = diff.fields.children && diff.fields.children.action !== 'unchanged' && diff.fields.children.type === 'array' && diff.fields.children.items.find(item => item.diff && item.diff.type === 'object' && (item.diff.action === 'removed' ? item.diff.fromValue && item.diff.fromValue._key === child._key : (item.diff.toValue && item.diff.toValue._key) === child._key));

  if (candidate) {
    return candidate.diff;
  }

  return undefined;
}

function findAnnotationDiff(diff, markDefKey) {
  var _diff$fields$markDefs;

  return diff.fields.markDefs && diff.fields.markDefs.isChanged && diff.fields.markDefs.type === 'array' && ((_diff$fields$markDefs = diff.fields.markDefs.items.find(item => item.diff && item.diff.type === 'object' && (item.diff.toValue && item.diff.toValue._key && item.diff.toValue._key === markDefKey || item.diff.fromValue && item.diff.fromValue._key && item.diff.fromValue._key === markDefKey))) === null || _diff$fields$markDefs === void 0 ? void 0 : _diff$fields$markDefs.diff) || undefined;
}

function isEmptyObject(object) {
  return object && (0, _isEqual2.default)(Object.keys(object), ['_key', '_type']) || false;
}

function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

function getAllMarkDefs(diff) {
  var allDefs = [...(diff.toValue && diff.toValue.markDefs ? diff.toValue.markDefs : [])];
  var oldDefs = diff.fromValue && diff.fromValue.markDefs ? diff.fromValue.markDefs : [];
  oldDefs.forEach(oDef => {
    if (!allDefs.some(def => oDef._key === def._key)) {
      allDefs.push(oDef);
    }
  });
  return (0, _orderBy2.default)(allDefs, ['_key'], ['asc']);
}