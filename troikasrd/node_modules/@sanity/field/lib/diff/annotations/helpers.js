"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAnnotationColor = getAnnotationColor;
exports.getAnnotationAtPath = getAnnotationAtPath;
exports.getDiffAtPath = getDiffAtPath;
exports.visitDiff = visitDiff;

var _types = require("@sanity/types");

var _helpers = require("../../paths/helpers");

function getAnnotationColor(colorManager, annotation) {
  return colorManager.get((annotation === null || annotation === void 0 ? void 0 : annotation.author) || null);
}

function getAnnotationAtPath(diff, diffPath) {
  var path = Array.isArray(diffPath) ? diffPath : (0, _helpers.stringToPath)(diffPath);
  return getAnnotationAt(diff, path);
}

function getDiffAtPath(diff, diffPath) {
  var path = Array.isArray(diffPath) ? diffPath : (0, _helpers.stringToPath)(diffPath);
  return getDiffAt(diff, path);
}

function getAnnotationAt(diff, path) {
  var diffAt = getDiffAt(diff, path);

  if (!diffAt) {
    return undefined;
  }

  if (diffAt.action === 'unchanged') {
    return undefined;
  }

  return diffAt.annotation || undefined;
} // eslint-disable-next-line complexity


function getDiffAt(diff, path) {
  var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (path.length === 0) {
    return diff;
  }

  var segment = path[0];
  var tail = path.slice(1);

  if ((0, _types.isIndexTuple)(segment)) {
    throw new Error('Index tuples are not supported in diff paths');
  }

  if ((0, _types.isIndexSegment)(segment) || (0, _types.isKeySegment)(segment)) {
    var location = (0, _types.isIndexSegment)(segment) ? "at index ".concat(segment) : "with key ".concat(segment._key);

    if (diff.type !== 'array') {
      warn("Failed to get item ".concat(location, " at path ").concat((0, _helpers.pathToString)(parentPath), " (not an array)"));
      return undefined;
    }

    var itemDiff = diff.items.find((0, _types.isIndexSegment)(segment) ? item => item.toIndex === segment : item => itemMatchesKey(item, segment));

    if (!itemDiff) {
      warn("Failed to get item ".concat(location, " at path ").concat((0, _helpers.pathToString)(parentPath), " (item missing)"));
      return undefined;
    }

    return getDiffAt(itemDiff.diff, tail, parentPath.concat(segment));
  }

  if (diff.type !== 'object') {
    warn("Failed to get property ".concat(segment, " at path ").concat((0, _helpers.pathToString)(parentPath), " (not an object)"));
    return undefined;
  }

  var fieldDiff = diff.fields[segment];

  if (typeof fieldDiff === 'undefined') {
    warn("Failed to get property ".concat(segment, " at path ").concat((0, _helpers.pathToString)(parentPath), " (field did not exist)"));
    return undefined;
  }

  return getDiffAt(fieldDiff, tail, parentPath.concat(segment));
}
/* eslint-disable no-console, @typescript-eslint/no-unused-vars */


function warn(msg) {//console.warn(msg)
}
/* eslint-enable no-console, @typescript-eslint/no-unused-vars */


function itemMatchesKey(item, key) {
  var itemDiff = item.diff;
  return itemDiff.type !== 'object' || !itemDiff.toValue ? false : itemDiff.toValue._key === key;
}

/**
 * Visit all diffs in tree, until visitor returns false
 *
 * @param diff Diff to visit
 * @param visitor Visitor function, return false to stop from going deeper
 */
function visitDiff(diff, visitor) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (!visitor(diff, path)) {
    return;
  }

  if (diff.type === 'array') {
    visitArrayDiff(diff, visitor, path);
    return;
  }

  if (diff.type === 'object') {
    visitObjectDiff(diff, visitor, path);
    return;
  }

  if (diff.type === 'string') {
    visitStringDiff(diff, visitor, path);
  }
}

function visitArrayDiff(diff, visitor, path) {
  if (diff.action === 'unchanged') {
    return;
  }

  diff.items.forEach(itemDiff => {
    var _itemDiff$diff$toValu;

    var _key = itemDiff.diff.type === 'object' && ((_itemDiff$diff$toValu = itemDiff.diff.toValue) === null || _itemDiff$diff$toValu === void 0 ? void 0 : _itemDiff$diff$toValu._key);

    var segment = _key ? {
      _key
    } : getItemDiffIndex(itemDiff);
    visitDiff(itemDiff.diff, visitor, path.concat(segment));
  });
}

function visitObjectDiff(diff, visitor, path) {
  if (diff.action === 'unchanged') {
    return;
  }

  Object.keys(diff.fields).forEach(fieldName => {
    var fieldDiff = diff.fields[fieldName];
    visitDiff(fieldDiff, visitor, path.concat(fieldName));
  });
}

function visitStringDiff(diff, visitor, path) {
  if (diff.action === 'unchanged') {
    return;
  }

  diff.segments.forEach(segment => {
    visitDiff(segment, visitor, path);
  });
}

function getItemDiffIndex(itemDiff) {
  return typeof itemDiff.toIndex === 'undefined' ? itemDiff.fromIndex || 0 : itemDiff.toIndex;
}