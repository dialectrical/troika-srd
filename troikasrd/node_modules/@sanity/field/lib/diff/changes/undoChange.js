"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.undoChange = undoChange;

var _types = require("@sanity/types");

var _sanityDiffPatch = require("sanity-diff-patch");

var _paths = require("../../paths");

var _helpers = require("./helpers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var diffOptions = {
  diffMatchPatch: {
    enabled: false
  }
};

function undoChange(change, rootDiff, documentOperations) {
  if (!rootDiff) {
    return;
  }

  var patches = [];

  if (change.type === 'group') {
    var allChanges = (0, _helpers.flattenChangeNode)(change);
    var unsetChanges = allChanges.filter(_helpers.isAddedAction);
    allChanges.filter(child => !(0, _helpers.isAddedAction)(child)).forEach(child => undoChange(child, rootDiff, documentOperations));
    patches.push(...buildUnsetPatches(rootDiff, unsetChanges.map(unsetChange => unsetChange.path)));
  } else if (change.diff.action === 'added') {
    // The reverse of an add operation is an unset -
    // so we don't need to worry about moved items in this case
    patches.push(...buildUnsetPatches(rootDiff, [change.path]));
  } else if (change.type === 'field' && change.itemDiff && change.parentDiff && change.parentDiff.type === 'array' && change.itemDiff.hasMoved) {
    // If an array item has moved, we need to unset + insert it again
    // (we lack a "move" patch currently)
    patches.push(...buildMovePatches(change.itemDiff, change.parentDiff, change.path));
  } else {
    // For all other operations, try to find the most optimal case
    patches.push(...buildUndoPatches(change.diff, rootDiff, change.path));
  }

  documentOperations.patch.execute(patches);
}

function buildUnsetPatch(rootDiff, path, concurrentUnsetPaths) {
  var previousValue = rootDiff.toValue;
  return furthestEmptyAncestor(previousValue, path, concurrentUnsetPaths);
}

function buildUnsetPatches(rootDiff, paths) {
  var patches = [];

  var _loop = function _loop(i) {
    var unsetByEarlierPatch = patches.some(patch => (0, _helpers.isSubpathOf)(paths[i], patch));

    if (unsetByEarlierPatch) {
      return "continue";
    }

    patches.push(buildUnsetPatch(rootDiff, paths[i], paths));
  };

  for (var i = 0; i < paths.length; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }

  return [{
    unset: [...new Set(patches.map(_paths.pathToString))]
  }];
}
/**
 * Find the path to the furthest empty ancestor that's also a stub.
 *
 * Used for removing all stubs when unsetting a nested value.
 *
 * @param previousValue The state of the tree before the change was made.
 * @param currentPath Path of the value to unset. Used for recursing.
 * @param ignorePaths An optional list of path to forcefully mark as
 *  a stub regardless of what it actually is.
 * @param initialPath Same as the first value of currentPath.
 */


function furthestEmptyAncestor(previousValue, currentPath) {
  var ignorePaths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var initialPath = arguments.length > 3 ? arguments[3] : undefined;

  if (currentPath.length <= 0) {
    /*
     * This means we are at root and no ancestors are stubs. We
     * can therefore safely unset only the actual value.
     */
    if (!initialPath) {
      /*
       * Will happen if the function is started with `currentPath = []`.
       */
      throw new Error('Root has no ancestor');
    }

    return initialPath;
  }

  var ancestorPath = currentPath.slice(0, -1);
  var ancestorValue = (0, _paths.getValueAtPath)(previousValue, ancestorPath);
  /*
   * If the ancestor also is a stub we can add it to the ignore-list
   * so it'll be "remembered" as a stub without us having to scan
   * the whole tree again.
   */

  var updatedIgnorePaths = [ancestorPath,
  /*
   * We can filter out all the subpaths from under this ancestor
   * because since we ignore it higher up in the tree it doesn't
   * matter anymore what the values of subpaths are.
   */
  ...ignorePaths.filter(path => !(0, _helpers.isSubpathOf)(path, ancestorPath))];
  return isStub(ancestorValue, ancestorPath, ignorePaths) ? furthestEmptyAncestor(previousValue, ancestorPath, updatedIgnorePaths, initialPath) : currentPath;
}

function buildMovePatches(itemDiff, parentDiff, path) {
  var basePath = path.slice(0, -1);

  var _getFromItem = getFromItem(parentDiff, itemDiff),
      parentValue = _getFromItem.parentValue,
      fromIndex = _getFromItem.fromIndex,
      fromValue = _getFromItem.fromValue;

  var insertLocation;

  if (fromIndex === 0) {
    // If it was moved from the beginning, we can use a simple prepend
    insertLocation = {
      before: (0, _paths.pathToString)([...basePath, 0])
    };
  } else {
    // Try to use item key segments where possible, falling back to array indexes
    var prevIndex = fromIndex - 1;
    var prevItemKey = (0, _paths.getItemKeySegment)(parentValue[prevIndex]);
    var prevSegment = prevItemKey || prevIndex;
    insertLocation = {
      after: (0, _paths.pathToString)([...basePath, prevSegment])
    };
  }

  return [{
    unset: [(0, _paths.pathToString)(path)]
  }, {
    insert: _objectSpread(_objectSpread({}, insertLocation), {}, {
      items: [fromValue]
    })
  }];
}

function buildUndoPatches(diff, rootDiff, path) {
  var patches = (0, _sanityDiffPatch.diffItem)(diff.toValue, diff.fromValue, diffOptions, path);
  var inserts = patches.filter(patch => patch.op === 'insert').map(_ref => {
    var after = _ref.after,
        items = _ref.items;
    return {
      insert: {
        after: (0, _paths.pathToString)(after),
        items
      }
    };
  });
  var unsets = patches.filter(patch => patch.op === 'unset').reduce((acc, patch) => acc.concat((0, _paths.pathToString)(patch.path)), []);
  var stubbedPaths = new Set();
  var stubs = [];
  var hasSets = false;
  var sets = patches.filter(patch => patch.op === 'set').reduce((acc, patch) => {
    hasSets = true;
    stubs.push(...getParentStubs(patch.path, rootDiff, stubbedPaths));
    acc[(0, _paths.pathToString)(patch.path)] = patch.value;
    return acc;
  }, {});
  return [...stubs, ...inserts, ...(unsets.length > 0 ? [{
    unset: unsets
  }] : []), ...(hasSets ? [{
    set: sets
  }] : [])];
}

function getParentStubs(path, rootDiff, stubbed) {
  var value = rootDiff.fromValue;
  var nextValue = rootDiff.toValue;
  var stubs = [];

  for (var i = 1; i <= path.length; i++) {
    var subPath = path.slice(0, i);
    var pathStr = (0, _paths.pathToString)(subPath);

    if (stubbed.has(pathStr)) {
      continue;
    }

    var nextSegment = path[i];
    var nextIsArrayElement = (0, _types.isKeySegment)(nextSegment) || (0, _types.isIndexSegment)(nextSegment);
    var itemValue = (0, _paths.getValueAtPath)(value, subPath);
    var stub = getStubValue(itemValue); // If the next array element does not exist, we need to inject an insert stub here

    if (nextIsArrayElement && Array.isArray(itemValue) && !(0, _paths.getValueAtPath)(nextValue, path.slice(0, i + 1))) {
      var indexAtPrev = (0, _paths.findIndex)(itemValue, nextSegment);
      var prevItem = itemValue[indexAtPrev - 1];
      var nextItem = (0, _paths.getValueAtPath)(value, subPath.concat(nextSegment));
      var prevSeg = (0, _types.isKeyedObject)(prevItem) ? {
        _key: prevItem._key
      } : indexAtPrev - 1;
      var after = (0, _paths.pathToString)(subPath.concat(indexAtPrev < 1 ? 0 : prevSeg));
      stubs.push({
        setIfMissing: {
          [pathStr]: []
        }
      });
      stubs.push({
        insert: {
          after,
          items: [getStubValue(nextItem)]
        }
      });
      i++;
      continue;
    }

    if (typeof stub === 'undefined') {
      continue;
    }

    stubbed.add(pathStr);
    stubs.push({
      setIfMissing: {
        [pathStr]: stub
      }
    });
  }

  return stubs;
}
/**
 * Check if all items in an object or an array are stubs.
 *
 * @param item The item to check whether is a stub.
 * @param path The path to the item we're checking.
 * @param ignorePaths An optional list of path to forcefully mark as
 *  a stub regardless of what it actually is.
 */


function onlyContainsStubs(item, path, ignorePaths) {
  /*
   * If we're trying to check for stubs inside something which isn't an object
   * or an array we're checking a string for example and it they cannot
   * contain stubs.
   */
  if (typeof item != 'object' && !Array.isArray(item)) {
    return false;
  }

  for (var child in item) {
    if (!Object.prototype.hasOwnProperty.call(item, child)) {
      continue;
    }
    /*
     * _type or _key field alone doesn't affect whether the field is a stub or
     * not.
     */


    if (child === '_type' || child === '_key') {
      continue;
    }

    var nextPath = [...path, (0, _helpers.pathSegmentOfCorrectType)(item, child)];

    if (!isStub(item[child], nextPath, ignorePaths)) {
      return false;
    }
  }

  return true;
}

function isStub(item, path, ignorePaths) {
  var isIgnoredPath = Array.isArray(ignorePaths) && ignorePaths.some(ignorePath => (0, _paths.pathToString)(ignorePath) === (0, _paths.pathToString)(path));
  var isEmptyArray = Array.isArray(item) && item.length <= 0;
  return isIgnoredPath || item === undefined || item === null || isEmptyArray || (0, _paths.isEmptyObject)(item) || onlyContainsStubs(item, path, ignorePaths);
}

function getStubValue(item) {
  if (Array.isArray(item)) {
    return [];
  }

  if (typeof item !== 'object' || item === null) {
    return undefined;
  }

  var props = {};

  if ((0, _types.isKeyedObject)(item)) {
    props._key = item._key;
  }

  if ((0, _types.isTypedObject)(item)) {
    props._type = item._type;
  }

  return props;
}

function getFromItem(parentDiff, itemDiff) {
  if (parentDiff.fromValue && typeof itemDiff.fromIndex === 'number') {
    var fromValue = parentDiff.fromValue[itemDiff.fromIndex];
    return {
      parentValue: parentDiff.fromValue,
      fromIndex: itemDiff.fromIndex,
      fromValue
    };
  } // Shouldn't ever happen


  throw new Error("Failed to find item at index ".concat(itemDiff.fromIndex));
}