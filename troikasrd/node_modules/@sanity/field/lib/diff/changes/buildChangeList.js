"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildChangeList = buildChangeList;
exports.buildObjectChangeList = buildObjectChangeList;
exports.buildFieldChange = buildFieldChange;
exports.buildFieldsetChangeList = buildFieldsetChangeList;
exports.buildArrayChangeList = buildArrayChangeList;

var _paths = require("../../paths");

var _validation = require("../../validation");

var _helpers = require("../../schema/helpers");

var _helpers2 = require("../../types/portableText/diff/helpers");

var _resolveDiffComponent = require("../resolve/resolveDiffComponent");

var _helpers3 = require("../helpers");

var _excluded = ["fieldFilter"],
    _excluded2 = ["fieldFilter"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function buildChangeList(schemaType, diff) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var titlePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var context = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var diffComponent = (0, _resolveDiffComponent.resolveDiffComponent)(schemaType, context.parentSchema);

  if (!diffComponent) {
    if (schemaType.jsonType === 'object' && diff.type === 'object') {
      return buildObjectChangeList(schemaType, diff, path, titlePath, context);
    }

    if (schemaType.jsonType === 'array' && diff.type === 'array') {
      return buildArrayChangeList(schemaType, diff, path, titlePath);
    }
  }

  return getFieldChange(schemaType, diff, path, titlePath, context);
}

function buildObjectChangeList(schemaType, diff) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var titlePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var diffContext = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var changes = [];

  var childContext = _objectSpread(_objectSpread({}, diffContext), {}, {
    parentSchema: schemaType
  });

  var fieldSets = schemaType.fieldsets || schemaType.fields.map(field => ({
    single: true,
    field
  }));

  var _iterator = _createForOfIteratorHelper(fieldSets),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var fieldSet = _step.value;

      if (fieldSet.single) {
        changes.push(...buildFieldChange(fieldSet.field, diff, path, titlePath, childContext));
      } else {
        changes.push(...buildFieldsetChangeList(fieldSet, diff, path, titlePath, childContext));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (changes.length < 2) {
    return changes;
  }

  return [{
    type: 'group',
    key: (0, _paths.pathToString)(path) || 'root',
    path,
    titlePath,
    changes: reduceTitlePaths(changes, titlePath.length),
    schemaType
  }];
}

function buildFieldChange(field, diff, path, titlePath) {
  var diffContext = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var fieldFilter = diffContext.fieldFilter,
      context = _objectWithoutProperties(diffContext, _excluded);

  var fieldDiff = diff.fields[field.name];

  if (!fieldDiff || !fieldDiff.isChanged || fieldFilter && !fieldFilter.includes(field.name)) {
    return [];
  }

  var fieldPath = path.concat([field.name]);
  var fieldTitlePath = titlePath.concat([field.type.title || field.name]);
  return buildChangeList(field.type, fieldDiff, fieldPath, fieldTitlePath, context);
}

function buildFieldsetChangeList(fieldSet, diff, path, titlePath) {
  var diffContext = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var fields = fieldSet.fields,
      name = fieldSet.name,
      title = fieldSet.title;

  var fieldFilter = diffContext.fieldFilter,
      context = _objectWithoutProperties(diffContext, _excluded2);

  var fieldSetTitlePath = titlePath.concat([title || name]);
  var changes = [];

  var _iterator2 = _createForOfIteratorHelper(fields),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var field = _step2.value;
      var fieldDiff = diff.fields[field.name];

      if (!fieldDiff || !fieldDiff.isChanged || fieldFilter && !fieldFilter.includes(field.name)) {
        continue;
      }

      var fieldPath = path.concat([field.name]);
      var fieldTitlePath = fieldSetTitlePath.concat([field.type.title || field.name]);
      changes.push(...buildChangeList(field.type, fieldDiff, fieldPath, fieldTitlePath, context));
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  if (changes.length < 2) {
    return changes;
  }

  return [{
    type: 'group',
    key: (0, _paths.pathToString)(path) || 'root',
    path,
    titlePath: fieldSetTitlePath,
    changes: reduceTitlePaths(changes, fieldSetTitlePath.length)
  }];
}

function buildArrayChangeList(schemaType, diff) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var titlePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var changedOrMoved = diff.items.filter(item => item.hasMoved && item.fromIndex !== item.toIndex || item.diff.action !== 'unchanged');

  if (changedOrMoved.length === 0) {
    return [];
  }

  var isPortableText = (0, _helpers2.hasPTMemberType)(schemaType);
  var list = [];
  var changes = changedOrMoved.reduce((acc, itemDiff) => {
    var memberTypes = (0, _helpers.getArrayDiffItemType)(itemDiff.diff, schemaType);
    var memberType = memberTypes.toType || memberTypes.fromType;

    if (!memberType) {
      // eslint-disable-next-line no-console
      console.warn('Could not determine schema type for item at %s', (0, _paths.pathToString)(path));
      return acc;
    }

    var segment = (0, _paths.getItemKeySegment)(itemDiff.diff.fromValue) || (0, _paths.getItemKeySegment)(itemDiff.diff.toValue) || diff.items.indexOf(itemDiff);
    var itemPath = path.concat(segment);
    var itemContext = {
      itemDiff,
      parentDiff: diff,
      parentSchema: schemaType
    };
    var itemTitlePath = titlePath.concat({
      hasMoved: itemDiff.hasMoved,
      toIndex: itemDiff.toIndex,
      fromIndex: itemDiff.fromIndex,
      annotation: itemDiff.diff.action === 'unchanged' ? itemDiff.annotation : itemDiff.diff.annotation
    });

    var attachItemDiff = change => {
      if (change.type === 'field' && (0, _paths.pathsAreEqual)(itemPath, change.path)) {
        change.itemDiff = itemDiff;
      }

      return change;
    };

    var children = buildChangeList(memberType, itemDiff.diff, itemPath, itemTitlePath, itemContext).map(attachItemDiff);

    if (isPortableText) {
      children.filter(_helpers3.isFieldChange).forEach((field, index, siblings) => {
        field.showHeader = siblings.length === 1;
        field.showIndex = itemDiff.fromIndex !== itemDiff.toIndex && itemDiff.hasMoved;
      });
    }

    if (children.length === 0) {
      // This can happen when there are no changes to the actual element, it's just been moved
      acc.push(...getFieldChange(memberType, itemDiff.diff, itemPath, itemTitlePath, itemContext));
    } else {
      acc.push(...children);
    }

    return acc;
  }, list);

  if (changes.length > 1) {
    return [{
      type: 'group',
      key: (0, _paths.pathToString)(path) || 'root',
      path,
      titlePath,
      changes: reduceTitlePaths(changes, titlePath.length),
      schemaType
    }];
  }

  return changes;
}

function getFieldChange(schemaType, diff, path, titlePath) {
  var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
      itemDiff = _ref.itemDiff,
      parentDiff = _ref.parentDiff,
      parentSchema = _ref.parentSchema;

  var fromValue = diff.fromValue,
      toValue = diff.toValue,
      type = diff.type; // Treat undefined => [] as no change

  if (type === 'array' && isEmpty(fromValue) && isEmpty(toValue)) {
    return [];
  }

  var error;

  if (typeof fromValue !== 'undefined') {
    error = (0, _validation.getValueError)(fromValue, schemaType);
  }

  if (!error && typeof toValue !== 'undefined') {
    error = (0, _validation.getValueError)(toValue, schemaType);
  }

  var showHeader = true;
  var component;
  var diffComponent = (0, _resolveDiffComponent.resolveDiffComponent)(schemaType, parentSchema);

  if (diffComponent && typeof diffComponent === 'function') {
    // Just a diff component with default options
    component = diffComponent;
  } else if (diffComponent) {
    // Diff component with options
    component = diffComponent.component;
    showHeader = typeof diffComponent.showHeader === 'undefined' ? showHeader : diffComponent.showHeader;
  }

  return [{
    type: 'field',
    diff,
    path,
    error,
    itemDiff,
    parentDiff,
    titlePath,
    schemaType,
    showHeader,
    showIndex: true,
    key: (0, _paths.pathToString)(path) || 'root',
    diffComponent: error ? undefined : component,
    parentSchema
  }];
}

function reduceTitlePaths(changes) {
  var byLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return changes.map(change => {
    change.titlePath = change.titlePath.slice(byLength);
    return change;
  });
}

function isEmpty(item) {
  return Array.isArray(item) && item.length === 0 || item === null || typeof item === 'undefined';
}