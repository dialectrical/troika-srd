/// <reference types="react" />
import { Path } from '@sanity/types';
import { Subject, Observable } from 'rxjs';
import { Node as SlateNode, Operation as SlateOperation, Editor as SlateEditor } from 'slate';
import type { Patch } from '../types/patch';
import { Type } from '../types/schema';
import { PortableTextBlock, PortableTextChild } from '../types/portableText';
export interface EditableAPI {
    activeAnnotations: () => PortableTextBlock[];
    addAnnotation: (type: Type, value?: {
        [prop: string]: any;
    }) => {
        spanPath: Path;
        markDefPath: Path;
    } | undefined;
    blur: () => void;
    delete: (selection?: EditorSelection, options?: {
        mode?: 'block' | 'children';
    }) => void;
    findByPath: (path: Path) => [PortableTextBlock | PortableTextChild | undefined, Path | undefined];
    findDOMNode: (element: PortableTextBlock | PortableTextChild) => Node | undefined;
    focus: () => void;
    focusBlock: () => PortableTextBlock | undefined;
    focusChild: () => PortableTextChild | undefined;
    getSelection: () => EditorSelection | undefined;
    getValue: () => PortableTextBlock[] | undefined;
    hasBlockStyle: (style: string) => boolean;
    hasListStyle: (listStyle: string) => boolean;
    insertBlock: (type: Type, value?: {
        [prop: string]: any;
    }) => Path;
    insertChild: (type: Type, value?: {
        [prop: string]: any;
    }) => Path;
    isCollapsedSelection: () => boolean;
    isExpandedSelection: () => boolean;
    isMarkActive: (mark: string) => boolean;
    isVoid: (element: PortableTextBlock | PortableTextChild) => boolean;
    marks: () => string[];
    redo: () => void;
    removeAnnotation: (type: Type) => void;
    select: (selection: EditorSelection) => void;
    toggleBlockStyle: (blockStyle: string) => void;
    toggleList: (listStyle: string) => void;
    toggleMark: (mark: string) => void;
    undo: () => void;
}
export declare type EditorNode = SlateNode & {
    _key: string;
    _type: string;
};
export declare type HistoryItem = {
    operations: SlateOperation[];
    timestamp: Date;
};
export interface History {
    redos: HistoryItem[];
    undos: HistoryItem[];
}
export declare type EditorSelectionPoint = {
    path: Path;
    offset: number;
};
export declare type EditorSelection = {
    anchor: EditorSelectionPoint;
    focus: EditorSelectionPoint;
} | null;
export interface PortableTextSlateEditor extends SlateEditor {
    editable: EditableAPI;
    history: History;
    /**
     * Increments selected list items levels, or decrements them if @reverse is true.
     *
     * @param {boolean} reverse
     * @returns {boolean} True if anything was incremented in the selection
     */
    pteIncrementBlockLevels: (reverse?: boolean) => boolean;
    /**
     * Toggle blocks as listItem
     *
     * @param {string} listStyle
     */
    pteToggleListItem: (listStyle: string) => void;
    /**
     * Set block as listItem
     *
     * @param {string} listStyle
     */
    pteSetListItem: (listStyle: string) => void;
    /**
     * Unset block as listItem
     *
     * @param {string} listStyle
     */
    pteUnsetListItem: (listStyle: string) => void;
    /**
     * Ends a list
     *
     * @returns {boolean} True if a list was ended in the selection
     */
    pteEndList: () => boolean;
    /**
     * Toggle marks in the selection
     *
     * @param {string} mark
     */
    pteToggleMark: (mark: string) => void;
    /**
     * Teset if a mark is active in the current selection
     *
     * @param {string} mark
     */
    pteIsMarkActive: (mark: string) => boolean;
    /**
     * Toggle the selected block style
     *
     * @param {string} style The style name
     *
     */
    pteToggleBlockStyle: (style: string) => void;
    /**
     * Test if the current selection has a certain block style
     *
     * @param {string} style The style name
     *
     */
    pteHasBlockStyle: (style: string) => boolean;
    /**
     * Test if the current selection has a certain list style
     *
     * @param {string} listStyle The liststyle name
     *
     */
    pteHasListStyle: (style: string) => boolean;
    /**
     * Try to expand the current selection to a word
     *
     */
    pteExpandToWord: () => void;
    /**
     * Use hotkeys
     *
     */
    pteWithHotKeys: (event: React.KeyboardEvent<HTMLDivElement>) => void;
    /**
     * Undo
     *
     */
    undo: () => void;
    /**
     * Redo
     *
     */
    redo: () => void;
}
export declare type MutationChange = {
    type: 'mutation';
    patches: Patch[];
};
export declare type PatchChange = {
    type: 'patch';
    patch: Patch;
};
export declare type ValueChange = {
    type: 'value';
    value: PortableTextBlock[] | undefined;
};
export declare type SelectionChange = {
    type: 'selection';
    selection: EditorSelection;
};
export declare type ThrottleChange = {
    type: 'throttle';
    throttle: boolean;
};
export declare type FocusChange = {
    type: 'focus';
};
export declare type UnsetChange = {
    type: 'unset';
    previousValue: PortableTextBlock[];
};
export declare type BlurChange = {
    type: 'blur';
};
export declare type LoadingChange = {
    type: 'loading';
    isLoading: boolean;
};
export declare type ReadyChange = {
    type: 'ready';
};
export declare type ErrorChange = {
    type: 'error';
    name: string;
    level: 'warning' | 'error';
    description: string;
    data?: any;
};
export declare type InvalidValueResolution = null | {
    patches: Patch[];
    description: string;
    action: string;
    item: PortableTextBlock[] | PortableTextBlock | PortableTextChild | undefined;
};
export declare type InvalidValue = {
    type: 'invalidValue';
    resolution: InvalidValueResolution;
    value: PortableTextBlock[];
};
export declare type UndoChange = {
    type: 'undo';
    patches: Patch[];
    timestamp: Date;
};
export declare type RedoChange = {
    type: 'redo';
    patches: Patch[];
    timestamp: Date;
};
export declare type EditorChange = BlurChange | ErrorChange | FocusChange | InvalidValue | LoadingChange | MutationChange | PatchChange | ReadyChange | RedoChange | SelectionChange | ThrottleChange | UndoChange | UnsetChange | ValueChange;
export declare type EditorChanges = Subject<EditorChange>;
export declare type OnPasteResult = {
    insert?: PortableTextBlock[];
    path?: Path;
} | Error;
export declare type OnPasteResultOrPromise = OnPasteResult | Promise<OnPasteResult>;
export declare type OnPasteFn = (arg0: {
    event: React.SyntheticEvent;
    path: Path;
    type: Type;
    value: PortableTextBlock[] | undefined;
}) => OnPasteResultOrPromise;
export declare type OnBeforeInputFn = (event: Event) => void;
export declare type OnCopyFn = (event: React.ClipboardEvent<HTMLDivElement | HTMLSpanElement>) => undefined | any;
export declare type PatchObservable = Observable<Patch>;
export declare type RenderAttributes = {
    focused: boolean;
    selected: boolean;
    path: Path;
    annotations?: PortableTextBlock[];
    style?: string;
    listItem?: string;
};
export declare type RenderBlockFunction = (value: PortableTextBlock, type: Type, attributes: RenderAttributes, defaultRender: (val: PortableTextBlock) => JSX.Element, ref: React.RefObject<HTMLDivElement>) => JSX.Element;
export declare type RenderChildFunction = (value: PortableTextChild, type: Type, attributes: RenderAttributes, defaultRender: (val: PortableTextChild) => JSX.Element, ref: React.RefObject<HTMLSpanElement>) => JSX.Element;
export declare type RenderAnnotationFunction = (value: PortableTextBlock, type: Type, attributes: RenderAttributes, defaultRender: () => JSX.Element, ref: React.RefObject<HTMLSpanElement>) => JSX.Element;
export declare type RenderDecoratorFunction = (value: string, type: {
    title: string;
}, attributes: RenderAttributes, defaultRender: () => JSX.Element, ref: React.RefObject<HTMLSpanElement>) => JSX.Element;
//# sourceMappingURL=editor.d.ts.map