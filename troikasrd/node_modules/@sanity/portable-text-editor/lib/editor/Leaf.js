"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Leaf = void 0;

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _react = _interopRequireWildcard(require("react"));

var _slate = require("slate");

var _slateReact = require("@sanity/slate-react");

var _debug = require("../utils/debug");

var _DefaultAnnotation = require("./nodes/DefaultAnnotation");

var _DraggableChild = require("./DraggableChild");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var debug = (0, _debug.debugWithName)('components:Leaf');
var debugRenders = false;

var Leaf = props => {
  var editor = (0, _slateReact.useEditor)();
  var selected = (0, _slateReact.useSelected)();
  var attributes = props.attributes,
      children = props.children,
      leaf = props.leaf,
      portableTextFeatures = props.portableTextFeatures,
      keyGenerator = props.keyGenerator,
      renderChild = props.renderChild;

  var spanRef = _react.default.useRef(null);

  var returnedChildren = children;
  var focused = selected && editor.selection && _slate.Range.isCollapsed(editor.selection) || false;
  var handleMouseDown = (0, _react.useCallback)(event => {
    // Slate will deselect this when it is already selected and clicked again, so prevent that. 2020/05/04
    if (focused) {
      event.stopPropagation();
      event.preventDefault();
    }
  }, [focused]);

  if (leaf._type === portableTextFeatures.types.span.name) {
    var blockElement = children.props.parent;
    var path = [{
      _key: blockElement._key
    }, 'children', {
      _key: leaf._key
    }];
    var decoratorValues = portableTextFeatures.decorators.map(dec => dec.value);
    var marks = (0, _uniq2.default)((Array.isArray(leaf.marks) ? leaf.marks : []).filter(mark => decoratorValues.includes(mark)));
    marks.forEach(mark => {
      var type = portableTextFeatures.decorators.find(dec => dec.value === mark);

      if (type) {
        var _type$blockEditor;

        // TODO: look into this API!
        if (type !== null && type !== void 0 && (_type$blockEditor = type.blockEditor) !== null && _type$blockEditor !== void 0 && _type$blockEditor.render) {
          var _type$blockEditor2;

          var CustomComponent = type === null || type === void 0 ? void 0 : (_type$blockEditor2 = type.blockEditor) === null || _type$blockEditor2 === void 0 ? void 0 : _type$blockEditor2.render;
          returnedChildren = /*#__PURE__*/_react.default.createElement(CustomComponent, {
            mark: mark
          }, returnedChildren);
        }

        if (props.renderDecorator) {
          returnedChildren = props.renderDecorator(mark, type, {
            focused,
            selected,
            path
          }, () => /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, returnedChildren), spanRef);
        }
      }
    });
    var annotations = (Array.isArray(leaf.marks) ? leaf.marks : []).map(mark => !decoratorValues.includes(mark) && blockElement && blockElement.markDefs && blockElement.markDefs.find(def => def._key === mark)).filter(Boolean);

    if (annotations.length > 0) {
      annotations.forEach(annotation => {
        var _type$blockEditor3;

        var type = portableTextFeatures.types.annotations.find(t => t.name === annotation._type); // TODO: look into this API!

        var CustomComponent = type === null || type === void 0 ? void 0 : (_type$blockEditor3 = type.blockEditor) === null || _type$blockEditor3 === void 0 ? void 0 : _type$blockEditor3.render;

        var defaultRender = () => // TODO: annotation should be an own prop here, keeping for backward compability (2020/05/18).
        CustomComponent ? /*#__PURE__*/_react.default.createElement(CustomComponent, _extends({}, annotation, {
          attributes: attributes
        }), returnedChildren) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, returnedChildren);

        if (type) {
          if (props.renderAnnotation) {
            returnedChildren = /*#__PURE__*/_react.default.createElement("span", {
              ref: spanRef,
              key: keyGenerator()
            }, props.renderAnnotation(annotation, type, {
              focused,
              selected,
              path,
              annotations
            }, defaultRender, spanRef));
          } else {
            returnedChildren = /*#__PURE__*/_react.default.createElement(_DefaultAnnotation.DefaultAnnotation, {
              annotation: annotation
            }, /*#__PURE__*/_react.default.createElement("span", {
              ref: spanRef,
              key: keyGenerator(),
              onMouseDown: handleMouseDown
            }, defaultRender()));
          }
        }
      });
    }

    if (renderChild) {
      var child = blockElement.children.find(_child => _child._key === leaf._key); // Ensure object equality

      returnedChildren = renderChild(child, portableTextFeatures.types.span, {
        focused,
        selected,
        path,
        annotations
      }, () => returnedChildren, spanRef);
    }
  }

  if (debugRenders) {
    debug("Render ".concat(leaf._key, " (span)"));
  }

  var key = leaf._key || keyGenerator(); // TODO: remove hightlight stuff as test for decorations

  return /*#__PURE__*/_react.default.createElement("span", _extends({}, attributes, {
    style: {
      backgroundColor: leaf.__highlight ? '#ff0' : 'inherit'
    },
    ref: spanRef,
    key: key
  }), /*#__PURE__*/_react.default.createElement(_DraggableChild.DraggableChild, {
    element: leaf,
    readOnly: props.readOnly,
    spanType: portableTextFeatures.types.span.name,
    keyGenerator: props.keyGenerator
  }, returnedChildren));
};

exports.Leaf = Leaf;