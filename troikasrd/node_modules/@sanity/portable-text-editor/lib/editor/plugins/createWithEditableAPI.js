"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWithEditableAPI = createWithEditableAPI;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _slate = require("slate");

var _slateReact = require("@sanity/slate-react");

var _values = require("../../utils/values");

var _selection = require("../../utils/selection");

var _debug = require("../../utils/debug");

var _weakMaps = require("../../utils/weakMaps");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var debug = (0, _debug.debugWithName)('API:editable');

function createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator) {
  return function withEditableAPI(editor) {
    var apply = editor.apply; // Convert the selection when the operation happens,
    // or we may be out of sync between selection and value

    editor.apply = operation => {
      apply(operation);
    };

    portableTextEditor.setEditable({
      focus: () => {
        _slateReact.ReactEditor.focus(editor);
      },
      blur: () => {
        _slateReact.ReactEditor.blur(editor);
      },
      toggleMark: mark => {
        editor.pteToggleMark(mark);

        _slateReact.ReactEditor.focus(editor);
      },
      toggleList: listStyle => {
        editor.pteToggleListItem(listStyle);

        _slateReact.ReactEditor.focus(editor);
      },
      toggleBlockStyle: blockStyle => {
        editor.pteToggleBlockStyle(blockStyle);

        _slateReact.ReactEditor.focus(editor);
      },
      isMarkActive: mark => {
        // Try/catch this, as Slate may error because the selection is currently wrong
        // TODO: catch only relevant error from Slate
        try {
          return editor.pteIsMarkActive(mark);
        } catch (err) {
          return false;
        }
      },
      marks: () => {
        return _objectSpread({}, _slate.Editor.marks(editor) || {}).marks || [];
      },
      undo: () => editor.undo(),
      redo: () => editor.redo(),
      select: selection => {
        var isEmpty = (0, _values.isEqualToEmptyEditor)(editor.children, portableTextFeatures); // TODO: check up on this

        if (isEmpty || selection === null) {
          debug('No value or selection is null, deselecting');

          _slate.Transforms.deselect(editor);

          return;
        }

        var slateSelection = (0, _selection.toSlateRange)(selection, editor);

        if (slateSelection) {
          var _Editor$node = _slate.Editor.node(editor, slateSelection),
              _Editor$node2 = _slicedToArray(_Editor$node, 1),
              node = _Editor$node2[0];

          if (_slate.Editor.isVoid(editor, node)) {
            _slate.Transforms.select(editor, slateSelection.focus.path.concat(0));
          } else {
            _slate.Transforms.select(editor, slateSelection);
          }

          _slateReact.ReactEditor.focus(editor);
        }
      },
      focusBlock: () => {
        if (editor.selection) {
          // Try/catch this, as Slate may error because the selection is currently wrong
          // TODO: catch only relevant error from Slate
          try {
            var _ref = Array.from(_slate.Editor.nodes(editor, {
              at: editor.selection.focus,
              match: n => _slate.Editor.isBlock(editor, n)
            }))[0] || [undefined],
                _ref2 = _slicedToArray(_ref, 1),
                block = _ref2[0];

            if (block) {
              return (0, _values.fromSlateValue)([block], portableTextFeatures.types.block.name, _weakMaps.KEY_TO_VALUE_ELEMENT.get(editor))[0];
            }
          } catch (err) {
            return undefined;
          }
        }

        return undefined;
      },
      focusChild: () => {
        if (editor.selection) {
          try {
            var _ref3 = Array.from(_slate.Editor.nodes(editor, {
              mode: 'lowest',
              at: editor.selection.focus,
              match: n => n._type !== undefined,
              voids: true
            }))[0] || [undefined],
                _ref4 = _slicedToArray(_ref3, 1),
                node = _ref4[0];

            if (node && !_slate.Editor.isBlock(editor, node)) {
              var pseudoBlock = {
                _key: 'pseudo',
                _type: portableTextFeatures.types.block.name,
                children: [node]
              };
              return (0, _values.fromSlateValue)([pseudoBlock], portableTextFeatures.types.block.name, _weakMaps.KEY_TO_VALUE_ELEMENT.get(editor))[0].children[0];
            }
          } catch (err) {
            return undefined;
          }
        }

        return undefined;
      },
      insertChild: (type, value) => {
        var _toPortableTextRange;

        if (!editor.selection) {
          throw new Error('The editor has no selection');
        }

        var _ref5 = Array.from(_slate.Editor.nodes(editor, {
          at: editor.selection.focus,
          match: n => _slate.Editor.isBlock(editor, n)
        }))[0] || [undefined],
            _ref6 = _slicedToArray(_ref5, 1),
            focusBlock = _ref6[0];

        if (!focusBlock) {
          throw new Error('No focus block');
        }

        if (focusBlock && _slate.Editor.isVoid(editor, focusBlock)) {
          throw new Error("Can't insert childs into block objects");
        }

        var block = (0, _values.toSlateValue)([{
          _key: keyGenerator(),
          _type: portableTextFeatures.types.block.name,
          children: [_objectSpread({
            _key: keyGenerator(),
            _type: type.name
          }, value ? value : {})]
        }], portableTextFeatures.types.block.name)[0];
        var child = block.children[0];

        _slate.Editor.insertNode(editor, child);

        editor.onChange();
        return ((_toPortableTextRange = (0, _selection.toPortableTextRange)(editor)) === null || _toPortableTextRange === void 0 ? void 0 : _toPortableTextRange.focus.path) || [];
      },
      insertBlock: (type, value) => {
        var _toPortableTextRange2;

        if (!editor.selection) {
          throw new Error('The editor has no selection');
        }

        var block = (0, _values.toSlateValue)([_objectSpread({
          _key: keyGenerator(),
          _type: type.name
        }, value ? value : {})], portableTextFeatures.types.block.name)[0];

        _slate.Editor.insertNode(editor, block);

        editor.onChange();
        return ((_toPortableTextRange2 = (0, _selection.toPortableTextRange)(editor)) === null || _toPortableTextRange2 === void 0 ? void 0 : _toPortableTextRange2.focus.path) || [];
      },
      hasBlockStyle: style => {
        try {
          return editor.pteHasBlockStyle(style);
        } catch (err) {
          // This is fine.
          // debug(err)
          return false;
        }
      },
      hasListStyle: listStyle => {
        try {
          return editor.pteHasListStyle(listStyle);
        } catch (err) {
          // This is fine.
          // debug(err)
          return false;
        }
      },
      isVoid: element => {
        return ![portableTextFeatures.types.block.name, portableTextFeatures.types.span.name].includes(element._type);
      },
      findByPath: path => {
        var slatePath = (0, _selection.toSlateRange)({
          focus: {
            path,
            offset: 0
          },
          anchor: {
            path,
            offset: 0
          }
        }, editor);

        if (slatePath) {
          var _Editor$node3 = _slate.Editor.node(editor, slatePath.focus.path.slice(0, 1)),
              _Editor$node4 = _slicedToArray(_Editor$node3, 2),
              block = _Editor$node4[0],
              blockPath = _Editor$node4[1];

          if (block && blockPath && typeof block._key === 'string') {
            if (path.length === 1 && slatePath.focus.path.length === 1) {
              return [(0, _values.fromSlateValue)([block], portableTextFeatures.types.block.name)[0], [{
                _key: block._key
              }]];
            }

            var ptBlock = (0, _values.fromSlateValue)([block], portableTextFeatures.types.block.name, _weakMaps.KEY_TO_VALUE_ELEMENT.get(editor))[0];
            var ptChild = ptBlock.children[slatePath.focus.path[1]];

            if (ptChild) {
              return [ptChild, [{
                _key: block._key
              }, 'children', {
                _key: ptChild._key
              }]];
            }
          }
        }

        return [undefined, undefined];
      },
      findDOMNode: element => {
        var node;

        try {
          var _ref7 = Array.from(_slate.Editor.nodes(editor, {
            at: [],
            match: n => n._key === element._key
          }) || [])[0] || [undefined],
              _ref8 = _slicedToArray(_ref7, 1),
              item = _ref8[0];

          node = _slateReact.ReactEditor.toDOMNode(editor, item);
        } catch (err) {// Nothing
        }

        return node;
      },
      activeAnnotations: () => {
        if (!editor.selection || editor.selection.focus.path.length < 2) {
          return [];
        }

        try {
          var _ret = function () {
            var activeAnnotations = [];

            var spans = _slate.Editor.nodes(editor, {
              at: editor.selection,
              match: node => _slate.Text.isText(node) && node.marks !== undefined && Array.isArray(node.marks) && node.marks.length > 0
            });

            var _iterator = _createForOfIteratorHelper(spans),
                _step;

            try {
              var _loop = function _loop() {
                var _step$value = _slicedToArray(_step.value, 2),
                    span = _step$value[0],
                    path = _step$value[1];

                var _Editor$node5 = _slate.Editor.node(editor, path, {
                  depth: 1
                }),
                    _Editor$node6 = _slicedToArray(_Editor$node5, 1),
                    block = _Editor$node6[0];

                if (block && Array.isArray(block.markDefs)) {
                  block.markDefs.forEach(def => {
                    if (span.marks && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                      activeAnnotations.push(def);
                    }
                  });
                }
              };

              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            return {
              v: activeAnnotations
            };
          }();

          if (typeof _ret === "object") return _ret.v;
        } catch (err) {
          return [];
        }
      },
      addAnnotation: (type, value) => {
        var selection = editor.selection;

        if (selection) {
          var _Editor$node7 = _slate.Editor.node(editor, selection.focus, {
            depth: 1
          }),
              _Editor$node8 = _slicedToArray(_Editor$node7, 1),
              blockElement = _Editor$node8[0];

          if (blockElement._type === portableTextFeatures.types.block.name) {
            var annotationKey = keyGenerator();

            if (Array.isArray(blockElement.markDefs)) {
              _slate.Transforms.setNodes(editor, {
                markDefs: [...blockElement.markDefs, _objectSpread({
                  _type: type.name,
                  _key: annotationKey
                }, value)]
              }, {
                at: selection.focus
              });

              if (_slate.Range.isCollapsed(selection)) {
                editor.pteExpandToWord();
              }

              var _Editor$node9 = _slate.Editor.node(editor, selection.focus, {
                depth: 2
              }),
                  _Editor$node10 = _slicedToArray(_Editor$node9, 1),
                  textNode = _Editor$node10[0];

              if (editor.selection) {
                _slate.Editor.withoutNormalizing(editor, () => {
                  // Split if needed
                  _slate.Transforms.setNodes(editor, {}, {
                    match: _slate.Text.isText,
                    split: true
                  });

                  if (editor.selection) {
                    _slate.Transforms.setNodes(editor, {
                      marks: [...(textNode.marks || []), annotationKey]
                    }, {
                      at: editor.selection,
                      match: n => n._type === portableTextFeatures.types.span.name
                    });
                  }
                });

                _slate.Editor.normalize(editor);

                editor.onChange();
                var newSelection = (0, _selection.toPortableTextRange)(editor); // eslint-disable-next-line max-depth

                if (newSelection && typeof blockElement._key === 'string') {
                  // Insert an empty string to continue writing non-annotated text
                  _slate.Editor.withoutNormalizing(editor, () => {
                    if (editor.selection) {
                      _slate.Transforms.insertNodes(editor, [{
                        _type: 'span',
                        text: '',
                        marks: [],
                        _key: keyGenerator()
                      }], {
                        at: _slate.Range.end(editor.selection)
                      });

                      editor.onChange();
                    }
                  });

                  return {
                    spanPath: newSelection.focus.path,
                    markDefPath: [{
                      _key: blockElement._key
                    }, 'markDefs', {
                      _key: annotationKey
                    }]
                  };
                }
              }
            }
          }
        }

        return undefined;
      },
      delete: (selection, options) => {
        if (selection) {
          var range = (0, _selection.toSlateRange)(selection, editor);

          if (range) {
            var ptMode = options && options.mode || undefined;
            var mode = 'highest';

            if (ptMode) {
              mode = ptMode === 'block' ? 'highest' : 'lowest';
            }

            _slate.Transforms.removeNodes(editor, {
              at: range,
              mode
            });
          }
        }
      },
      removeAnnotation: type => {
        var selection = editor.selection;
        var changed = false;

        if (selection) {
          // Select the whole annotation if collapsed
          if (_slate.Range.isCollapsed(selection)) {
            var _Editor$node11 = _slate.Editor.node(editor, selection, {
              depth: 2
            }),
                _Editor$node12 = _slicedToArray(_Editor$node11, 2),
                node = _Editor$node12[0],
                nodePath = _Editor$node12[1];

            if (node && node.marks && typeof node.text === 'string') {
              _slate.Transforms.select(editor, nodePath);

              selection = editor.selection;
            }
          }

          if (selection && _slate.Range.isExpanded(selection)) {
            // Split the span first
            _slate.Transforms.setNodes(editor, {}, {
              match: _slate.Text.isText,
              split: true
            });

            selection = editor.selection;

            if (!selection) {
              return;
            } // Everything in the selection which has marks


            var spans = _slate.Editor.nodes(editor, {
              at: selection,
              match: node => _slate.Text.isText(node) && node.marks !== undefined && Array.isArray(node.marks) && node.marks.length > 0
            });

            var _iterator2 = _createForOfIteratorHelper(spans),
                _step2;

            try {
              var _loop2 = function _loop2() {
                var _step2$value = _slicedToArray(_step2.value, 2),
                    span = _step2$value[0],
                    path = _step2$value[1];

                var _Editor$node13 = _slate.Editor.node(editor, path, {
                  depth: 1
                }),
                    _Editor$node14 = _slicedToArray(_Editor$node13, 1),
                    block = _Editor$node14[0];

                if (block && Array.isArray(block.markDefs)) {
                  // eslint-disable-next-line no-loop-func
                  block.markDefs.forEach(def => {
                    if (def._type === type.name && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key)) {
                      _slate.Transforms.setNodes(editor, {
                        marks: [...(span.marks || []).filter(mark => mark !== def._key)]
                      }, {
                        at: path,
                        voids: false,
                        split: false
                      });

                      changed = true;
                    }
                  });
                } // Merge similar adjecent spans


                if (changed) {
                  // eslint-disable-next-line max-depth
                  var _iterator3 = _createForOfIteratorHelper(Array.from(_slate.Editor.nodes(editor, {
                    at: _slate.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]]),
                    match: _slate.Text.isText
                  })).reverse()),
                      _step3;

                  try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                      var _step3$value = _slicedToArray(_step3.value, 1),
                          _node = _step3$value[0];

                      var _Editor$node15 = _slate.Editor.node(editor, _slate.Path.parent(path)),
                          _Editor$node16 = _slicedToArray(_Editor$node15, 1),
                          parent = _Editor$node16[0]; // eslint-disable-next-line max-depth


                      if (_slate.Editor.isBlock(editor, parent)) {
                        var nextPath = [path[0], path[1] + 1];
                        var nextTextNode = parent.children[nextPath[1]]; // eslint-disable-next-line max-depth

                        if (nextTextNode && typeof nextTextNode.text === 'string' && (0, _isEqual2.default)(nextTextNode.marks, _node.marks)) {
                          _slate.Transforms.mergeNodes(editor, {
                            at: nextPath,
                            voids: true
                          });
                        }
                      }
                    }
                  } catch (err) {
                    _iterator3.e(err);
                  } finally {
                    _iterator3.f();
                  }
                }
              };

              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                _loop2();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            if (changed) {
              editor.onChange();
            }
          }
        }
      },
      getSelection: () => {
        return (0, _selection.toPortableTextRange)(editor);
      },
      getValue: () => {
        return (0, _values.fromSlateValue)(editor.children, portableTextFeatures.types.block.name, _weakMaps.KEY_TO_VALUE_ELEMENT.get(editor));
      },
      isCollapsedSelection: () => {
        return !!editor.selection && _slate.Range.isCollapsed(editor.selection);
      },
      isExpandedSelection: () => {
        return !!editor.selection && _slate.Range.isExpanded(editor.selection);
      }
    });
    return editor;
  };
}