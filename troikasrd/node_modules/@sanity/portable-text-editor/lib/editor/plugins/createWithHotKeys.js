"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWithHotkeys = createWithHotkeys;

var _slate = require("slate");

var _isHotkey = _interopRequireDefault(require("is-hotkey"));

var _debug = require("../../utils/debug");

var _values = require("../../utils/values");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var debug = (0, _debug.debugWithName)('plugin:withHotKeys');
var DEFAULT_HOTKEYS = {
  marks: {
    'mod+b': 'strong',
    'mod+i': 'em',
    'mod+u': 'underline',
    "mod+'": 'code'
  },
  custom: {}
};
/**
 * This plugin takes care of all hotkeys in the editor
 * TODO: move a lot of these out the their respective plugins
 *
 */

function createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeysFromOptions) {
  var reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end'];
  var activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS; // TODO: Merge where possible? A union?

  return function withHotKeys(editor) {
    editor.pteWithHotKeys = event => {
      // Wire up custom marks hotkeys
      Object.keys(activeHotkeys).forEach(cat => {
        if (cat === 'marks') {
          // eslint-disable-next-line guard-for-in
          for (var hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey)) {
              throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
            }

            if ((0, _isHotkey.default)(hotkey, event.nativeEvent)) {
              event.preventDefault();
              var possibleMark = activeHotkeys[cat];

              if (possibleMark) {
                var mark = possibleMark[hotkey];
                debug("HotKey ".concat(hotkey, " to toggle ").concat(mark));
                editor.pteToggleMark(mark);
              }
            }
          }
        }

        if (cat === 'custom') {
          // eslint-disable-next-line guard-for-in
          for (var _hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(_hotkey)) {
              throw new Error("The hotkey ".concat(_hotkey, " is reserved!"));
            }

            if ((0, _isHotkey.default)(_hotkey, event.nativeEvent)) {
              var possibleCommand = activeHotkeys[cat];

              if (possibleCommand) {
                var command = possibleCommand[_hotkey];
                command(event, portableTextEditor);
              }
            }
          }
        }
      });
      var isEnter = (0, _isHotkey.default)('enter', event.nativeEvent);
      var isTab = (0, _isHotkey.default)('tab', event.nativeEvent);
      var isShiftEnter = (0, _isHotkey.default)('shift+enter', event.nativeEvent);
      var isShiftTab = (0, _isHotkey.default)('shift+tab', event.nativeEvent);
      var isBackspace = (0, _isHotkey.default)('backspace', event.nativeEvent);
      var isDelete = (0, _isHotkey.default)('delete', event.nativeEvent); // Handle inline objects delete and backspace (not implemented in Slate)
      // TODO: implement cut for inline objects (preferably in Slate)

      if ((isDelete || isBackspace) && editor.selection && _slate.Range.isCollapsed(editor.selection)) {
        var _Editor$node = _slate.Editor.node(editor, editor.selection.focus, {
          depth: 2
        }),
            _Editor$node2 = _slicedToArray(_Editor$node, 1),
            focusChild = _Editor$node2[0];

        if (_slate.Editor.isVoid(editor, focusChild) && _slate.Editor.isInline(editor, focusChild)) {
          _slate.Transforms.delete(editor, {
            at: editor.selection,
            voids: false,
            hanging: true
          });

          _slate.Transforms.collapse(editor);

          editor.onChange();
        }
      } // Disallow deleting void blocks by backspace from another line.
      // Otherwise it's so easy to delete the void block above when trying to delete text on
      // the line below or above


      if (isBackspace && editor.selection && editor.selection.focus.path[0] > 0 && _slate.Range.isCollapsed(editor.selection)) {
        var _Editor$node3 = _slate.Editor.node(editor, _slate.Path.previous(editor.selection.focus.path.slice(0, 1))),
            _Editor$node4 = _slicedToArray(_Editor$node3, 2),
            prevBlock = _Editor$node4[0],
            prevPath = _Editor$node4[1];

        var _Editor$node5 = _slate.Editor.node(editor, editor.selection.focus, {
          depth: 1
        }),
            _Editor$node6 = _slicedToArray(_Editor$node5, 1),
            focusBlock = _Editor$node6[0];

        if (prevBlock && focusBlock && _slate.Editor.isVoid(editor, prevBlock) && editor.selection.focus.offset === 0) {
          debug('Preventing deleting void block above');
          event.preventDefault();
          event.stopPropagation();

          _slate.Transforms.removeNodes(editor, {
            match: n => n === focusBlock
          });

          _slate.Transforms.select(editor, prevPath);

          editor.onChange();
          return;
        }
      }

      if (isDelete && editor.selection && editor.selection.focus.offset === 0 && _slate.Range.isCollapsed(editor.selection) && editor.children[editor.selection.focus.path[0] + 1]) {
        var _Editor$node7 = _slate.Editor.node(editor, _slate.Path.next(editor.selection.focus.path.slice(0, 1))),
            _Editor$node8 = _slicedToArray(_Editor$node7, 1),
            nextBlock = _Editor$node8[0];

        var _Editor$node9 = _slate.Editor.node(editor, editor.selection.focus, {
          depth: 1
        }),
            _Editor$node10 = _slicedToArray(_Editor$node9, 2),
            _focusBlock = _Editor$node10[0],
            focusBlockPath = _Editor$node10[1];

        if (nextBlock && _focusBlock && !_slate.Editor.isVoid(editor, _focusBlock) && _slate.Editor.isVoid(editor, nextBlock)) {
          debug('Preventing deleting void block below');
          event.preventDefault();
          event.stopPropagation();

          _slate.Transforms.removeNodes(editor, {
            match: n => n === _focusBlock
          });

          _slate.Transforms.select(editor, focusBlockPath);

          editor.onChange();
          return;
        }
      } // There's a bug in Slate atm regarding void nodes not being deleted if it is the last block.
      // Seems related to 'hanging: true'. 2020/05/26


      if ((isDelete || isBackspace) && editor.selection && _slate.Range.isExpanded(editor.selection)) {
        event.preventDefault();
        event.stopPropagation();

        _slate.Transforms.delete(editor, {
          at: editor.selection,
          voids: false,
          hanging: true
        });

        _slate.Transforms.collapse(editor);

        editor.onChange();
        return;
      } // Tab for lists


      if (isTab || isShiftTab) {
        if (editor.pteIncrementBlockLevels(isShiftTab)) {
          event.preventDefault();
        }
      } // Deal with enter key combos


      if (isEnter && !isShiftEnter && editor.selection) {
        var _focusBlock2;

        try {
          ;

          var _Editor$node11 = _slate.Editor.node(editor, editor.selection.focus, {
            depth: 1
          });

          var _Editor$node12 = _slicedToArray(_Editor$node11, 1);

          _focusBlock2 = _Editor$node12[0];
        } catch (err) {// Just ignore
        } // List item enter key


        if (_focusBlock2 && _focusBlock2.listItem) {
          if (editor.pteEndList()) {
            event.preventDefault();
          }

          return;
        } // Block object enter key


        if (_focusBlock2 && _slate.Editor.isVoid(editor, _focusBlock2)) {
          var block = (0, _values.toSlateValue)([{
            _type: portableTextFeatures.types.block.name,
            _key: keyGenerator(),
            style: 'normal',
            markDefs: [],
            children: [{
              _type: 'span',
              _key: keyGenerator(),
              text: '',
              marks: []
            }]
          }], portableTextFeatures.types.block.name)[0];

          _slate.Editor.insertNode(editor, block);

          event.preventDefault();
          return;
        }
      } // Soft line breaks


      if (isShiftEnter) {
        event.preventDefault();
        editor.insertText('\n');
        return;
      } // Undo/redo


      if ((0, _isHotkey.default)('mod+z', event.nativeEvent)) {
        event.preventDefault();
        editor.undo();
        return;
      }

      if ((0, _isHotkey.default)('mod+y', event.nativeEvent) || (0, _isHotkey.default)('mod+shift+z', event.nativeEvent)) {
        event.preventDefault();
        editor.redo();
      }
    };

    return editor;
  };
}