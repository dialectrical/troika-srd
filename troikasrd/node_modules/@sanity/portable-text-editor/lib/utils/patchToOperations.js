"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPatchToOperations = createPatchToOperations;

var _slate = require("slate");

var _values = require("./values");

var _debug = require("./debug");

var _weakMaps = require("./weakMaps");

var debug = (0, _debug.debugWithName)('operationToPatches');

function createPatchToOperations(portableTextFeatures) {
  function insertPatch(editor, patch) {
    if (patch.path.length === 1) {
      var items = patch.items,
          position = patch.position;
      var blocksToInsert = (0, _values.toSlateValue)(items, portableTextFeatures.types.block.name, _weakMaps.KEY_TO_SLATE_ELEMENT.get(editor));
      var posKey = findLastKey(patch.path);
      var index = editor.children.findIndex((node, indx) => {
        return posKey ? node._key === posKey : indx === patch.path[0];
      });
      var normalizedIdx = position === 'after' ? index + 1 : index;
      debug("Inserting blocks at path [".concat(normalizedIdx, "]"));

      _slate.Transforms.insertNodes(editor, blocksToInsert, {
        at: [normalizedIdx]
      });

      return true;
    }

    return false;
  }

  function unsetPatch(editor, patch) {
    // Deal with patches unsetting the whole field
    if (patch.path.length === 0) {
      debug("Removing everything");
      editor.children = [];
      return true;
    }

    if (patch.path.length === 1) {
      var lastKey = findLastKey(patch.path);
      var index = editor.children.findIndex((node, indx) => lastKey ? node._key === lastKey : indx === patch.path[0]);

      if (index > -1) {
        _slate.Transforms.removeNodes(editor, {
          at: [index]
        });

        debug("Removing block at path [".concat(index, "]"));
      }

      return true;
    }

    return false;
  }

  return function (editor, patch) {
    switch (patch.type) {
      case 'insert':
        return !!insertPatch(editor, patch);

      case 'unset':
        return !!unsetPatch(editor, patch);

      default:
        debug('Unhandled patch', patch.type);
    }

    return false;
  };
}

function isKeyedSegment(segment) {
  return typeof segment === 'object' && '_key' in segment;
} // Helper function to find the last part of a patch path that has a known key


function findLastKey(path) {
  var key = null;
  path.forEach(part => {
    if (isKeyedSegment(part)) {
      key = part._key;
    }
  });
  return key;
}