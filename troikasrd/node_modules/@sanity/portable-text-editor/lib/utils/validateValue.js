"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateValue = validateValue;

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _PatchEvent = require("../patch/PatchEvent");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function validateValue(value, portableTextFeatures, keyGenerator) {
  var resolution = null;
  var valid = true;
  var validChildTypes = [...[portableTextFeatures.types.span.name], ...portableTextFeatures.types.inlineObjects.map(t => t.name)];
  var validBlockTypes = [...[portableTextFeatures.types.block.name], ...portableTextFeatures.types.blockObjects.map(t => t.name)]; // Undefined is allowed

  if (value === undefined) {
    return {
      valid: true,
      resolution: null
    };
  } // Only lengthy arrays are allowed


  if (!Array.isArray(value) || value.length === 0) {
    return {
      valid: false,
      resolution: {
        patches: [(0, _PatchEvent.unset)([])],
        description: 'Value must be an array or undefined',
        action: 'Unset the value',
        item: value
      }
    };
  }

  if (value.some((blk, index) => {
    if (!(0, _isObject2.default)(blk)) {
      resolution = {
        patches: [(0, _PatchEvent.unset)([index])],
        description: "Block must be an object, got ".concat(String(blk)),
        action: "Unset invalid item",
        item: blk
      };
      return true;
    } // Test that every block has a _key


    if (!blk._key) {
      resolution = {
        patches: [(0, _PatchEvent.set)(_objectSpread(_objectSpread({}, blk), {}, {
          _key: keyGenerator()
        }), [index])],
        description: "Block at index ".concat(index, " is missing required _key."),
        action: 'Set the block with a random _key value',
        item: blk
      };
      return true;
    } // Test that every block has valid _type


    if (!blk._type || !validBlockTypes.includes(blk._type)) {
      // Special case where block type is set to default 'block', but the block type is named something else according to the schema.
      if (blk._type === 'block') {
        var currentBlockTypeName = portableTextFeatures.types.block.name;
        resolution = {
          patches: [(0, _PatchEvent.set)(_objectSpread(_objectSpread({}, blk), {}, {
            _type: currentBlockTypeName
          }), [{
            _key: blk._key
          }])],
          description: "Block with _key '".concat(blk._key, "' has invalid type name '").concat(blk._type, "'. According to the schema, the block type name is '").concat(currentBlockTypeName, "'"),
          action: "Use type '".concat(currentBlockTypeName, "'"),
          item: blk
        };
        return true;
      }

      resolution = {
        patches: [(0, _PatchEvent.unset)([{
          _key: blk._key
        }])],
        description: "Block with _key '".concat(blk._key, "' has invalid _type '").concat(blk._type, "'"),
        action: 'Remove the block',
        item: blk
      };
      return true;
    } // Test that every child in text block is valid


    if (blk._type === portableTextFeatures.types.block.name) {
      // Test that it has children
      if (!blk.children) {
        resolution = {
          patches: [(0, _PatchEvent.unset)([{
            _key: blk._key
          }])],
          description: "Text block with _key '".concat(blk._key, "' is missing required key 'children'."),
          action: 'Remove the block',
          item: blk
        };
        return true;
      } // Test that markDefs exists


      if (!blk.markDefs) {
        resolution = {
          patches: [(0, _PatchEvent.set)(_objectSpread(_objectSpread({}, blk), {}, {
            markDefs: []
          }), [{
            _key: blk._key
          }])],
          description: "Block is missing required key 'markDefs'.",
          action: 'Add empty markDefs array',
          item: blk
        };
        return true;
      } // // Test that every span has .marks
      // const spansWithUndefinedMarks = blk.children
      //   .filter(cld => cld._type === portableTextFeatures.types.span.name)
      //   .filter(cld => typeof cld.marks === 'undefined')
      // if (spansWithUndefinedMarks.length > 0) {
      //   const first = spansWithUndefinedMarks[0]
      //   resolution = {
      //     patches: [
      //       set({...first, marks: []}, [{_key: blk._key}, 'children', {_key: first._key}])
      //     ],
      //     description: `Span has no .marks array`,
      //     action: 'Add empty marks array',
      //     item: first
      //   }
      //   return true
      // }


      var allUsedMarks = (0, _uniq2.default)((0, _flatten2.default)(blk.children.filter(cld => cld._type === portableTextFeatures.types.span.name).map(cld => cld.marks || []))); // // Test that all markDefs are in use
      // if (blk.markDefs && blk.markDefs.length > 0) {
      //   const unusedMarkDefs: string[] = uniq(
      //     blk.markDefs.map(def => def._key).filter(key => !allUsedMarks.includes(key))
      //   )
      //   if (unusedMarkDefs.length > 0) {
      //     resolution = {
      //       patches: unusedMarkDefs.map(key =>
      //         unset([{_key: blk._key}, 'markDefs', {_key: key}])
      //       ),
      //       description: `Block has unused mark definitions: ${unusedMarkDefs.join(', ')}.`,
      //       action: 'Remove unused markDefs',
      //       item: blk
      //     }
      //     return true
      //   }
      // }
      // Test that every annotation mark used has a definition

      var annotationMarks = allUsedMarks.filter(mark => !portableTextFeatures.decorators.map(dec => dec.value).includes(mark));
      var orphanedMarks = annotationMarks.filter(mark => !blk.markDefs.find(def => def._key === mark));

      if (orphanedMarks.length > 0) {
        var children = blk.children.filter(cld => Array.isArray(cld.marks) && cld.marks.some(mark => orphanedMarks.includes(mark)));

        if (children) {
          resolution = {
            patches: children.map(child => {
              return (0, _PatchEvent.set)(child.marks.filter(cmrk => !orphanedMarks.includes(cmrk)), [{
                _key: blk._key
              }, 'children', {
                _key: child._key
              }, 'marks']);
            }),
            description: "Block with _key '".concat(blk._key, "' contains marks (").concat(orphanedMarks.join(', '), ") not supported by the current content model."),
            action: 'Remove invalid marks',
            item: blk
          };
          return true;
        }
      } // Test that children is lengthy


      if (blk.children && blk.children.length === 0) {
        var newSpan = {
          _type: portableTextFeatures.types.span.name,
          _key: keyGenerator(),
          text: ''
        };
        resolution = {
          patches: [(0, _PatchEvent.insert)([newSpan], 'after', [{
            _key: blk._key
          }, 'children', 0])],
          description: "Children for text block with _key '".concat(blk._key, "' is empty."),
          action: 'Insert an empty text',
          item: blk
        };
        return true;
      } // Test every child


      if (blk.children.some((child, cIndex) => {
        if (!child._key) {
          var newchild = _objectSpread(_objectSpread({}, child), {}, {
            _key: keyGenerator()
          });

          resolution = {
            patches: [(0, _PatchEvent.set)(newchild, [{
              _key: blk._key
            }, 'children', cIndex])],
            description: "Child at index ".concat(cIndex, " is missing required _key in block with _key ").concat(blk._key, "."),
            action: 'Set a new random _key on the object',
            item: blk
          };
          return true;
        } // Verify that childs have valid types


        if (!child._type || validChildTypes.includes(child._type) === false) {
          resolution = {
            patches: [(0, _PatchEvent.unset)([{
              _key: blk._key
            }, 'children', {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has invalid '_type' property (").concat(child._type, ")."),
            action: 'Remove the object',
            item: blk
          };
          return true;
        } // Verify that spans have .text


        if (child._type === portableTextFeatures.types.span.name && child.text === undefined) {
          resolution = {
            patches: [(0, _PatchEvent.set)(_objectSpread(_objectSpread({}, child), {}, {
              text: ''
            }), [{
              _key: blk._key
            }, 'children', {
              _key: child._key
            }])],
            description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' is missing text property!"),
            action: "Write an empty .text to the object",
            item: blk
          };
          return true;
        }

        return false;
      })) {
        valid = false;
      }
    }

    return false;
  })) {
    valid = false;
  }

  return {
    valid,
    resolution
  };
}