"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSlateValue = toSlateValue;
exports.fromSlateValue = fromSlateValue;
exports.isEqualToEmptyEditor = isEqualToEmptyEditor;
exports.findBlockAndIndexFromPath = findBlockAndIndexFromPath;
exports.findChildAndIndexFromPath = findChildAndIndexFromPath;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _slate = require("slate");

var _excluded = ["_type", "_key"],
    _excluded2 = ["_type", "_key"],
    _excluded3 = ["value", "_key", "_type", "__inline", "children"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function keepObjectEquality(object, keyMap) {
  var value = keyMap[object._key];

  if (value && (0, _isEqual2.default)(object, value)) {
    return value;
  }

  keyMap[object._key] = object;
  return object;
}

function toSlateValue(value, textBlockType) {
  var keyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (value && Array.isArray(value)) {
    return value.map(block => {
      var _type = block._type,
          _key = block._key,
          rest = _objectWithoutProperties(block, _excluded);

      var isPortableText = block && block._type === textBlockType;

      if (isPortableText) {
        var textBlock = block;
        var hasInlines = false;
        var children = textBlock.children.map(child => {
          var cType = child._type,
              cKey = child._key,
              cRest = _objectWithoutProperties(child, _excluded2);

          if (cType !== 'span') {
            hasInlines = true;
            return keepObjectEquality({
              _type: cType,
              _key: cKey,
              children: [{
                text: ''
              }],
              value: cRest,
              __inline: true
            }, keyMap);
          } // Original object


          return child;
        });

        if (!hasInlines && _slate.Element.isElement(block)) {
          // Original object
          return block;
        }

        return keepObjectEquality(_objectSpread(_objectSpread({
          _type,
          _key
        }, rest), {}, {
          children
        }), keyMap);
      }

      return keepObjectEquality({
        _type,
        _key,
        children: [{
          text: ''
        }],
        value: rest
      }, keyMap);
    });
  }

  return [];
}

function fromSlateValue(value, textBlockType) {
  var keyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (value && Array.isArray(value)) {
    return value.map(block => {
      var isPortableText = block && block._type === textBlockType;

      if (isPortableText && _slate.Element.isElement(block)) {
        var hasInlines = false;
        var children = block.children.map(child => {
          var _type = child._type;

          if (_type !== 'span' && typeof child.value === 'object') {
            hasInlines = true; // eslint-disable-next-line @typescript-eslint/no-unused-vars

            var v = child.value,
                k = child._key,
                t = child._type,
                _i = child.__inline,
                _c = child.children,
                rest = _objectWithoutProperties(child, _excluded3);

            return keepObjectEquality(_objectSpread(_objectSpread({
              _key: k,
              _type: t
            }, rest), v), keyMap);
          }

          return child;
        });

        if (typeof block._key === 'string' && typeof block._type === 'string') {
          if (!hasInlines) {
            // Original object
            return block;
          }

          return keepObjectEquality(_objectSpread(_objectSpread({
            _key: block._key,
            _type: block._type
          }, block), {}, {
            children
          }), keyMap);
        }

        throw new Error('Not a valid block type');
      }

      var _ref = block,
          _key = _ref._key,
          _type = _ref._type;
      var blockValue = block.value;
      return keepObjectEquality(_objectSpread({
        _key,
        _type
      }, typeof blockValue === 'object' ? blockValue : {}), keyMap);
    });
  }

  return value;
}

function isEqualToEmptyEditor(children, portableTextFeatures) {
  return children === undefined || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && children[0]._type === portableTextFeatures.types.block.name && Array.isArray(children[0].children) && children[0].children.length === 1 && children[0].children[0]._type === 'span' && children[0].children[0].text === '';
}

function findBlockAndIndexFromPath(firstPathSegment, children) {
  var blockIndex = -1;
  var isNumber = Number.isInteger(Number(firstPathSegment));

  if (isNumber) {
    blockIndex = Number(firstPathSegment);
  } else if (children) {
    blockIndex = children.findIndex(blk => (0, _isEqual2.default)({
      _key: blk._key
    }, firstPathSegment));
  }

  if (blockIndex > -1) {
    return [children[blockIndex], blockIndex];
  }

  return [undefined, -1];
}

function findChildAndIndexFromPath(secondPathSegment, block) {
  var childIndex = -1;
  var isNumber = Number.isInteger(Number(secondPathSegment));

  if (isNumber) {
    childIndex = Number(secondPathSegment);
  } else {
    childIndex = block.children.findIndex(child => (0, _isEqual2.default)({
      _key: child._key
    }, secondPathSegment));
  }

  if (childIndex > -1) {
    return [block.children[childIndex], childIndex];
  }

  return [undefined, -1];
}