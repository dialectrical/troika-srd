"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _memoize2 = _interopRequireDefault(require("lodash/memoize"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _getBackingStoreRatio = _interopRequireDefault(require("./getBackingStoreRatio"));

var utils2d = _interopRequireWildcard(require("./2d/utils"));

var _shapes = require("./2d/shapes");

var _ImageTool = require("./ImageTool.styles");

var cursors = _interopRequireWildcard(require("./cursors"));

var _constants = require("./constants");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// The margin available in all directions for drawing the crop tool
var MARGIN_PX = 8;
var CROP_HANDLE_SIZE = 12;
var HOTSPOT_HANDLE_SIZE = 10;

function normalizeRect(rect) {
  var flippedY = rect.top > rect.bottom;
  var flippedX = rect.left > rect.right;
  return {
    top: flippedY ? rect.bottom : rect.top,
    bottom: flippedY ? rect.top : rect.bottom,
    left: flippedX ? rect.right : rect.left,
    right: flippedX ? rect.left : rect.right
  };
}

function checkCropBoundaries(value, delta) {
  // Make the experience a little better. Still offsets when dragging back from outside
  if (!value || !value.crop || value.crop.top + delta.top < 0 || value.crop.left + delta.left < 0 || value.crop.right + delta.right < 0 || value.crop.bottom + delta.bottom < 0) {
    return false;
  }

  return true;
}

function limitToBoundaries(value, delta) {
  var _ref = value.crop || _constants.DEFAULT_CROP,
      top = _ref.top,
      right = _ref.right,
      bottom = _ref.bottom,
      left = _ref.left;

  var newValue = _objectSpread({}, value);

  newValue.crop = {
    top: top + (delta.top || 0) > 0 ? top : 0,
    right: right + (delta.right || 0) > 0 ? right : 0,
    bottom: bottom + (delta.bottom || 0) > 0 ? bottom : 0,
    left: left + (delta.left || 0) > 0 ? left : 0
  };
  var newDelta = {
    top: top + (delta.top || 0) > 0 ? delta.top || 0 : 0,
    right: right + (delta.right || 0) > 0 ? delta.right || 0 : 0,
    bottom: bottom + (delta.bottom || 0) > 0 ? delta.bottom || 0 : 0,
    left: left + (delta.left || 0) > 0 ? delta.left || 0 : 0
  };
  return {
    value: newValue,
    delta: newDelta
  };
}

function getCropCursorForHandle(handle) {
  switch (handle) {
    case 'left':
    case 'right':
      return 'col-resize';

    case 'top':
    case 'bottom':
      return 'row-resize';

    case 'topRight':
    case 'bottomLeft':
      return 'nesw-resize';

    case 'topLeft':
    case 'bottomRight':
      return 'nwse-resize';

    default:
      return null;
  }
}

var getDevicePixelRatio = (0, _memoize2.default)(function () {
  var devicePixelRatio = window.devicePixelRatio || 1;
  var ctx = document.createElement('canvas').getContext('2d');
  var backingStoreRatio = (0, _getBackingStoreRatio.default)(ctx) || 1;
  return devicePixelRatio / backingStoreRatio;
});

var ImageTool = /*#__PURE__*/function (_React$PureComponent) {
  _inherits(ImageTool, _React$PureComponent);

  var _super = _createSuper(ImageTool);

  function ImageTool() {
    var _this;

    _classCallCheck(this, ImageTool);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      cropping: false,
      cropMoving: false,
      moving: false
    });

    _defineProperty(_assertThisInitialized(_this), "handleDragStart", function (_ref2) {
      var x = _ref2.x,
          y = _ref2.y;
      var mousePosition = {
        x: x * _this.getScale(),
        y: y * _this.getScale()
      };
      var inHotspot = utils2d.isPointInEllipse(mousePosition, _this.getHotspotRect());
      var inDragHandle = utils2d.isPointInCircle(mousePosition, _this.getDragHandleCoords());

      var activeCropHandle = _this.getActiveCropHandleFor(mousePosition);

      var inCropRect = utils2d.isPointInRect(mousePosition, _this.getCropRect());

      if (activeCropHandle) {
        _this.setState({
          cropping: activeCropHandle
        });
      } else if (inDragHandle) {
        _this.setState({
          resizing: true
        });
      } else if (inHotspot) {
        _this.setState({
          moving: true
        });
      } else if (inCropRect) {
        _this.setState({
          cropMoving: true
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleDrag", function (pos) {
      if (_this.state.cropping) {
        _this.emitCrop(_this.state.cropping, pos);
      } else if (_this.state.cropMoving) {
        _this.emitCropMove(pos);
      } else if (_this.state.moving) {
        _this.emitMove(pos);
      } else if (_this.state.resizing) {
        _this.emitResize(pos);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleDragEnd", function (pos) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          onChangeEnd = _this$props.onChangeEnd;

      _this.setState({
        moving: false,
        resizing: false,
        cropping: false,
        cropMoving: false
      });

      var _this$getClampedValue = _this.getClampedValue(),
          hotspot = _this$getClampedValue.hotspot,
          rawCrop = _this$getClampedValue.crop;

      var crop = normalizeRect(rawCrop);
      var finalValue = {
        crop: {
          top: crop.top,
          bottom: 1 - crop.bottom,
          left: crop.left,
          right: 1 - crop.right
        },
        hotspot: {
          x: hotspot.center.x,
          y: hotspot.center.y,
          height: Math.abs(hotspot.height),
          width: Math.abs(hotspot.width)
        }
      };
      onChange(finalValue);

      if (onChangeEnd) {
        onChangeEnd(finalValue);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleMouseOut", function () {
      _this.setState({
        mousePosition: null
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleMouseMove", function (event) {
      var clientRect = event.target.getBoundingClientRect();

      _this.setState({
        mousePosition: {
          x: (event.clientX - clientRect.left) * _this.getScale(),
          y: (event.clientY - clientRect.top) * _this.getScale()
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "setCanvas", function (node) {
      _this.canvas = node;
    });

    return _this;
  }

  _createClass(ImageTool, [{
    key: "getHotspotRect",
    value: function getHotspotRect() {
      var _this$props2 = this.props,
          value = _this$props2.value,
          image = _this$props2.image;
      var hotspot = value.hotspot || _constants.DEFAULT_HOTSPOT;
      var hotspotRect = new _shapes.Rect().setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y);
      return new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale()).multiply(hotspotRect);
    }
  }, {
    key: "getCropRect",
    value: function getCropRect() {
      var _this$props3 = this.props,
          value = _this$props3.value,
          image = _this$props3.image;
      return new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale()).cropRelative(_shapes.Rect.fromEdges(value.crop || _constants.DEFAULT_CROP).clamp(new _shapes.Rect(0, 0, 1, 1)));
    }
  }, {
    key: "getCropHandles",
    value: function getCropHandles() {
      var inner = this.getCropRect();
      var handleSize = CROP_HANDLE_SIZE * this.getScale();
      var halfCropHandleSize = handleSize / 2;
      var cropHandle = new _shapes.Rect(0, 0, handleSize, handleSize);
      return {
        left: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.center.y - halfCropHandleSize),
        right: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.center.y - halfCropHandleSize),
        top: cropHandle.setTopLeft(inner.center.x - halfCropHandleSize, inner.top - halfCropHandleSize),
        topLeft: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.top - halfCropHandleSize),
        topRight: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.top - halfCropHandleSize),
        bottom: cropHandle.setTopLeft(inner.center.x - halfCropHandleSize, inner.bottom - halfCropHandleSize),
        bottomLeft: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.bottom - halfCropHandleSize),
        bottomRight: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.bottom - halfCropHandleSize)
      };
    }
  }, {
    key: "getActiveCropHandleFor",
    value: function getActiveCropHandleFor(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;
      var cropHandles = this.getCropHandles();
      return Object.keys(cropHandles).find(function (position) {
        return utils2d.isPointInRect({
          x: x,
          y: y
        }, cropHandles[position]);
      });
    }
  }, {
    key: "applyHotspotMoveBy",
    value: function applyHotspotMoveBy(value, delta) {
      var currentHotspot = value && value.hotspot || _constants.DEFAULT_HOTSPOT;
      return Object.assign({}, value, {
        hotspot: Object.assign({}, value.hotspot, {
          x: currentHotspot.x + delta.x,
          y: currentHotspot.y + delta.y
        })
      });
    }
  }, {
    key: "applyHotspotResizeBy",
    value: function applyHotspotResizeBy(value, delta) {
      var currentHotspot = value && value.hotspot || _constants.DEFAULT_HOTSPOT;
      return Object.assign({}, value, {
        hotspot: Object.assign({}, currentHotspot, {
          height: currentHotspot.height + delta.height,
          width: currentHotspot.width + delta.width
        })
      });
    }
  }, {
    key: "applyCropMoveBy",
    value: function applyCropMoveBy(value, delta) {
      var currentCrop = value && value.crop || _constants.DEFAULT_CROP;
      return Object.assign({}, value, {
        crop: Object.assign({}, value.crop, {
          left: currentCrop.left + (delta.left || 0),
          right: currentCrop.right + (delta.right || 0),
          top: currentCrop.top + (delta.top || 0),
          bottom: currentCrop.bottom + (delta.bottom || 0)
        })
      });
    }
  }, {
    key: "emitMove",
    value: function emitMove(pos) {
      var _this$props4 = this.props,
          image = _this$props4.image,
          value = _this$props4.value,
          onChange = _this$props4.onChange;
      var scale = this.getScale();
      var delta = {
        x: pos.x * scale / image.width,
        y: pos.y * scale / image.height
      };
      onChange(this.applyHotspotMoveBy(value, delta));
    }
  }, {
    key: "emitCropMove",
    value: function emitCropMove(pos) {
      var _this$props5 = this.props,
          image = _this$props5.image,
          onChange = _this$props5.onChange,
          value = _this$props5.value;
      var scale = this.getScale();
      var delta = {};
      delta.left = pos.x * scale / image.width;
      delta.right = -pos.x * scale / image.width;
      delta.top = pos.y * scale / image.height;
      delta.bottom = -pos.y * scale / image.height;

      if (checkCropBoundaries(value, delta)) {
        onChange(this.applyCropMoveBy(value, delta));
      }
    }
  }, {
    key: "emitCrop",
    value: function emitCrop(side, pos) {
      var _this$props6 = this.props,
          image = _this$props6.image,
          onChange = _this$props6.onChange,
          value = _this$props6.value;
      var scale = this.getScale();
      var delta = {};

      if (side == 'left' || side === 'topLeft' || side === 'bottomLeft') {
        delta.left = pos.x * scale / image.width;
      } else if (side == 'right' || side === 'topRight' || side === 'bottomRight') {
        delta.right = -pos.x * scale / image.width;
      }

      if (side == 'top' || side === 'topLeft' || side === 'topRight') {
        delta.top = pos.y * scale / image.height;
      } else if (side == 'bottom' || side === 'bottomLeft' || side === 'bottomRight') {
        delta.bottom = -pos.y * scale / image.height;
      }

      var newValue = limitToBoundaries(value, delta).value;
      var newDelta = limitToBoundaries(value, delta).delta;
      onChange(this.applyCropMoveBy(newValue, newDelta));
    }
  }, {
    key: "emitResize",
    value: function emitResize(pos) {
      var _this$props7 = this.props,
          image = _this$props7.image,
          onChange = _this$props7.onChange,
          value = _this$props7.value;
      var scale = this.getScale();
      var delta = {
        x: pos.x * scale * 2 / image.width,
        y: pos.y * scale * 2 / image.height
      };
      onChange(this.applyHotspotResizeBy(value, {
        height: delta.y,
        width: delta.x
      }));
    }
  }, {
    key: "getClampedValue",
    value: function getClampedValue() {
      var value = this.props.value;

      var crop = _shapes.Rect.fromEdges(value.crop || _constants.DEFAULT_CROP).clamp(new _shapes.Rect(0, 0, 1, 1));

      var hotspot = value.hotspot || _constants.DEFAULT_HOTSPOT;
      var hotspotRect = new _shapes.Rect(0, 0, 1, 1).setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y).clamp(crop);
      return {
        crop: crop,
        hotspot: hotspotRect
      };
    }
  }, {
    key: "paintHotspot",
    value: function paintHotspot(context, opacity) {
      var _this$props8 = this.props,
          image = _this$props8.image,
          readOnly = _this$props8.readOnly;
      var imageRect = new _shapes.Rect().setSize(image.width, image.height);

      var _this$getClampedValue2 = this.getClampedValue(),
          hotspot = _this$getClampedValue2.hotspot,
          crop = _this$getClampedValue2.crop;

      var scale = this.getScale();
      var margin = MARGIN_PX * scale;
      context.save();
      drawBackdrop();
      drawEllipse();
      context.clip();
      drawHole();
      context.restore();

      if (!readOnly) {
        drawDragHandle(Math.PI * 1.25);
      }

      function drawEllipse() {
        context.save();
        var dest = imageRect.shrink(margin).multiply(hotspot);
        var scaleY = dest.height / dest.width;
        context.scale(1, scaleY);
        context.beginPath();
        context.globalAlpha = opacity;
        context.arc(dest.center.x, dest.center.y / scaleY, Math.abs(dest.width / 2), 0, 2 * Math.PI, false);
        context.strokeStyle = 'white';
        context.lineWidth = 1.5 * scale;
        context.stroke();
        context.closePath();
        context.restore();
      }

      function drawImage() {
        context.save();

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        context.drawImage.apply(context, [image].concat(args));
        context.restore();
      }

      function drawHole() {
        var src = imageRect.multiply(hotspot);
        var dest = imageRect.shrink(margin).multiply(hotspot);
        drawImage(src.left, src.top, src.width, src.height, dest.left, dest.top, dest.width, dest.height);
      }

      function drawBackdrop() {
        var src = imageRect.cropRelative(crop);
        var dest = imageRect.shrink(margin).cropRelative(crop);
        context.save();
        drawImage(src.left, src.top, src.width, src.height, dest.left, dest.top, dest.width, dest.height);
        context.globalAlpha = 0.5;
        context.fillStyle = 'black';
        context.fillRect(dest.left, dest.top, dest.width, dest.height);
        context.restore();
      }

      function drawDragHandle(radians) {
        context.save();
        var radius = HOTSPOT_HANDLE_SIZE * scale;
        var dest = imageRect.shrink(margin).multiply(hotspot);
        var point = utils2d.getPointAtCircumference(radians, dest);
        context.beginPath();
        context.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
        context.fillStyle = 'rgb(255,255,255)';
        context.fill();
        context.closePath();
        context.restore();
        context.beginPath();
        context.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
        context.strokeStyle = 'rgb(0, 0, 0)';
        context.lineWidth = 0.5 * scale;
        context.stroke();
        context.closePath();
      }
    }
  }, {
    key: "getActualSize",
    value: function getActualSize() {
      var node = this.canvas.domNode;
      return {
        height: node.clientHeight,
        width: node.clientWidth
      };
    }
  }, {
    key: "getDragHandleCoords",
    value: function getDragHandleCoords() {
      var bbox = this.getHotspotRect();
      var point = utils2d.getPointAtCircumference(Math.PI * 1.25, bbox);
      return {
        x: point.x,
        y: point.y,
        radius: 8 * this.getScale()
      };
    }
  }, {
    key: "debug",
    value: function debug(context) {
      context.save();
      var image = this.props.image;
      var bbox = this.getHotspotRect();
      var scale = this.getScale();
      var margin = MARGIN_PX * scale; // IE 10 doesn't support context.setLineDash

      if (context.setLineDash) {
        context.setLineDash([2 * scale, 2 * scale]);
      }

      context.lineWidth = 0.5 * scale;
      context.strokeStyle = 'rgba(200, 200, 200, 0.5)'; // --- center line x

      vline(bbox.center.x); // --- center line y

      hline(bbox.center.y);
      context.strokeStyle = 'rgba(150, 150, 150, 0.5)'; // --- line top

      hline(bbox.top); // --- line bottom

      hline(bbox.bottom); // --- line left

      vline(bbox.left); // --- line right

      vline(bbox.right);
      context.restore();

      function vline(x) {
        line(x, margin, x, image.height - margin);
      }

      function hline(y) {
        line(margin, y, image.width - margin, y);
      }

      function line(x1, y1, x2, y2) {
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();
        context.closePath();
      }
    }
  }, {
    key: "paintBackground",
    value: function paintBackground(context) {
      var image = this.props.image;
      var inner = new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale());
      context.save();
      context.fillStyle = 'white';
      context.clearRect(0, 0, image.width, image.height);
      context.globalAlpha = 0.3; //context.globalCompositeOperation = 'lighten';

      context.drawImage(image, inner.left, inner.top, inner.width, inner.height);
      context.restore();
    }
  }, {
    key: "paint",
    value: function paint(context) {
      var readOnly = this.props.readOnly;
      context.save();
      var pxratio = getDevicePixelRatio();
      context.scale(pxratio, pxratio);
      var opacity = !readOnly && this.state.mousePosition ? 0.8 : 0.2;
      this.paintBackground(context); //return context.restore();

      this.paintHotspot(context, opacity); //this.paintDragHandle(context);

      this.debug(context);
      this.paintCropBorder(context);

      if (!readOnly) {
        this.highlightCropHandles(context, opacity);
      }

      if (this.state.mousePosition) {// this.paintMousePosition(context)
      }

      context.restore();
    }
  }, {
    key: "paintMousePosition",
    value: function paintMousePosition(context) {
      var _this$state$mousePosi = this.state.mousePosition,
          x = _this$state$mousePosi.x,
          y = _this$state$mousePosi.y;
      context.beginPath();
      context.arc(x, y, 14 * this.getScale(), 0, 2 * Math.PI, false);
      context.fillStyle = 'lightblue';
      context.fill();
      context.restore();
    }
  }, {
    key: "paintCropBorder",
    value: function paintCropBorder(context) {
      var cropRect = this.getCropRect();
      context.save();
      context.beginPath();
      context.fillStyle = 'rgba(66, 66, 66, 0.9)';
      context.lineWidth = 1;
      context.rect(cropRect.left, cropRect.top, cropRect.width, cropRect.height);
      context.stroke();
      context.closePath();
      context.restore();
    }
  }, {
    key: "highlightCropHandles",
    value: function highlightCropHandles(context, opacity) {
      var _this2 = this;

      context.save();
      var crophandles = this.getCropHandles(); //context.globalCompositeOperation = "difference";

      Object.keys(crophandles).forEach(function (handle) {
        context.fillStyle = _this2.state.cropping === handle ? "rgba(202, 54, 53, ".concat(opacity, ")") : "rgba(230, 230, 230, ".concat(opacity + 0.4, ")");
        var _crophandles$handle = crophandles[handle],
            left = _crophandles$handle.left,
            top = _crophandles$handle.top,
            height = _crophandles$handle.height,
            width = _crophandles$handle.width;
        context.fillRect(left, top, width, height);
        context.beginPath();
        context.fillStyle = "rgba(66, 66, 66, ".concat(opacity, ")");
        context.rect(left, top, width, height);
        context.closePath();
        context.stroke();
      });
      context.restore();
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var actualSize = this.getActualSize();
      return this.props.image.width / actualSize.width;
    }
  }, {
    key: "getCursor",
    value: function getCursor() {
      var mousePosition = this.state.mousePosition;
      var readOnly = this.props.readOnly;

      if (!mousePosition || readOnly) {
        return 'auto';
      }

      var activeCropArea = this.state.cropping || this.getActiveCropHandleFor(mousePosition);

      if (activeCropArea) {
        return getCropCursorForHandle(activeCropArea);
      }

      var mouseOverDragHandle = utils2d.isPointInCircle(mousePosition, this.getDragHandleCoords());

      if (this.state.resizing || mouseOverDragHandle) {
        return 'move';
      }

      if (this.state.moving || this.state.cropMoving) {
        return "url(".concat(cursors.CLOSE_HAND, "), move");
      }

      var mouseoverHotspot = utils2d.isPointInEllipse(mousePosition, this.getHotspotRect());
      var mouseoverCropRect = utils2d.isPointInRect(mousePosition, this.getCropRect());

      if (mouseoverHotspot || mouseoverCropRect) {
        return "url(".concat(cursors.OPEN_HAND, "), move");
      }

      return 'auto';
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.draw();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.draw();
    }
  }, {
    key: "draw",
    value: function draw() {
      var domNode = this.canvas.domNode;
      var context = domNode.getContext('2d');
      this.paint(context);
      var currentCursor = domNode.style.cursor;
      var newCursor = this.getCursor();

      if (currentCursor !== newCursor) {
        domNode.style.cursor = newCursor;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props9 = this.props,
          image = _this$props9.image,
          readOnly = _this$props9.readOnly;
      var ratio = getDevicePixelRatio();
      return /*#__PURE__*/_react.default.createElement(_ImageTool.RootContainer, null, /*#__PURE__*/_react.default.createElement(_ImageTool.CanvasContainer, {
        readOnly: readOnly,
        ref: this.setCanvas,
        onDrag: this.handleDrag,
        onDragStart: this.handleDragStart,
        onDragEnd: this.handleDragEnd,
        onMouseMove: this.handleMouseMove,
        onMouseOut: this.handleMouseOut,
        height: image.height * ratio,
        width: image.width * ratio
      }));
    }
  }]);

  return ImageTool;
}(_react.default.PureComponent);

exports.default = ImageTool;

_defineProperty(ImageTool, "propTypes", {
  value: _propTypes.default.shape({
    hotspot: _propTypes.default.shape({
      x: _propTypes.default.number,
      y: _propTypes.default.number,
      height: _propTypes.default.number,
      width: _propTypes.default.number
    })
  }),
  image: _propTypes.default.shape({
    height: _propTypes.default.number,
    width: _propTypes.default.number
  }),
  onChange: _propTypes.default.func,
  onChangeEnd: _propTypes.default.func,
  readOnly: _propTypes.default.bool
});

_defineProperty(ImageTool, "defaultProps", {
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onChange: function onChange() {},
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onChangeEnd: function onChangeEnd() {}
});