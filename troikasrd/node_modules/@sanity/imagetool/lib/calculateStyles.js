"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateStyles;

var _constants = require("./constants");

function calculateStyles() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var imageAspect = readAspectRatio(options.image);
  var hotspot = options.hotspot || _constants.DEFAULT_HOTSPOT;
  var crop = options.crop || _constants.DEFAULT_CROP;
  var containerAspect = readAspectRatio(options.container) || imageAspect * readCropAspect(crop);
  var align = options.align || {
    x: 'center',
    y: 'center'
  };
  var result = calculateHotSpotCrop(imageAspect, {
    hotspot: hotspot,
    crop: crop
  }, {
    aspect: containerAspect,
    align: align
  });
  var containerHeight = styleFormat(round(100 / containerAspect));
  return {
    debug: {
      result: result
    },
    container: {
      //outline: '1px solid cyan',
      overflow: 'hidden',
      position: 'relative',
      width: '100%',
      height: containerHeight
    },
    padding: {
      marginTop: containerHeight
    },
    crop: {
      position: 'absolute',
      overflow: 'hidden',
      height: toStylePercentage(result.crop.height),
      width: toStylePercentage(result.crop.width),
      top: toStylePercentage(result.crop.top),
      left: toStylePercentage(result.crop.left)
    },
    image: {
      position: 'absolute',
      height: toStylePercentage(result.image.height),
      width: toStylePercentage(result.image.width),
      top: toStylePercentage(result.image.top),
      left: toStylePercentage(result.image.left)
    }
  };
}

function readAspectRatio(opts) {
  if (!opts) {
    return null;
  }

  if (opts.hasOwnProperty('aspectRatio')) {
    return opts.aspectRatio;
  }

  if (opts.hasOwnProperty('height') || opts.hasOwnProperty('width')) {
    if (typeof opts.height !== 'number' && typeof opts.width !== 'number') {
      throw new Error("Height and width must be numbers, got ".concat(JSON.stringify(opts)));
    }

    return opts.width / opts.height;
  }

  return null;
}

function round(num) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var multiplier = Math.pow(10, decimals);
  return Math.round(num * multiplier) / multiplier;
}

function calculateHotSpotCrop(sourceAspect, descriptor, spec) {
  var crop = descriptor.crop;
  var viewportAspect = spec.aspect;
  var alignment = spec.align; // The rational aspect of the cropped image

  var netWidth = 1.0 - crop.left - crop.right;
  var netHeight = 1.0 - crop.top - crop.bottom; // Places the image inside the crop box

  var outImg = {
    top: -crop.top / netHeight,
    left: -crop.left / netWidth,
    width: 1 / netWidth,
    height: 1 / netHeight
  }; // The rational aspect is the aspect ration of the crop in ratios of the image size meaning the image
  // is always considered having the size 1.0*1.0

  var cropRationalAspect = netWidth / netHeight; // cropAspect is the real aspect ratio of the crop box in pixel-space

  var cropAspect = cropRationalAspect * sourceAspect; // Now we transform the hotspot to be expressed in ratios of the cropped area, not the
  // full image:

  var hotspot = {
    x: (descriptor.hotspot.x - crop.left) / netWidth,
    y: (descriptor.hotspot.y - crop.top) / netHeight,
    height: descriptor.hotspot.height / netHeight,
    width: descriptor.hotspot.width / netWidth
  }; // Lets calculate the maximum scale the image may be presented at without cropping the hotspot. A scale of
  // 1.0 means the cropped image exactly fill the width of the viewport.
  // The scale at which the hotspot would fill the viewport exactly in the X direction

  var maxHotspotXScale = 1.0 / hotspot.width; // The scale at which the hotspot would fill the veiwport exactly in the Y direction

  var maxHotspotYScale = 1.0 / hotspot.height * cropAspect / viewportAspect; // This is the largest scale the image can have while still not cropping the hotspot:

  var maxScale = Math.min(maxHotspotXScale, maxHotspotYScale); // Now lets find the minimum scale we can have while maintaining full bleed (no letterboxing)

  var minFullBleedScale;
  var cropIsTaller = cropAspect <= viewportAspect;

  if (cropIsTaller) {
    // Crop is taller than viewport
    minFullBleedScale = 1.0; // By definition 1.0 fills the width of the viewport exactly with the viewport cutting away from the height of the cropbox
  } else {
    // Image is wider than viewport
    minFullBleedScale = cropAspect / viewportAspect; // At this scale the viewport is filled exactly in the height while cutting away from the sides
  }

  var method;
  var outCrop; // Do we have to letterbox this image in order to leave the hotspot area uncropped?

  if (minFullBleedScale > maxScale) {
    // Yes :-( There is no way to protect the hot spot and still have full bleed, so we are letterboxing it
    method = 'letterbox';
    var letterboxScale;
    var diff = minFullBleedScale - maxScale; // Determine a scale where the image fills one dimension of the container

    if (cropIsTaller) {
      letterboxScale = 1.0 - diff;
    } else {
      letterboxScale = maxScale;
    }

    outCrop = {
      width: letterboxScale,
      height: letterboxScale / cropAspect * viewportAspect
    };
    var hotspotLeft = hotspot.x * outCrop.width - hotspot.width * outCrop.width / 2;

    switch (alignment.x) {
      case 'left':
        outCrop.left = cropIsTaller ? 0 : -hotspotLeft;
        break;

      case 'right':
        // todo: broken atm
        outCrop.left = cropIsTaller ? 1 - outCrop.width : hotspotLeft;
        break;

      case 'center':
        outCrop.left = cropIsTaller ? (1 - outCrop.width) / 2 : -hotspotLeft;
        break;

      default:
        throw new Error("Invalid x alignment: '".concat(alignment.x, "'. Must be either 'left', 'right' or 'center'"));
    }

    var hotspotTop = hotspot.y * outCrop.height - hotspot.height * outCrop.height / 2;

    switch (alignment.y) {
      case 'top':
        outCrop.top = cropIsTaller ? -hotspotTop : 0;
        break;

      case 'bottom':
        // todo: broken atm
        outCrop.top = hotspotTop;
        break;

      case 'center':
        outCrop.top = cropIsTaller ? -hotspotTop : (1 - outCrop.height) / 2;
        break;

      default:
        throw new Error("Invalid y alignment: '".concat(alignment.y, "'. Must be either 'top', 'bottom' or 'center'"));
    }
  } else if (cropIsTaller) {
    // TODO: Clamp hotspot offset to avoid moving image off canvas
    method = 'full_width';
    var top = -hotspot.y / cropAspect * viewportAspect + 0.5;
    var height = minFullBleedScale / cropAspect * viewportAspect; // Clamp top so that we will not move the image off of the viewport

    if (top > 0) {
      top = 0;
    } else if (-top > height - 1.0) {
      top = -(height - 1.0);
    }

    outCrop = {
      width: minFullBleedScale,
      height: height,
      left: 0,
      // Place the Y center of the hotspot near the center of the viewport
      top: top
    };
  } else {
    // crop is wider
    method = 'full_height';
    var width = minFullBleedScale;
    var left = 0.5 - hotspot.x * minFullBleedScale;

    if (left > 0) {
      left = 0;
    } else if (-left > width - 1.0) {
      left = -(width - 1.0);
    } // Clamp left so that we will not move the image off of the viewport.


    outCrop = {
      width: width,
      height: minFullBleedScale / cropAspect * viewportAspect,
      top: 0,
      // Place the X center of the hotspot at the center of the viewport
      left: left
    };
  }

  return {
    method: method,
    crop: outCrop,
    image: outImg
  };
}

function readCropAspect(crop) {
  var height = 1 - crop.top - crop.bottom;
  var width = 1 - crop.left - crop.right;
  return width / height;
}

function styleFormat(num) {
  return num === 0 ? 0 : "".concat(num, "%");
}

function toStylePercentage(num) {
  return styleFormat(round(num * 100));
}