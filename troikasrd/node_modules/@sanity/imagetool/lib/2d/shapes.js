"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rect = exports.Point = exports.Size = void 0;

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Size = function Size(height, width) {
  _classCallCheck(this, Size);

  this.height = height;
  this.width = width;
};

exports.Size = Size;

var Point = function Point(x, y) {
  _classCallCheck(this, Point);

  this.x = x;
  this.y = y;
};

exports.Point = Point;

var HLine = /*#__PURE__*/function () {
  function HLine(y, left, right) {
    _classCallCheck(this, HLine);

    this.y = y;
    this._left = left;
    this._right = right;
  }

  _createClass(HLine, [{
    key: "right",
    get: function get() {
      return new Point(this._right, this.y);
    }
  }, {
    key: "left",
    get: function get() {
      return new Point(this._left, this.y);
    }
  }, {
    key: "length",
    get: function get() {
      return this._right - this._left;
    }
  }]);

  return HLine;
}();

var Corners = /*#__PURE__*/function () {
  function Corners(rect) {
    _classCallCheck(this, Corners);

    this.rect = rect;
  }

  _createClass(Corners, [{
    key: "top",
    get: function get() {
      return new HLine(this.rect.top, this.rect.left, this.rect.right);
    }
  }, {
    key: "bottom",
    get: function get() {
      return new HLine(this.rect.bottom, this.rect.left, this.rect.right);
    }
  }]);

  return Corners;
}();

var Rect = /*#__PURE__*/function () {
  function Rect(left, top, width, height) {
    _classCallCheck(this, Rect);

    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }

  _createClass(Rect, [{
    key: "setTopLeft",
    value: function setTopLeft(left, top) {
      return new Rect(left, top, this.width || 0, this.height || 0);
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      return new Rect(this.left || 0, this.top || 0, width, height);
    }
  }, {
    key: "setCenter",
    value: function setCenter(x, y) {
      var width = this.width || 0;
      var height = this.height || 0;
      return new Rect(x - width / 2, y - height / 2, width || 0, height || 0);
    }
  }, {
    key: "center",
    get: function get() {
      return new Point(this.left + this.width / 2, this.top + this.height / 2);
    }
  }, {
    key: "corners",
    get: function get() {
      return new Corners(this);
    }
  }, {
    key: "right",
    get: function get() {
      return this.left + this.width;
    }
  }, {
    key: "bottom",
    get: function get() {
      return this.top + this.height;
    }
  }, {
    key: "multiply",
    value: function multiply(rect) {
      return new Rect((this.left || 0) + this.width * rect.left, (this.top || 0) + this.height * rect.top, this.width * rect.width, this.height * rect.height);
    }
  }, {
    key: "grow",
    value: function grow(delta) {
      return new Rect(this.left - delta, this.top - delta, this.width + delta * 2, this.height + delta * 2);
    }
  }, {
    key: "shrink",
    value: function shrink(delta) {
      return this.grow(-delta);
    }
  }, {
    key: "cropRelative",
    value: function cropRelative(crop) {
      var top = this.top + crop.top * this.height;
      var left = this.left + crop.left * this.width;
      var height = this.height * crop.height;
      var width = this.width * crop.width;
      return new Rect(left, top, width, height);
    }
  }, {
    key: "clamp",
    value: function clamp(bounds) {
      // always try to fit the whole rect inside given bounds
      // adjust top, left if we can, resize if we must
      var left = this.left,
          top = this.top,
          width = this.width,
          height = this.height;

      if (bounds.width < width) {
        width = bounds.width;
        left = bounds.left;
      }

      if (bounds.height < height) {
        height = bounds.height;
        top = bounds.top;
      }

      if (left + width > bounds.left + bounds.width) {
        left = bounds.right - width;
      }

      if (top + height > bounds.top + bounds.height) {
        top = bounds.bottom - height;
      }

      return new Rect(Math.max(left, bounds.left), Math.max(top, bounds.top), width, height);
    }
  }], [{
    key: "fromEdges",
    value: function fromEdges(_ref) {
      var left = _ref.left,
          right = _ref.right,
          top = _ref.top,
          bottom = _ref.bottom;
      return new Rect(left, top, 1 - left - right, 1 - top - bottom);
    }
  }]);

  return Rect;
}();

exports.Rect = Rect;