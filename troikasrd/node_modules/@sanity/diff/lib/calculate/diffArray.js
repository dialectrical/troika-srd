"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.diffArray = diffArray;
exports.removedArray = removedArray;
exports.addedArray = addedArray;

var _helpers = require("../helpers");

var _diffInput = require("./diffInput");

var _lcs = require("./lcs");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function diffArray(fromInput, toInput, options) {
  if (fromInput === toInput) {
    var fromValue = fromInput.value;
    var toValue = toInput.value;
    return {
      type: 'array',
      action: 'unchanged',
      isChanged: false,
      fromValue,
      toValue,

      get items() {
        var items = diffExactByPosition(fromInput, toInput, options);
        if (!items) throw new Error('invariant broken: equivalent input, but diff detected');
        return (0, _helpers.replaceProperty)(this, 'items', items);
      }

    };
  } // The key-ed approach should handle most cases (_key'ed objects, primitives):


  var keyedA = indexByKey(fromInput);
  var keyedB = indexByKey(toInput);

  if (keyedA && keyedB) {
    return diffArrayByKey(fromInput, keyedA, toInput, keyedB, options);
  } // Check if they are 100% equivalent:


  var items = diffExactByPosition(fromInput, toInput, options);
  if (items) return buildArrayDiff(fromInput, toInput, items, false); // Otherwise we create a diff where we model it as removing the from-items and adding the to-items.

  return diffArrayByReinsert(fromInput, toInput, options);
}

function buildArrayDiff(fromInput, toInput, items, isChanged) {
  var fromValue = fromInput.value;
  var toValue = toInput.value;
  return isChanged ? {
    type: 'array',
    action: 'changed',
    isChanged: true,
    fromValue,
    toValue,
    items,
    annotation: toInput.annotation
  } : {
    type: 'array',
    action: 'unchanged',
    isChanged: false,
    fromValue,
    toValue,
    items
  };
}
/**
 * Diffes the two arrays by position. Returns an `items` array if they are unchanged, or undefined
 * if there are any changes anywhere.
 */


function diffExactByPosition(fromInput, toInput, options) {
  if (fromInput.length !== toInput.length) {
    return undefined;
  }

  var items = [];

  for (var idx = 0; idx < fromInput.length; idx++) {
    var diff = (0, _diffInput.diffInput)(fromInput.at(idx), toInput.at(idx), options);

    if (diff.isChanged) {
      return undefined;
    }

    items.push({
      fromIndex: idx,
      toIndex: idx,
      hasMoved: false,
      diff,
      annotation: toInput.annotationAt(idx)
    });
  }

  return items;
}

function diffArrayByReinsert(fromInput, toInput, options) {
  var items = [];

  for (var idx = 0; idx < toInput.length; idx++) {
    var input = toInput.at(idx);
    items.push({
      fromIndex: undefined,
      toIndex: idx,
      hasMoved: false,
      diff: (0, _diffInput.addedInput)(input, undefined, options),
      annotation: input.annotation
    });
  }

  for (var _idx = 0; _idx < fromInput.length; _idx++) {
    var _input = fromInput.at(_idx);

    items.push({
      fromIndex: _idx,
      toIndex: undefined,
      hasMoved: false,
      diff: (0, _diffInput.removedInput)(_input, undefined, options),
      annotation: _input.annotation
    });
  }

  return buildArrayDiff(fromInput, toInput, items, true);
}

/**
 * Diff an array when all the elements have _key in the same position.
 */
function diffArrayByKey(fromArray, fromKeyIndex, toArray, toKeyIndex, options) {
  var items = [];
  var isChanged = false;

  function diffCommon(key, fromIndex, toIndex, hasMoved) {
    deletePositionInIndex(fromKeyIndex.index, key, fromIndex);
    deletePositionInIndex(toKeyIndex.index, key, toIndex);
    var fromInput = fromArray.at(fromIndex);
    var toInput = toArray.at(toIndex);
    var diff = (0, _diffInput.diffInput)(fromInput, toInput);
    items.push({
      fromIndex,
      toIndex,
      hasMoved,
      diff,
      annotation: toArray.annotationAt(toIndex)
    });

    if (diff.isChanged || fromIndex !== toIndex) {
      isChanged = true;
    }
  }

  var lcs = (0, _lcs.getLongestCommonSubsequence)(fromKeyIndex.keys, toKeyIndex.keys);

  for (var fromIndex = 0; fromIndex < fromKeyIndex.keys.length; fromIndex++) {
    var key = fromKeyIndex.keys[fromIndex];
    var subsequenceIdx = lcs.prevIndices.indexOf(fromIndex);

    if (subsequenceIdx !== -1) {
      // Part of the common subsequence => hasMoved:false
      diffCommon(key, fromIndex, lcs.nextIndices[subsequenceIdx], false);
      continue;
    } // Not a part of the subsequence. Try to find another item which has the same key
    // and also is not part of the common subsequence.


    var toIndexes = toKeyIndex.index.get(key);
    var toIndex = toIndexes && toIndexes.find(idx => !lcs.nextIndices.includes(idx));

    if (toIndex !== undefined) {
      diffCommon(key, fromIndex, toIndex, true);
      continue;
    }

    var input = fromArray.at(fromIndex);
    items.push({
      fromIndex,
      toIndex: undefined,
      hasMoved: false,
      diff: (0, _diffInput.removedInput)(input, undefined, options),
      annotation: fromArray.annotationAt(fromIndex)
    });
    isChanged = true;
  } // The remaining data in toKeyIndex are the new elements which has been added


  var _iterator = _createForOfIteratorHelper(toKeyIndex.index.values()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var positions = _step.value;

      var _iterator2 = _createForOfIteratorHelper(positions),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _toIndex = _step2.value;

          var _input2 = toArray.at(_toIndex);

          items.push({
            fromIndex: undefined,
            toIndex: _toIndex,
            hasMoved: false,
            diff: (0, _diffInput.addedInput)(_input2, undefined, options),
            annotation: toArray.annotationAt(_toIndex)
          });
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      isChanged = true;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  items.sort(compareItemDiff);
  return buildArrayDiff(fromArray, toArray, items, isChanged);
}

function compareItemDiff(a, b) {
  if (a.toIndex !== undefined && b.toIndex !== undefined) {
    return a.toIndex - b.toIndex;
  }

  if (a.fromIndex !== undefined && b.fromIndex !== undefined) {
    return a.fromIndex - b.fromIndex;
  }

  if (a.fromIndex !== undefined && b.toIndex !== undefined) {
    // A was removed and B was added. Prefer to sort removals last.
    return -1;
  }

  if (a.toIndex !== undefined && b.fromIndex !== undefined) {
    // A was added and B was removed. Prefer to sort removals last.
    return 1;
  }

  throw new Error('invalid item diff comparison');
}

function deletePositionInIndex(index, key, pos) {
  var positions = index.get(key);
  deleteArrayValue(positions, pos);

  if (positions.length === 0) {
    index.delete(key);
  }
}

function deleteArrayValue(arr, value) {
  var idx = arr.indexOf(value);
  if (idx === -1) throw new Error('value not found');
  arr.splice(idx, 1);
}

/**
 * Indexes the array by a key. This handles cases where the items are:
 *
 * - Objects with _key
 * - Strings
 * - Numbers
 */
function indexByKey(arr) {
  var index = new Map();
  var keys = [];
  var length = arr.length;

  for (var i = 0; i < length; i++) {
    var item = arr.at(i);
    var key = null;

    switch (item.type) {
      case 'string':
        key = "s".concat(item.value);
        break;

      case 'number':
        key = item.value;
        break;

      case 'boolean':
        key = item.value;
        break;

      case 'null':
        key = 'n';
        break;

      case 'object':
        {
          var keyField = item.get('_key');

          if (keyField && keyField.type === 'string') {
            key = "k".concat(keyField.value); // We do not handle duplicate _key

            if (index.has(key)) return undefined;
          }
        }
        break;

      default:
    } // No key => abort


    if (key === null) return undefined;
    keys.push(key);
    var positions = index.get(key);

    if (!positions) {
      positions = [];
      index.set(key, positions);
    }

    positions.push(i);
  } // All is good.


  return {
    keys,
    index
  };
}

function removedArray(input, toValue, options) {
  return {
    type: 'array',
    action: 'removed',
    isChanged: true,
    fromValue: input.value,
    toValue,
    annotation: input.annotation,

    get items() {
      var items = [];

      for (var i = 0; i < input.length; i++) {
        var item = input.at(i);
        items.push({
          fromIndex: i,
          toIndex: undefined,
          hasMoved: false,
          diff: (0, _diffInput.removedInput)(item, undefined, options),
          annotation: input.annotationAt(i)
        });
      }

      return (0, _helpers.replaceProperty)(this, 'items', items);
    }

  };
}

function addedArray(input, fromValue, options) {
  return {
    type: 'array',
    action: 'added',
    isChanged: true,
    fromValue,
    toValue: input.value,
    annotation: input.annotation,

    get items() {
      var items = [];

      for (var i = 0; i < input.length; i++) {
        var item = input.at(i);
        items.push({
          fromIndex: undefined,
          toIndex: i,
          hasMoved: false,
          diff: (0, _diffInput.addedInput)(item, undefined, options),
          annotation: input.annotationAt(i)
        });
      }

      return (0, _helpers.replaceProperty)(this, 'items', items);
    }

  };
}