"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLongestCommonSubsequence = getLongestCommonSubsequence;

/*
 * Longest common subsequence implementation, for diffing arrays
 * Reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
 */
function getLongestCommonSubsequence(previous, next) {
  var matrix = getLengthMatrix(previous, next);
  var result = backtrack(matrix, previous, next);
  return result;
}

function getLengthMatrix(previous, next) {
  var len1 = previous.length;
  var len2 = next.length;
  var x = 0;
  var y = 0; // initialize empty matrix of len1+1 x len2+1

  var matrix = new Array(len1 + 1);

  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];

    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  } // save sequence lengths for each coordinate


  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (previous[x - 1] === next[y - 1]) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }

  return matrix;
}

function backtrack(matrix, previous, next) {
  var prevIndex = previous.length;
  var nextIndex = next.length;
  var subsequence = {
    sequence: [],
    prevIndices: [],
    nextIndices: []
  };

  while (prevIndex !== 0 && nextIndex !== 0) {
    var areEqual = previous[prevIndex - 1] === next[nextIndex - 1];

    if (areEqual) {
      subsequence.sequence.unshift(previous[prevIndex - 1]);
      subsequence.prevIndices.unshift(prevIndex - 1);
      subsequence.nextIndices.unshift(nextIndex - 1);
      --prevIndex;
      --nextIndex;
    } else {
      var valueAtMatrixAbove = matrix[prevIndex][nextIndex - 1];
      var valueAtMatrixLeft = matrix[prevIndex - 1][nextIndex];

      if (valueAtMatrixAbove > valueAtMatrixLeft) {
        --nextIndex;
      } else {
        --prevIndex;
      }
    }
  }

  return subsequence;
}