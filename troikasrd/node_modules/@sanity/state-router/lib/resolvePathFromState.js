"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolvePathFromState;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _findMatchingNodes = _interopRequireDefault(require("./findMatchingNodes"));

var _debug = require("./utils/debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function resolvePathFromState(node, state) {
  (0, _debug.debug)('Resolving path from state %o', state);
  var match = (0, _findMatchingNodes.default)(node, state);

  if (match.remaining.length > 0) {
    var remaining = match.remaining;
    throw new Error("Unable to find matching route for state. Could not map the following state key".concat(remaining.length == 1 ? '' : 's', " to a valid url: ").concat(remaining.join(', ')));
  }

  if (match.nodes.length === 0) {
    throw new Error("Unable to resolve path from given state: ".concat(JSON.stringify(state)));
  }

  var scopedState = state;
  var relative = (0, _flatten2.default)(match.nodes.map(matchNode => {
    if (matchNode.scope && matchNode.scope in scopedState) {
      scopedState = scopedState[matchNode.scope];
    }

    return matchNode.route.segments.map(segment => {
      if (segment.type === 'dir') {
        return segment.name;
      }

      var transform = matchNode.transform && matchNode.transform[segment.name];
      return transform ? transform.toPath(scopedState[segment.name]) : scopedState[segment.name];
    });
  })).join('/');
  (0, _debug.debug)('Resolved to /%s', relative);
  return "/".concat(relative);
}