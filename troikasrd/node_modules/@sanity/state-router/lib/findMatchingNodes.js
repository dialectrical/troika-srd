"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findMatchingRoutes;

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _intersection2 = _interopRequireDefault(require("lodash/intersection"));

var _difference2 = _interopRequireDefault(require("lodash/difference"));

var _arrayify = _interopRequireDefault(require("./utils/arrayify"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createMatchResult(nodes, missing, remaining) {
  return {
    nodes,
    missing,
    remaining
  };
}

function findMatchingRoutes(node, _state) {
  if (_state === null || _state === undefined) {
    return createMatchResult([], [], []);
  }

  var state = node.scope ? _state[node.scope] : _state;
  var requiredParams = node.route.segments.filter(seg => seg.type === 'param').map(seg => seg.name);
  var stateKeys = state ? Object.keys(state) : [];
  var consumedParams = (0, _intersection2.default)(stateKeys, requiredParams);
  var missingParams = (0, _difference2.default)(requiredParams, consumedParams);
  var remainingParams = (0, _difference2.default)(stateKeys, consumedParams);

  if (missingParams.length > 0) {
    return createMatchResult([], missingParams, []);
  }

  if (remainingParams.length === 0) {
    return createMatchResult([node], [], []);
  }

  var children = (typeof node.children === 'function' ? node.children(state) : node.children) || [];

  if (remainingParams.length > 0 && children.length === 0) {
    return createMatchResult([], remainingParams, []);
  }

  var remainingState = (0, _pick2.default)(state, remainingParams);
  var matchingChild = {
    nodes: [],
    remaining: [],
    missing: []
  };
  (0, _arrayify.default)(children).some(childNode => {
    matchingChild = findMatchingRoutes(childNode, remainingState);
    return matchingChild.nodes.length > 0;
  });

  if (matchingChild.nodes.length === 0) {
    return createMatchResult([], missingParams, remainingParams);
  }

  return createMatchResult([node, ...matchingChild.nodes], matchingChild.missing, matchingChild.remaining);
}