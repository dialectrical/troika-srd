import { Diff } from '@sanity/diff';
import { Chunk, Annotation } from '@sanity/field/diff';
import { Transaction, TransactionLogEvent, DocumentRemoteMutationVersionEvent, CombinedDocument } from './types';
export declare type ParsedTimeRef = Chunk | 'loading' | 'invalid';
declare type Options = {
    publishedId: string;
    enableTrace?: boolean;
};
/**
 * Timeline maintains information about the history of a document:
 * Grouping raw translog entries into sensible groups, replaying and
 * reconstructing different versions and abstract other details.
 *
 * Note that this class by itself is not capable of _fetching_ information,
 * but will only organize and structure the incoming translog entries.
 */
export declare class Timeline {
    reachedEarliestEntry: boolean;
    publishedId: string;
    draftId: string;
    private _transactions;
    private _chunks;
    private _possiblePendingTransactions;
    private _recreateTransactionsFrom?;
    private _trace?;
    constructor(opts: Options);
    get chunkCount(): number;
    /** Maps over the chunk from newest to oldest. */
    mapChunks<T>(mapper: (chunk: Chunk, idx: number) => T): T[];
    reset(): void;
    /**
     * Adds a remote mutation to the timeline. This methods assumes that the remote mutations
     * come in correct order for their respective version, but has no ordering requirements
     * across draft/published.
     *
     * Example: [D1, D2, P1] (where D1 and P1 were mutations done to the draft and published
     * version in the same transaction) is a valid input. [P1, D2, D1] is _not_ valid since
     * the mutation for the draft is out of order.
     */
    addRemoteMutation(entry: DocumentRemoteMutationVersionEvent): void;
    addTranslogEntry(event: TransactionLogEvent): void;
    /** Mark that we've reached the earliest entry. */
    didReachEarliestEntry(): void;
    /**
     * updateChunks synchronizes the chunks to match the current state
     * of the transactions array. After calling this method you need
     * to invalidate all Chunks.
     */
    updateChunks(): void;
    private _removeInvalidatedChunks;
    private _addChunksFromTransactions;
    private _invalidateTransactionFrom;
    private _createInitialChunk;
    /**
     * Resolves a time reference.
     *
     * Note that the chunk returned is only valid if the timeline stays constant.
     * Once the timeline is updated, you must re-parse all references.
     */
    parseTimeId(id: string): ParsedTimeRef;
    findLastPublishedBefore(chunk: Chunk | null): ParsedTimeRef;
    isLatestChunk(chunk: Chunk): boolean;
    createTimeId(chunk: Chunk): string;
    lastChunk(): Chunk;
    transactionByIndex(idx: number): Transaction | null;
    chunkByTransactionIndex(idx: number, startChunkIdx?: number): Chunk;
    replayBackwardsBetween(firstIdx: number, lastIdx: number, doc: CombinedDocument): CombinedDocument;
    replayBackwardsUntil(firstIdx: number, doc: CombinedDocument): CombinedDocument;
    calculateDiff(initialDoc: CombinedDocument, finalDoc: CombinedDocument, firstIdx: number, lastIdx: number): Diff<Annotation>;
}
export {};
//# sourceMappingURL=timeline.d.ts.map