import { Timeline } from './timeline';
import { RemoteSnapshotVersionEvent, TransactionLogEvent, CombinedDocument } from './types';
/**
 * The timeline consists of data from (1) the history, (2) live draft mutations, and
 * (3) live published mutations. It's critical for us that the chain of transactions
 * is complete and without holes. The following class can be used as a layer in front
 * of Timeline to ensure this:
 *
 * - Invoke `appendRemoteSnapshotEvent` when there's an incoming remote mutation.
 *   These mutations are buffered internally and _not_ passed to the timeline quite yet.
 *
 * - Once we've received snapshots for both draft and published, then `acceptsHistory`
 *   becomes true and the caller can fetch a chunk of the translog. The flag
 *   `earliestTransactionId` can be used to figure out where to fetch transactions from.
 *
 * - The caller invokes `prependHistoryEvent` for each of the events. These history events
 *   are always pushed to the timeline and it will become available immediately.
 *
 * - Internally this class will then try to align the history event to the received
 *   mutations and then dispatch to the timeline.
 *
 * - The aligner also maintains the latest version for both the draft and the published version.
 *
 *
 */
export declare class Aligner {
    timeline: Timeline;
    earliestTransactionId: string | null;
    constructor(timeline: Timeline);
    private _states;
    appendRemoteSnapshotEvent(evt: RemoteSnapshotVersionEvent): void;
    prependHistoryEvent(evt: TransactionLogEvent): void;
    didReachEarliestEntry(): void;
    get isAligned(): boolean;
    get acceptsHistory(): boolean;
    get currentDocument(): CombinedDocument;
    private _alignAtIndex;
    private get _isComplete();
    private _apply;
    private _maybeInvalidateHistory;
}
//# sourceMappingURL=aligner.d.ts.map