"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePanes = resolvePanes;
exports.setStructureResolveError = exports.useStructure = exports.loadStructure = exports.maybeSerialize = void 0;

var _react = require("react");

var _shallowEquals = _interopRequireDefault(require("shallow-equals"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _leven = _interopRequireDefault(require("leven"));

var _constants = require("../constants");

var _defaultStructure = _interopRequireDefault(require("../defaultStructure"));

var _isSubscribable = _interopRequireDefault(require("./isSubscribable"));

var _validateStructure = _interopRequireDefault(require("./validateStructure"));

var _serializeStructure = _interopRequireDefault(require("./serializeStructure"));

var _generateHelpUrl = _interopRequireDefault(require("@sanity/generate-help-url"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var KNOWN_STRUCTURE_EXPORTS = ['getDefaultDocumentNode'];
var prevStructureError = null;

if (__DEV__) {
  if (module.hot && module.hot.data) {
    prevStructureError = module.hot.data.prevError;
  }

  if (module.hot) {
    module.hot.dispose(data => {
      data.prevError = prevStructureError;
    });
  }
}

function resolvePanes(structure, paneGroups, prevStructure, fromIndex, options) {
  var waitStructure = (0, _isSubscribable.default)(structure) ? (0, _rxjs.from)(structure) : (0, _rxjs.of)(structure);
  return waitStructure.pipe((0, _operators.switchMap)(struct => resolveForStructure(struct, paneGroups, prevStructure, fromIndex, options)));
}

function getInitialPanes(prevStructure, numPanes, fromIndex) {
  var allLoading = new Array(numPanes).fill(_constants.LOADING_PANE);

  if (!prevStructure) {
    return allLoading;
  }

  var remains = prevStructure.slice(0, fromIndex);
  return remains.concat(allLoading.slice(fromIndex));
}

function sumPaneSegments(paneGroups) {
  return paneGroups.reduce((count, curr) => count + curr.length, 0);
}

function resolveForStructure(structure, paneGroups, prevStructure, fromIndex) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  return _rxjs.Observable.create(subscriber => {
    try {
      (0, _validateStructure.default)(structure);
    } catch (err) {
      subscriber.error(err);
      return unsubscribe;
    }

    var paneSegments = [[{
      id: structure.id
    }]].concat(paneGroups).filter(pair => pair && pair.length > 0);
    var totalPanes = sumPaneSegments(paneSegments);

    var _fromIndex = _slicedToArray(fromIndex, 2),
        fromRootIndex = _fromIndex[0],
        fromSplitIndex = _fromIndex[1];

    var panes = getInitialPanes(prevStructure, totalPanes, fromRootIndex + 1 + fromSplitIndex);
    var subscriptions = []; // Start with all-loading (or previous structure) state

    subscriber.next(panes);
    var resolveFrom = Math.max(0, panes.indexOf(_constants.LOADING_PANE));
    var resolveFromIndex = findSegmentGroupIndexForPaneAtIndex(resolveFrom); // Start resolving pane-by-pane

    resolve(resolveFromIndex, fromSplitIndex || 0);
    return unsubscribe;

    function resolve(index, splitIndex) {
      if (index > paneSegments.length - 1) {
        return;
      }

      var parent = index === 0 ? null : findParentForSegmentIndex(index - 1);
      var path = paneSegments.slice(0, index + 1).map(segment => segment[0].id);
      var context = {
        parent,
        index,
        splitIndex,
        path
      };

      if (index === 0) {
        var id = paneSegments[index][splitIndex].id;
        subscribeForUpdates(structure, index, 0, context, [id, context]);
        return;
      }

      if (!parent || !parent.child) {
        return;
      }

      var siblings = paneSegments[index];

      for (var i = splitIndex; i < siblings.length; i++) {
        var _id = siblings[i].id;

        var isFallbackEditor = index === 1 && _id.startsWith('__edit__');

        var child = isFallbackEditor ? resolveFallbackEditor : parent.child;
        var resolverArgs = getResolverArgumentsForSibling(siblings[i], context, isFallbackEditor);
        subscribeForUpdates(child, index, i, context, resolverArgs);
      }
    }

    function getResolverArgumentsForSibling(sibling, context, isFallbackEditor) {
      var id = sibling.id,
          params = sibling.params,
          payload = sibling.payload;
      return isFallbackEditor ? [id, context, {
        params,
        payload
      }] : [id, context];
    }

    function subscribeForUpdates(pane, index, splitIndex, context, resolverArgs) {
      var source = (0, _serializeStructure.default)(pane, context, resolverArgs);
      subscriptions.push(source.subscribe(result => emit(result, index, splitIndex), error => subscriber.error(error)));
    }

    function findSegmentGroupIndexForPaneAtIndex(index) {
      for (var i = 0, pane = 0; i < paneSegments.length; i++) {
        for (var x = 0; x < paneSegments[i].length; x++) {
          // eslint-disable-next-line max-depth
          if (pane === index) {
            return i;
          }

          pane++;
        }
      }

      return null;
    }

    function findFlatIndexForPane(index, splitIndex) {
      if (index === 0) {
        return splitIndex;
      }

      var flatIndex = 0;

      for (var i = 0; index < paneSegments.length && i <= index; i++) {
        if (i === index) {
          return flatIndex + splitIndex;
        }

        flatIndex += paneSegments[i].length;
      }

      return null;
    }

    function findParentForSegmentIndex(index) {
      var parentGroupIndex = findSegmentGroupIndexForPaneAtIndex(index);
      return parentGroupIndex === null ? null : panes[parentGroupIndex];
    }

    function emit(pane, index, splitIndex) {
      if (typeof pane === 'undefined' && !options.silent) {
        // eslint-disable-next-line no-console
        console.warn('Pane at index %d returned no child %s - see %s', index, splitIndex ? "for split pane index ".concat(splitIndex) : '', (0, _generateHelpUrl.default)('structure-item-returned-no-child'));
      }

      if (maybeReplacePane(pane, index, splitIndex)) {
        subscriber.next(panes); // eslint-disable-line callback-return
      }

      if (splitIndex === 0) {
        resolve(index + 1, splitIndex);
      }
    }

    function maybeReplacePane(pane, index, splitIndex) {
      // `panes` are flat: so we need to figure out the correct index based on the groups
      var flatIndex = findFlatIndexForPane(index, splitIndex);

      if (panes[flatIndex] === pane || (0, _shallowEquals.default)(panes[flatIndex], pane)) {
        return false;
      }

      panes = panes.slice();

      if (pane) {
        panes.splice(flatIndex, 1, pane);
      } else {
        panes.splice(flatIndex);
      }

      return true;
    }

    function resolveFallbackEditor(nodeId, context, _ref) {
      var params = _ref.params,
          payload = _ref.payload;
      var id = nodeId.replace(/^__edit__/, '');
      var template = params.template,
          type = params.type;
      return {
        id: 'editor',
        type: 'document',
        options: {
          id,
          template,
          type,
          templateParameters: payload
        }
      };
    }

    function unsubscribe() {
      while (subscriptions.length) {
        subscriptions.pop().unsubscribe();
      }
    }
  });
}

var maybeSerialize = structure => structure && typeof structure.serialize === 'function' ? structure.serialize({
  path: []
}) : structure; // We are lazy-requiring/resolving the structure inside of a function in order to catch errors
// on the root-level of the module. Any loading errors will be caught and emitted as errors
// eslint-disable-next-line complexity


exports.maybeSerialize = maybeSerialize;

var loadStructure = () => {
  var structure;

  try {
    var mod = require('part:@sanity/desk-tool/structure?') || _defaultStructure.default;

    structure = mod && mod.__esModule ? mod.default : mod;
    warnOnUnknownExports(mod); // On invalid modules, when HMR kicks in, we sometimes get an empty object back when the
    // source has changed without fixing the problem. In this case, keep showing the error

    if (__DEV__ && prevStructureError && structure && structure.constructor.name === 'Object' && Object.keys(structure).length === 0) {
      return (0, _rxjs.throwError)(prevStructureError);
    }

    prevStructureError = null;
  } catch (err) {
    prevStructureError = err;
    return (0, _rxjs.throwError)(err);
  }

  if (!isStructure(structure)) {
    return (0, _rxjs.throwError)(new Error("Structure needs to export a function, an observable, a promise or a stucture builder, got ".concat(typeof structure)));
  } // Defer to catch immediately thrown errors on serialization


  return (0, _rxjs.defer)(() => (0, _serializeStructure.default)(structure));
};

exports.loadStructure = loadStructure;

var useStructure = function useStructure(segments) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var hasSegments = Boolean(segments);
  var numSegments = sumPaneSegments(segments || []);

  var _useState = (0, _react.useState)({
    structure: null,
    error: null
  }),
      _useState2 = _slicedToArray(_useState, 2),
      _useState2$ = _useState2[0],
      structure = _useState2$.structure,
      error = _useState2$.error,
      setStructure = _useState2[1]; // @todo This leads to deep update loops unless we serialize paneSegments
  // @todo We should try to memoize/prevent this without resorting to JSON.stringify


  (0, _react.useEffect)(() => {
    if (!hasSegments) {
      return () => null;
    }

    setStructure({
      structure: getInitialPanes(null, numSegments, 0)
    });
    var subscription = loadStructure().pipe((0, _operators.distinctUntilChanged)(), (0, _operators.map)(maybeSerialize), (0, _operators.switchMap)(newStructure => resolvePanes(newStructure, segments, structure, [0, 0], options))).subscribe(newStructure => setStructure({
      structure: newStructure
    }), resolveError => setStructure({
      error: resolveError
    }));
    return () => subscription.unsubscribe();
  }, [JSON.stringify(segments)]);
  return {
    structure,
    error
  };
};

exports.useStructure = useStructure;

var setStructureResolveError = err => {
  prevStructureError = err;
};

exports.setStructureResolveError = setStructureResolveError;

function isStructure(structure) {
  return structure && (typeof structure === 'function' || typeof structure.serialize !== 'function' || typeof structure.then !== 'function' || typeof structure.subscribe !== 'function' || typeof structure.type !== 'string');
}

function warnOnUnknownExports(mod) {
  if (!mod) {
    return;
  }

  var known = KNOWN_STRUCTURE_EXPORTS.concat('default');
  var keys = Object.keys(mod);
  keys.filter(key => !known.includes(key)).forEach(key => {
    var _known$reduce = known.reduce((acc, current) => {
      var distance = (0, _leven.default)(current, key);
      return distance < 3 && distance < acc.distance ? {
        closest: current,
        distance
      } : acc;
    }, {
      closest: null,
      distance: +Infinity
    }),
        closest = _known$reduce.closest;

    var hint = closest ? " - did you mean \"".concat(closest, "\"") : ''; // eslint-disable-next-line

    console.warn("Unknown structure export \"".concat(key, "\"").concat(hint));
  });
}