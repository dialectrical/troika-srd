"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactPropsStream = require("react-props-stream");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _schema = _interopRequireDefault(require("part:@sanity/base/schema"));

var _preview = require("part:@sanity/base/preview");

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _initialValueTemplates = require("@sanity/base/initial-value-templates");

var _PaneRouterContext = require("../contexts/PaneRouterContext");

var _errorPane = require("../panes/errorPane");

var _loadingPane = require("../panes/loadingPane");

var _BrokenReferences = require("../components/BrokenReferences");

var _excluded = ["options", "paneContext"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var withInitialValue = Pane => {
  var WithInitialValueStream = (0, _reactPropsStream.streamingComponent)(props$ => props$.pipe((0, _operators.switchMap)(props => {
    var options = props.options,
        paneContext = props.paneContext,
        paneProps = _objectWithoutProperties(props, _excluded); // See if the document ID has a draft or a published document


    return (0, _rxjs.merge)((0, _preview.observePaths)((0, _draftUtils.getDraftId)(options.id), ['_type']).pipe((0, _operators.map)(draft => ({
      draft
    }))), (0, _preview.observePaths)((0, _draftUtils.getPublishedId)(options.id), ['_type']).pipe((0, _operators.map)(published => ({
      published
    })))).pipe((0, _operators.scan)((prev, res) => _objectSpread(_objectSpread({}, prev), res), {}), // Wait until we know the state of both draft and published
    (0, _operators.filter)(res => 'draft' in res && 'published' in res), (0, _operators.map)(res => res.draft || res.published), // Only update if we didn't previously have a document but we now do
    (0, _operators.distinctUntilChanged)((prev, next) => Boolean(prev) !== Boolean(next)), // Prevent rapid re-resolving when transitioning between different templates
    (0, _operators.debounceTime)(25), (0, _operators.switchMap)(document => {
      var _getInitialValueProps = getInitialValueProps(document, props, paneContext),
          templateName = _getInitialValueProps.templateName,
          parameters = _getInitialValueProps.parameters;

      var shouldResolve = Boolean(templateName);
      var paneOptions = resolvePaneOptions(props, templateName, document);
      var documentType = paneOptions.type;

      if (!shouldResolve) {
        // Wrap in broken references component to prevent "reload"
        // when going from missing document to a document that exists
        return (0, _rxjs.of)( /*#__PURE__*/_react.default.createElement(_BrokenReferences.BrokenReferences, {
          document: {},
          type: documentType,
          schema: _schema.default
        }, /*#__PURE__*/_react.default.createElement(Pane, _extends({}, paneProps, {
          options: paneOptions
        }))));
      }

      return (0, _rxjs.merge)((0, _rxjs.of)({
        isResolving: true
      }), resolveInitialValueWithParameters(templateName, parameters).pipe((0, _operators.catchError)(resolveError => {
        /* eslint-disable no-console */
        console.group('Failed to resolve initial value');
        console.error(resolveError);
        console.error('Template ID: %s', templateName);
        console.error('Parameters: %o', parameters || {});
        console.groupEnd();
        /* eslint-enable no-console */

        return (0, _rxjs.of)({
          resolveError
        });
      }))).pipe((0, _operators.switchMap)(_ref => {
        var isResolving = _ref.isResolving,
            initialValue = _ref.initialValue,
            resolveError = _ref.resolveError;

        if (resolveError) {
          return (0, _rxjs.of)( /*#__PURE__*/_react.default.createElement(_errorPane.ErrorPane, _extends({}, props, {
            title: "Failed to resolve initial value"
          }), /*#__PURE__*/_react.default.createElement("p", null, "Check developer console for details")));
        }

        var title = documentType && "New ".concat(_schema.default.get(documentType).title || documentType);
        return (0, _rxjs.of)(isResolving ? /*#__PURE__*/_react.default.createElement(_loadingPane.LoadingPane, _extends({}, props, {
          title: title,
          message: "Resolving initial value\u2026"
        })) : /*#__PURE__*/_react.default.createElement(_BrokenReferences.BrokenReferences, {
          document: initialValue,
          type: documentType,
          schema: _schema.default
        }, /*#__PURE__*/_react.default.createElement(Pane, _extends({}, paneProps, {
          initialValue: initialValue,
          options: paneOptions
        }))));
      }));
    }));
  })));

  var WithInitialValueWrapper = props => /*#__PURE__*/_react.default.createElement(_PaneRouterContext.PaneRouterContext.Consumer, null, context => /*#__PURE__*/_react.default.createElement(WithInitialValueStream, _extends({}, props, {
    paneContext: context
  })));

  return WithInitialValueWrapper;
};

function getInitialValueProps(document, props, paneContext) {
  if (document) {
    return {};
  }

  var payload = paneContext.payload || {};
  var urlTemplate = (paneContext.params || {}).template;
  var definedTemplate = props.options.template;

  if (urlTemplate && definedTemplate && definedTemplate !== urlTemplate) {
    // eslint-disable-next-line no-console
    console.warn("Conflicting templates: URL says \"".concat(urlTemplate, "\", structure node says \"").concat(definedTemplate, "\". Using \"").concat(definedTemplate, "\"."));
  }

  var _props$options = props.options,
      options = _props$options === void 0 ? {} : _props$options;
  var template = definedTemplate || urlTemplate;
  var typeTemplates = (0, _initialValueTemplates.getTemplatesBySchemaType)(options.type);

  var parameters = _objectSpread(_objectSpread({}, options.templateParameters), payload);

  var templateName = template; // If we have not specified a specific template, and we only have a single
  // template available for a schema type, use it

  if (!template && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }

  return {
    templateName,
    parameters
  };
}

function resolveInitialValueWithParameters(templateName, parameters) {
  if (!(0, _initialValueTemplates.templateExists)(templateName)) {
    // eslint-disable-next-line no-console
    console.warn('Template "%s" not defined, using empty initial value', templateName);
    return (0, _rxjs.of)({
      isResolving: false,
      initialValue: undefined
    });
  }

  return (0, _rxjs.from)((0, _initialValueTemplates.resolveInitialValue)(_schema.default, (0, _initialValueTemplates.getTemplateById)(templateName), parameters)).pipe((0, _operators.map)(initialValue => ({
    isResolving: false,
    initialValue
  })));
}

function resolvePaneOptions(props, templateName, document) {
  var options = props.options;
  var hasDefinedType = options.type && options.type !== '*';
  var typeFromOptions = hasDefinedType ? options.type : undefined;
  var documentType = typeFromOptions || document && document._type;

  if (!documentType && templateName) {
    var template = (0, _initialValueTemplates.getTemplateById)(templateName);
    documentType = template && template.schemaType;
  } // If we were not passed a schema type, use the resolved value if available


  return hasDefinedType ? options : _objectSpread(_objectSpread({}, options), {}, {
    type: documentType
  });
}

var _default = withInitialValue;
exports.default = _default;