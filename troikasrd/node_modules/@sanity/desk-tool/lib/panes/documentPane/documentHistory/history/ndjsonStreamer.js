"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getJsonStream = getJsonStream;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function getJsonStream(_x) {
  return _getJsonStream.apply(this, arguments);
}

function _getJsonStream() {
  _getJsonStream = _asyncToGenerator(function* (url) {
    var options = {
      credentials: 'include'
    };
    var response = yield fetch(url, options);
    return getStream(response);
  });
  return _getJsonStream.apply(this, arguments);
}

function getStream(response) {
  var body = response.body;

  if (!body) {
    throw new Error('Failed to read body from response');
  }

  var reader;
  var cancelled = false;
  return new ReadableStream({
    start(controller) {
      reader = body.getReader();
      var decoder = new TextDecoder();
      var buffer = '';
      reader.read().then(function processResult(result) {
        if (result.done) {
          if (cancelled) {
            return;
          }

          buffer = buffer.trim();

          if (buffer.length === 0) {
            controller.close();
            return;
          }

          controller.enqueue(JSON.parse(buffer));
          controller.close();
          return;
        }

        buffer += decoder.decode(result.value, {
          stream: true
        });
        var lines = buffer.split('\n');

        for (var i = 0; i < lines.length - 1; ++i) {
          var line = lines[i].trim();

          if (line.length === 0) {
            continue;
          }

          try {
            controller.enqueue(JSON.parse(line));
          } catch (err) {
            controller.error(err);
            cancelled = true;
            reader.cancel();
            return;
          }
        }

        buffer = lines[lines.length - 1]; // eslint-disable-next-line consistent-return

        return reader.read().then(processResult).catch(err => controller.error(err));
      }).catch(err => controller.error(err));
    },

    cancel() {
      cancelled = true;
      reader.cancel();
    }

  });
}