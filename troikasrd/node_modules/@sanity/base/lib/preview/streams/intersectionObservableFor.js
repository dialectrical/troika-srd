"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _resize = _interopRequireDefault(require("./resize"));

var _scroll = _interopRequireDefault(require("./scroll"));

var _orientationChange = _interopRequireDefault(require("./orientationChange"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ROOT_MARGIN_PX = 150;
/*
  Adapted from the polyfill at https://github.com/WICG/IntersectionObserver
*/

function isIntersectionObserverSupported() {
  if ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in IntersectionObserverEntry.prototype) {
    // Minimal polyfill for Edge 15's lack of `isIntersecting`
    // See: https://github.com/WICG/IntersectionObserver/issues/211
    if (!('isIntersecting' in IntersectionObserverEntry.prototype)) {
      Object.defineProperty(IntersectionObserverEntry.prototype, 'isIntersecting', {
        get() {
          return this.intersectionRatio > 0;
        }

      });
    }

    return true;
  }

  return false;
}

var _default = isIntersectionObserverSupported() ? createIntersectionObserverBased() : createLegacyBased();

exports.default = _default;

function createIntersectionObserverBased() {
  var intersectionObserverEntries$$ = new _rxjs.Subject();
  var intersectionObserver = new IntersectionObserver(callback, {
    threshold: 0,
    rootMargin: "".concat(ROOT_MARGIN_PX, "px")
  });

  function callback(entries) {
    entries.forEach(entry => {
      intersectionObserverEntries$$.next(entry);
    });
  }

  return function intersectionObservableFor(element) {
    return new _rxjs.Observable(observer => {
      intersectionObserver.observe(element);
      observer.next();
      return () => intersectionObserver.unobserve(element);
    }).pipe((0, _operators.mergeMap)(() => intersectionObserverEntries$$.asObservable()), (0, _operators.filter)(entry => entry.target === element), (0, _operators.map)(ev => ({
      isIntersecting: ev.isIntersecting
    })));
  };
} // This can be removed when intersection observer are supported by the browsers we support


function createLegacyBased() {
  function getViewport() {
    return {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: window.innerHeight
    };
  }

  function intersects(rect, viewport, margin) {
    return rect.left <= viewport.right + margin && rect.right >= viewport.left - margin && rect.top <= viewport.bottom + margin && rect.bottom >= viewport.top - margin;
  }

  function inViewport(element) {
    return () => intersects(element.getBoundingClientRect(), getViewport(), ROOT_MARGIN_PX);
  }

  return function intersectionObservableFor(element) {
    var isElementInViewport = inViewport(element);
    return (0, _rxjs.merge)((0, _rxjs.of)(isElementInViewport()), _resize.default, _scroll.default, _orientationChange.default).pipe((0, _operators.map)(isElementInViewport), // todo: consider "faking" more of the IntersectionObserverEntry api if possible
    (0, _operators.map)(isIntersecting => ({
      isIntersecting
    })));
  };
}