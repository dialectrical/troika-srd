"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cachedObserveFields;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _difference2 = _interopRequireDefault(require("lodash/difference"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _versionedClient = require("../client/versionedClient");

var _debounceCollect = _interopRequireDefault(require("./utils/debounceCollect"));

var _optimizeQuery = require("./utils/optimizeQuery");

var _constants = require("./constants");

var _hasEqualFields = _interopRequireDefault(require("./utils/hasEqualFields"));

var _isUniqueBy = _interopRequireDefault(require("./utils/isUniqueBy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _globalListener;

var getGlobalEvents = () => {
  if (!_globalListener) {
    var allEvents$ = (0, _rxjs.from)(_versionedClient.versionedClient.listen('*[!(_id in path("_.**"))]', {}, {
      events: ['welcome', 'mutation'],
      includeResult: false,
      visibility: 'query',
      tag: 'preview.global'
    })).pipe((0, _operators.share)()); // This is a stream of welcome events from the server, each telling us that we have established listener connection
    // We map these to snapshot fetch/sync. It is good to wait for the first welcome event before fetching any snapshots as, we may miss
    // events that happens in the time period after initial fetch and before the listener is established.

    var welcome$ = allEvents$.pipe((0, _operators.filter)(event => event.type === 'welcome'), (0, _operators.publishReplay)(1), (0, _operators.refCount)()); // This will keep the listener active forever and in turn reduce the number of initial fetches
    // as less 'welcome' events will be emitted.
    // @todo: see if we can delay unsubscribing or connect with some globally defined shared listener

    welcome$.subscribe();
    var mutations$ = allEvents$.pipe((0, _operators.filter)(event => event.type === 'mutation'));
    _globalListener = {
      welcome$,
      mutations$
    };
  }

  return _globalListener;
};

function listen(id) {
  var globalEvents = getGlobalEvents();
  return (0, _rxjs.merge)(globalEvents.welcome$, globalEvents.mutations$.pipe((0, _operators.filter)(event => event.documentId === id)));
}

function fetchAllDocumentPaths(selections) {
  var combinedSelections = (0, _optimizeQuery.combineSelections)(selections);
  return _versionedClient.versionedClient.observable.fetch((0, _optimizeQuery.toGradientQuery)(combinedSelections), {}, {
    tag: 'preview.document-paths'
  }).pipe((0, _operators.map)(result => (0, _optimizeQuery.reassemble)(result, combinedSelections)));
}

var fetchDocumentPathsFast = (0, _debounceCollect.default)(fetchAllDocumentPaths, 100);
var fetchDocumentPathsSlow = (0, _debounceCollect.default)(fetchAllDocumentPaths, 1000);

function listenFields(id, fields) {
  return listen(id).pipe((0, _operators.switchMap)(event => {
    if (event.type === 'welcome' || event.visibility === 'query') {
      return fetchDocumentPathsFast(id, fields).pipe((0, _operators.mergeMap)(result => {
        return (0, _rxjs.concat)((0, _rxjs.of)(result), result === undefined // hack: if we get undefined as result here it can be because the document has
        ? // just been created and is not yet indexed. We therefore need to wait a bit
        // and then re-fetch.
        fetchDocumentPathsSlow(id, fields) : []);
      }));
    }

    return fetchDocumentPathsSlow(id, fields);
  }));
} // keep for debugging purposes for now
// function fetchDocumentPaths(id, selection) {
//   return client.observable.fetch(`*[_id==$id]{_id,_type,${selection.join(',')}}`, {id})
//     .map(result => result[0])
// }


var CACHE = {}; // todo: use a LRU cache instead (e.g. hashlru or quick-lru)

function createCachedFieldObserver(id, fields) {
  var latest = null;
  var changes$ = (0, _rxjs.merge)((0, _rxjs.defer)(() => latest === null ? _rxjs.EMPTY : (0, _rxjs.of)(latest)), listenFields(id, fields)).pipe((0, _operators.tap)(v => latest = v), (0, _operators.publishReplay)(1), (0, _operators.refCount)());
  return {
    id,
    fields,
    changes$
  };
}

function cachedObserveFields(id, fields) {
  if (!(id in CACHE)) {
    CACHE[id] = [];
  }

  var existingObservers = CACHE[id];
  var missingFields = (0, _difference2.default)(fields, (0, _flatten2.default)(existingObservers.map(cachedFieldObserver => cachedFieldObserver.fields)));

  if (missingFields.length > 0) {
    existingObservers.push(createCachedFieldObserver(id, fields));
  }

  var cachedFieldObservers = existingObservers.filter(observer => observer.fields.some(fieldName => fields.includes(fieldName))).map(cached => cached.changes$);
  return (0, _rxjs.combineLatest)(cachedFieldObservers).pipe( // in the event that a document gets deleted, the cached values will be updated to store `undefined`
  // if this happens, we should not pick any fields from it, but rather just return null
  (0, _operators.map)(snapshots => snapshots.filter(Boolean)), // make sure all snapshots agree on same revision
  (0, _operators.filter)(snapshots => (0, _isUniqueBy.default)(snapshots, snapshot => snapshot._rev)), // pass on value with the requested fields (or null if value is deleted)
  (0, _operators.map)(snapshots => snapshots.length === 0 ? null : pickFrom(snapshots, fields)), // emit values only if changed
  (0, _operators.distinctUntilChanged)((0, _hasEqualFields.default)(fields)));
}

function pickFrom(objects, fields) {
  return [..._constants.INCLUDE_FIELDS, ...fields].reduce((result, fieldName) => {
    var value = getFirstFieldValue(objects, fieldName);

    if (value !== undefined) {
      result[fieldName] = value;
    }

    return result;
  }, {});
}

function getFirstFieldValue(objects, fieldName) {
  var value;
  objects.some(object => {
    if (fieldName in object) {
      value = object[fieldName];
      return true;
    }

    return false;
  });
  return value;
}