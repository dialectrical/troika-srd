"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = debounceCollect;

var _rxjs = require("rxjs");

// Takes a observable returning function and returns a debounced function that
// collects arguments until wait time has passed without receiving new calls.
// When wait period is over, calls the original function with the collected arguments
function debounceCollect(fn, wait) {
  var timer;
  var queue = {};
  var idx = 0;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new _rxjs.Observable(obs => {
      clearTimeout(timer);
      timer = setTimeout(flush, wait);
      var queueItem = {
        args: args,
        observer: obs,
        completed: false
      };
      var id = idx++;
      queue[id] = queueItem;
      return () => {
        // console.log('completed', queueItem.args)
        queueItem.completed = true;
      };
    });
  };

  function flush() {
    var currentlyFlushingQueue = queue;
    queue = {};
    var queueItemIds = Object.keys(currentlyFlushingQueue) // Todo: use debug
    // .map(id => {
    //   if (currentlyFlushingQueue[id].completed) {
    //     console.log('Dropped', currentlyFlushingQueue[id].args)
    //   }
    //   return id
    // })
    .filter(id => !currentlyFlushingQueue[id].completed);

    if (queueItemIds.length === 0) {
      // nothing to do
      return;
    }

    var collectedArgs = queueItemIds.map(id => currentlyFlushingQueue[id].args);
    fn(collectedArgs).subscribe({
      next(results) {
        results.forEach((result, i) => {
          var queueItem = currentlyFlushingQueue[queueItemIds[i]];

          if (!queueItem.completed) {
            queueItem.observer.next(results[i]);
          }
        });
      },

      complete() {
        queueItemIds.forEach(id => {
          var entry = currentlyFlushingQueue[id];

          if (!entry.completed) {
            entry.observer.complete();
          }
        });
      },

      error(err) {
        queueItemIds.forEach(id => {
          var entry = currentlyFlushingQueue[id];

          if (!entry.completed) {
            entry.observer.error(err);
          }
        });
      }

    });
  }
}