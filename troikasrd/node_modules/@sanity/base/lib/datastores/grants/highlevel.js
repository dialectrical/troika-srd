"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canCreateType = canCreateType;
exports.canCreateAnyOf = canCreateAnyOf;
exports.canUpdate = canUpdate;
exports.canDelete = canDelete;
exports.canPublish = canPublish;
exports.canUnpublish = canUnpublish;
exports.canDiscardDraft = canDiscardDraft;

var _initialValueTemplates = require("@sanity/initial-value-templates");

var _operators = require("rxjs/operators");

var _rxjs = require("rxjs");

var _schema = _interopRequireDefault(require("part:@sanity/base/schema"));

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _snapshotPair = require("../document/document-pair/snapshotPair");

var _pairChecks = require("./pairChecks");

var _ = _interopRequireDefault(require("./"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getSchemaType(typeName) {
  var type = _schema.default.get(typeName);

  if (!type) {
    throw new Error("No such schema type: ".concat(typeName));
  }

  return type;
}

function canCreateType(id, typeName) {
  var type = getSchemaType(typeName);
  return (0, _rxjs.from)((0, _initialValueTemplates.resolveInitialValueForType)(type)).pipe((0, _operators.mergeMap)(initialValue => {
    return _.default.checkDocumentPermission('create', _objectSpread(_objectSpread({}, initialValue), {}, {
      _id: type.liveEdit ? id : "drafts.".concat(id),
      _type: typeName
    }));
  }));
}

function canCreateAnyOf(types) {
  return (0, _rxjs.combineLatest)(types.map(typeName => canCreateType('dummy-id', typeName))).pipe((0, _operators.map)(results => {
    var granted = results.some(res => res.granted);
    return {
      granted,
      reason: granted ? 'can create at least one document type' : 'cannot create any document type'
    };
  }));
}

function stub(id, type) {
  return {
    _id: id,
    _type: type
  };
}

function canUpdate(id, typeName) {
  var type = getSchemaType(typeName);
  var idPair = getIdPairFromPublished(id);
  return (0, _snapshotPair.snapshotPair)(idPair).pipe((0, _operators.mergeMap)(pair => (0, _rxjs.combineLatest)([pair.draft.snapshots$, pair.published.snapshots$])), (0, _operators.switchMap)(_ref => {
    var _ref2 = _slicedToArray(_ref, 2),
        draft = _ref2[0],
        published = _ref2[1];

    return type.liveEdit ? _.default.checkDocumentPermission('update', published || stub(idPair.publishedId, typeName)) : _.default.checkDocumentPermission('update', // note: we check against the published document (if it exist) here since that's the
    // document that will be created as new draft when user edits it
    draft || published || stub(idPair.draftId, typeName));
  }));
}

function canDelete(id, typeName) {
  var type = getSchemaType(typeName);
  var idPair = getIdPairFromPublished(id);
  return (0, _snapshotPair.snapshotPair)(idPair).pipe((0, _operators.mergeMap)(pair => (0, _rxjs.combineLatest)([pair.draft.snapshots$, pair.published.snapshots$])), (0, _operators.map)(_ref3 => {
    var _ref4 = _slicedToArray(_ref3, 2),
        draft = _ref4[0],
        published = _ref4[1];

    return [draft || stub(idPair.draftId, typeName), published || stub(idPair.publishedId, typeName)];
  }), (0, _operators.switchMap)(_ref5 => {
    var _ref6 = _slicedToArray(_ref5, 2),
        draft = _ref6[0],
        published = _ref6[1];

    return type.liveEdit ? _.default.checkDocumentPermission('update', published) : (0, _pairChecks.checkDeletePermission)({
      draft,
      published
    });
  }));
}

function canPublish(id, typeName) {
  var idPair = getIdPairFromPublished(id);
  return (0, _snapshotPair.snapshotPair)(idPair).pipe((0, _operators.mergeMap)(pair => (0, _rxjs.combineLatest)([pair.draft.snapshots$, pair.published.snapshots$])), (0, _operators.map)(_ref7 => {
    var _ref8 = _slicedToArray(_ref7, 2),
        draft = _ref8[0],
        published = _ref8[1];

    return [draft || stub(idPair.draftId, typeName), published || stub(idPair.publishedId, typeName)];
  }), (0, _operators.switchMap)(_ref9 => {
    var _ref10 = _slicedToArray(_ref9, 2),
        draft = _ref10[0],
        published = _ref10[1];

    return (0, _pairChecks.checkPublishPermission)({
      draft,
      published
    });
  }));
}

function canUnpublish(id, typeName) {
  var idPair = getIdPairFromPublished(id);
  return (0, _snapshotPair.snapshotPair)(idPair).pipe((0, _operators.mergeMap)(pair => (0, _rxjs.combineLatest)([pair.draft.snapshots$, pair.published.snapshots$])), (0, _operators.map)(_ref11 => {
    var _ref12 = _slicedToArray(_ref11, 2),
        draft = _ref12[0],
        published = _ref12[1];

    return [draft || stub(idPair.draftId, typeName), published || stub(idPair.publishedId, typeName)];
  }), (0, _operators.switchMap)(_ref13 => {
    var _ref14 = _slicedToArray(_ref13, 2),
        draft = _ref14[0],
        published = _ref14[1];

    return (0, _pairChecks.checkUnpublishPermission)({
      draft,
      published
    });
  }));
}

function canDiscardDraft(id, typeName) {
  var idPair = getIdPairFromPublished(id);
  return (0, _snapshotPair.snapshotPair)(idPair).pipe((0, _operators.mergeMap)(pair => pair.draft.snapshots$), (0, _operators.map)(draft => draft || stub(idPair.draftId, typeName)), (0, _operators.switchMap)(draft => _.default.checkDocumentPermission('update', draft)));
}

function getIdPairFromPublished(publishedId) {
  if ((0, _draftUtils.isDraftId)(publishedId)) {
    throw new Error('editOpsOf does not expect a draft id.');
  }

  return {
    publishedId,
    draftId: (0, _draftUtils.getDraftId)(publishedId)
  };
}