"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.emitOperation = emitOperation;
exports.operationEvents = void 0;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _operationArgs = require("./operationArgs");

var _delete = require("./operations/delete");

var _publish = require("./operations/publish");

var _patch = require("./operations/patch");

var _commit = require("./operations/commit");

var _discardChanges = require("./operations/discardChanges");

var _unpublish = require("./operations/unpublish");

var _duplicate = require("./operations/duplicate");

var _restore = require("./operations/restore");

var _createMemoizer = require("../utils/createMemoizer");

var _consistencyStatus = require("./consistencyStatus");

function maybeObservable(v) {
  return typeof v === 'undefined' ? (0, _rxjs.of)(null) : v;
}

var operationImpls = {
  del: _delete.del,
  delete: _delete.del,
  publish: _publish.publish,
  patch: _patch.patch,
  commit: _commit.commit,
  discardChanges: _discardChanges.discardChanges,
  unpublish: _unpublish.unpublish,
  duplicate: _duplicate.duplicate,
  restore: _restore.restore
};

var execute = (operationName, operationArgs, extraArgs) => {
  var operation = operationImpls[operationName];
  return (0, _rxjs.defer)(() => (0, _rxjs.merge)((0, _rxjs.of)(null), maybeObservable(operation.execute(operationArgs, ...extraArgs)))).pipe((0, _operators.last)());
};

var operationCalls$ = new _rxjs.Subject();

function emitOperation(operationName, idPair, typeName, extraArgs) {
  operationCalls$.next({
    operationName,
    idPair,
    typeName,
    extraArgs
  });
} // These are the operations that cannot be performed while the document is in an inconsistent state


var REQUIRES_CONSISTENCY = ['publish', 'unpublish', 'discardChanges', 'delete'];
var results$ = operationCalls$.pipe((0, _operators.groupBy)(op => op.idPair.publishedId), (0, _operators.mergeMap)(groups$ => {
  return groups$.pipe( // although it might look like a but, dropping pending async operations here is actually a feature
  // E.g. if the user types `publish` which is async and then starts patching (sync) then the publish
  // should be cancelled
  (0, _operators.switchMap)(args => {
    return (0, _operationArgs.operationArgs)(args.idPair, args.typeName).pipe((0, _operators.take)(1), (0, _operators.switchMap)(operationArgs => {
      var requiresConsistency = REQUIRES_CONSISTENCY.includes(args.operationName);

      if (requiresConsistency) {
        operationArgs.published.commit();
        operationArgs.draft.commit();
      }

      var isConsistent$ = (0, _consistencyStatus.consistencyStatus)(args.idPair).pipe((0, _operators.filter)(Boolean));
      var ready$ = requiresConsistency ? isConsistent$.pipe((0, _operators.take)(1)) : (0, _rxjs.of)(null);
      return ready$.pipe((0, _operators.mergeMap)(() => execute(args.operationName, operationArgs, args.extraArgs)));
    }), (0, _operators.map)(() => ({
      type: 'success',
      args
    })), (0, _operators.catchError)(err => (0, _rxjs.of)({
      type: 'error',
      args,
      error: err
    })));
  }));
}), (0, _operators.share)()); // this enables autocommit after patch operations

var AUTOCOMMIT_INTERVAL = 1000;
var autoCommit$ = results$.pipe((0, _operators.filter)(result => result.type === 'success' && result.args.operationName === 'patch'), (0, _operators.throttleTime)(AUTOCOMMIT_INTERVAL, _rxjs.asyncScheduler, {
  leading: true,
  trailing: true
}), (0, _operators.tap)(result => {
  emitOperation('commit', result.args.idPair, result.args.typeName, []);
}));
autoCommit$.subscribe();
var operationEvents = (0, _createMemoizer.memoize)((idPair, typeName) => results$.pipe((0, _operators.filter)(result => result.args.idPair.publishedId === idPair.publishedId), (0, _operators.map)(result => {
  var _result$args = result.args,
      operationName = _result$args.operationName,
      idPair = _result$args.idPair;
  return result.type === 'success' ? {
    type: 'success',
    op: operationName,
    id: idPair.publishedId
  } : {
    type: 'error',
    op: operationName,
    id: idPair.publishedId,
    error: result.error
  };
})), idPair => idPair.publishedId);
exports.operationEvents = operationEvents;