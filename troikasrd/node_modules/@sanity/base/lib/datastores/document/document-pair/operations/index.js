"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOperationsAPI = createOperationsAPI;
exports.GUARDED = void 0;

var _delete = require("./delete");

var _publish = require("./publish");

var _patch = require("./patch");

var _commit = require("./commit");

var _discardChanges = require("./discardChanges");

var _unpublish = require("./unpublish");

var _duplicate = require("./duplicate");

var _restore = require("./restore");

var _operationEvents = require("../operationEvents");

function createOperationGuard(opName) {
  return {
    disabled: 'NOT_READY',
    execute: () => {
      throw new Error("Called ".concat(opName, " before it was ready."));
    }
  };
} // This creates a version of the operations api that will throw if called.
// Most operations depend on having the "current document state" available locally and if an action gets called
// before we have the state available, we throw an error to signal "premature" invocation before ready


var GUARDED = {
  commit: createOperationGuard('commit'),
  delete: createOperationGuard('delete'),
  del: createOperationGuard('del'),
  publish: createOperationGuard('publish'),
  patch: createOperationGuard('patch'),
  discardChanges: createOperationGuard('discardChanges'),
  unpublish: createOperationGuard('unpublish'),
  duplicate: createOperationGuard('duplicate'),
  restore: createOperationGuard('restore')
};
exports.GUARDED = GUARDED;

var createEmitter = (operationName, idPair, typeName) => function () {
  for (var _len = arguments.length, executeArgs = new Array(_len), _key = 0; _key < _len; _key++) {
    executeArgs[_key] = arguments[_key];
  }

  return (0, _operationEvents.emitOperation)(operationName, idPair, typeName, executeArgs);
};

function wrap(opName, op, operationArgs) {
  var disabled = op.disabled(operationArgs);
  return {
    disabled,
    execute: createEmitter(opName, operationArgs.idPair, operationArgs.typeName)
  };
}

function createOperationsAPI(args) {
  return {
    commit: wrap('commit', _commit.commit, args),
    delete: wrap('delete', _delete.del, args),
    del: wrap('delete', _delete.del, args),
    publish: wrap('publish', _publish.publish, args),
    patch: wrap('patch', _patch.patch, args),
    discardChanges: wrap('discardChanges', _discardChanges.discardChanges, args),
    unpublish: wrap('unpublish', _unpublish.unpublish, args),
    duplicate: wrap('duplicate', _duplicate.duplicate, args),
    restore: wrap('restore', _restore.restore, args)
  };
}