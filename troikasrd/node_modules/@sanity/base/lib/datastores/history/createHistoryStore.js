"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createHistoryStore;
exports.removeMissingReferences = void 0;

var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _rxjs = require("rxjs");

var _transactionCollator = require("@sanity/transaction-collator");

var _operators = require("rxjs/operators");

var _jsonReduce = _interopRequireDefault(require("json-reduce"));

var _draftUtils = require("../../util/draftUtils");

var _versionedClient = require("../../client/versionedClient");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var documentRevisionCache = Object.create(null);

var compileTransactions = (acc, curr) => {
  if (acc[curr.id]) {
    acc[curr.id].mutations = acc[curr.id].mutations.concat(curr.mutations);
    acc[curr.id].timestamp = curr.timestamp;
  } else {
    acc[curr.id] = curr;
  }

  return acc;
};

var ndjsonToArray = ndjson => {
  return ndjson.toString('utf8').split('\n').filter(Boolean).map(line => JSON.parse(line));
};

var getHistory = function getHistory(documentIds) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ids = Array.isArray(documentIds) ? documentIds : [documentIds];
  var time = options.time,
      revision = options.revision;

  if (time && revision) {
    throw new Error("getHistory can't handle both time and revision parameters");
  }

  var dataset = _versionedClient.versionedClient.clientConfig.dataset;
  var url = "/data/history/".concat(dataset, "/documents/").concat(ids.join(','));

  if (revision) {
    url = "".concat(url, "?revision=").concat(revision);
  } else {
    var timestamp = time || new Date().toISOString();
    url = "".concat(url, "?time=").concat(timestamp);
  }

  return _versionedClient.versionedClient.request({
    url
  });
};

var getDocumentAtRevision = (documentId, revision) => {
  var publishedId = (0, _draftUtils.getPublishedId)(documentId);
  var draftId = (0, _draftUtils.getDraftId)(documentId);
  var cacheKey = "".concat(publishedId, "@").concat(revision);

  if (!(cacheKey in documentRevisionCache)) {
    var dataset = _versionedClient.versionedClient.clientConfig.dataset;
    var url = "/data/history/".concat(dataset, "/documents/").concat(publishedId, ",").concat(draftId, "?revision=").concat(revision);
    documentRevisionCache[cacheKey] = _versionedClient.versionedClient.request({
      url
    }).then(_ref => {
      var documents = _ref.documents;
      var published = documents.find(res => res._id === publishedId);
      var draft = documents.find(res => res._id === draftId);
      return draft || published;
    });
  }

  return documentRevisionCache[cacheKey];
};

var getTransactions = documentIds => {
  var ids = Array.isArray(documentIds) ? documentIds : [documentIds];
  var dataset = _versionedClient.versionedClient.clientConfig.dataset;
  var url = "/data/history/".concat(dataset, "/transactions/").concat(ids.join(','), "?excludeContent=true");
  return _versionedClient.versionedClient.request({
    url
  }).then(ndjsonToArray);
};

function historyEventsFor(documentId) {
  var pairs = [(0, _draftUtils.getDraftId)(documentId), (0, _draftUtils.getPublishedId)(documentId)];
  var query = '*[_id in $documentIds]';
  var pastTransactions$ = (0, _rxjs.from)(getTransactions(pairs)).pipe((0, _operators.mergeMap)(transactions => (0, _rxjs.from)(transactions)), (0, _operators.map)(trans => ({
    author: trans.author,
    documentIDs: pairs,
    id: trans.id,
    mutations: trans.mutations,
    timestamp: trans.timestamp
  })), (0, _operators.reduce)(compileTransactions, {}));

  var realtimeTransactions$ = _versionedClient.versionedClient.observable.listen(query, {
    documentIds: pairs
  }).pipe((0, _operators.map)(item => ({
    author: item.identity,
    documentIDs: pairs,
    id: item.transactionId,
    mutations: item.mutations,
    timestamp: item.timestamp
  })), (0, _operators.scan)(compileTransactions, {}));

  return (0, _rxjs.merge)(realtimeTransactions$, pastTransactions$).pipe((0, _operators.scan)((prev, next) => {
    return _objectSpread(_objectSpread({}, prev), next);
  }, {}), (0, _operators.map)(transactions => (0, _transactionCollator.transactionsToEvents)(pairs, Object.keys(transactions).map(key => transactions[key])).reverse()));
}

var getAllRefIds = doc => (0, _jsonReduce.default)(doc, (acc, node) => node && typeof node === 'object' && '_ref' in node && !acc.includes(node._ref) ? [...acc, node._ref] : acc, []);

function jsonMap(value, mapFn) {
  if (Array.isArray(value)) {
    return mapFn(value.map(item => jsonMap(item, mapFn)).filter(item => !(0, _isUndefined2.default)(item)));
  }

  if (value && typeof value === 'object') {
    return mapFn(Object.keys(value).reduce((res, key) => {
      var mappedValue = jsonMap(value[key], mapFn);

      if (!(0, _isUndefined2.default)(mappedValue)) {
        res[key] = mappedValue;
      }

      return res;
    }, {}));
  }

  return mapFn(value);
}

var mapRefNodes = (doc, mapFn) => jsonMap(doc, node => {
  return node && typeof node === 'object' && typeof node._ref === 'string' ? mapFn(node) : node;
});

var removeMissingReferences = (doc, existingIds) => mapRefNodes(doc, refNode => {
  var documentExists = existingIds[refNode._ref];
  return documentExists ? refNode : undefined;
});

exports.removeMissingReferences = removeMissingReferences;

function restore(id, targetId, rev) {
  return (0, _rxjs.from)(getDocumentAtRevision(id, rev)).pipe((0, _operators.mergeMap)(documentAtRevision => {
    var existingIdsQuery = getAllRefIds(documentAtRevision).map(refId => "\"".concat(refId, "\": defined(*[_id==\"").concat(refId, "\"]._id)")).join(',');
    return _versionedClient.versionedClient.observable.fetch("{".concat(existingIdsQuery, "}")).pipe((0, _operators.map)(existingIds => removeMissingReferences(documentAtRevision, existingIds)));
  }), (0, _operators.map)(documentAtRevision => _objectSpread(_objectSpread({}, (0, _omit2.default)(documentAtRevision, '_updatedAt')), {}, {
    _id: targetId
  })), (0, _operators.mergeMap)(restoredDraft => _versionedClient.versionedClient.observable.transaction().createOrReplace(restoredDraft).commit()));
}

function createHistoryStore() {
  return {
    getDocumentAtRevision,
    getHistory,
    getTransactions,
    historyEventsFor,
    restore
  };
}