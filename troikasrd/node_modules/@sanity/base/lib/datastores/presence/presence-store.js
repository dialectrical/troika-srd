"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.documentPresence = exports.globalPresence$ = exports.reportLocations = exports.setLocation = exports.SESSION_ID = void 0;

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _groupBy2 = _interopRequireDefault(require("lodash/groupBy"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _nanoid = require("nanoid");

var _user = _interopRequireDefault(require("../user"));

var _bifur = require("../../client/bifur");

var _connectionStatusStore = require("../connection-status/connection-status-store");

var _mockEvents = require("./mock-events");

var _bifurTransport = require("./message-transports/bifurTransport");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var KEY = 'presence_session_id';

var generate = () => (0, _nanoid.nanoid)(16); // We're keeping the session id in sessionStorage as it will survive page reloads.
// todo:
//  There's a potential issue with window.open(...) here as it inherits the top level session storage and thus will
//  re-use session ids:
//    > Opening a page in a new tab or window creates a new session with the value of the top-level browsing context,
//      which differs from how session cookies work.
//      More at https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage
//  This is _probably_ a quite marginal case and not going to be much of a issue in practice


function getSessionId() {
  try {
    return window.sessionStorage.getItem(KEY);
  } catch (err) {// We don't want to fail hard if session storage can't be accessed for some reason
  }

  return null;
}

function setSessionId(id) {
  try {
    window.sessionStorage.setItem(KEY, id);
  } catch (err) {// We don't want to fail hard if session storage can't be accessed for some reason
  }

  return id;
}

var SESSION_ID = getSessionId() || setSessionId(generate());
exports.SESSION_ID = SESSION_ID;

var _createBifurTransport = (0, _bifurTransport.createBifurTransport)(_bifur.bifur, SESSION_ID),
    _createBifurTransport2 = _slicedToArray(_createBifurTransport, 2),
    presenceEvents$ = _createBifurTransport2[0],
    sendMessage = _createBifurTransport2[1];

var currentLocation$ = new _rxjs.BehaviorSubject([]);
var locationChange$ = currentLocation$.pipe((0, _operators.distinctUntilChanged)());

var setLocation = nextLocation => {
  currentLocation$.next(nextLocation);
};

exports.setLocation = setLocation;

var reportLocations = locations => sendMessage({
  type: 'state',
  locations: locations
});

exports.reportLocations = reportLocations;

var requestRollCall = () => sendMessage({
  type: 'rollCall'
});

var rollCallRequests$ = presenceEvents$.pipe((0, _operators.filter)(event => event.type === 'rollCall'), // do not respond to my own rollcall requests
(0, _operators.filter)(event => event.sessionId !== SESSION_ID));
var REPORT_MIN_INTERVAL = 30000; // Interval to report my own location at

var reportLocationInterval$ = (0, _rxjs.timer)(0, REPORT_MIN_INTERVAL);
var reportLocation$ = (0, _rxjs.defer)(() => (0, _rxjs.merge)(locationChange$, rollCallRequests$)).pipe((0, _operators.switchMap)(() => reportLocationInterval$), (0, _operators.withLatestFrom)(currentLocation$), (0, _operators.map)(_ref => {
  var _ref2 = _slicedToArray(_ref, 2),
      locations = _ref2[1];

  return locations;
}), (0, _operators.auditTime)(200), (0, _operators.switchMap)(locations => reportLocations(locations)), (0, _operators.mergeMapTo)(_rxjs.EMPTY), (0, _operators.share)()); // This represents my rollcall request to other clients
// Note: We are requesting a rollcall whenever we (re)connect

var myRollCall$ = (0, _rxjs.defer)(() => requestRollCall()).pipe((0, _operators.mergeMapTo)(_rxjs.EMPTY));

var connectionChange$ = _connectionStatusStore.connectionStatus$.pipe((0, _operators.map)(status => status.type), (0, _operators.filter)(statusType => statusType === 'connected' || statusType === 'error'), (0, _operators.distinctUntilChanged)());

var debugParams$ = (0, _rxjs.concat)((0, _rxjs.of)(0), (0, _rxjs.fromEvent)(window, 'hashchange')).pipe((0, _operators.map)(() => document.location.hash.toLowerCase().substring(1).split(';')));
var useMock$ = debugParams$.pipe((0, _operators.filter)(args => args.includes('give_me_company')), (0, _operators.switchMapTo)(_mockEvents.mock$));
var debugIntrospect$ = debugParams$.pipe((0, _operators.map)(args => args.includes('introspect')));
var syncEvent$ = (0, _rxjs.merge)(myRollCall$, presenceEvents$).pipe((0, _operators.filter)(event => event.type === 'state' || event.type === 'disconnect'));

var stateEventToSession = stateEvent => {
  return {
    lastActiveAt: stateEvent.timestamp,
    locations: stateEvent.locations,
    sessionId: stateEvent.sessionId,
    userId: stateEvent.userId
  };
};

var states$ = (0, _rxjs.merge)(syncEvent$, useMock$).pipe((0, _operators.scan)((keyed, event) => event.type === 'disconnect' ? (0, _omit2.default)(keyed, event.sessionId) : _objectSpread(_objectSpread({}, keyed), {}, {
  [event.sessionId]: stateEventToSession(event)
}), {}));
var allSessions$ = connectionChange$.pipe((0, _operators.switchMap)(status => status === 'connected' ? (0, _rxjs.merge)(states$, reportLocation$) : _rxjs.NEVER), (0, _operators.map)(keyedSessions => Object.values(keyedSessions)), (0, _operators.switchMap)(sessions => {
  var userIds = (0, _uniq2.default)(sessions.map(sess => sess.userId));
  return (0, _rxjs.from)(_user.default.getUsers(userIds)).pipe((0, _operators.map)(users => sessions.map(session => ({
    // eslint-disable-next-line max-nested-callbacks
    user: users.find(res => res.id === session.userId),
    session: session
  }))));
}), (0, _operators.takeUntil)((0, _rxjs.fromEvent)(window, 'beforeunload').pipe((0, _operators.switchMap)(() => sendMessage({
  type: 'disconnect'
})))), (0, _operators.shareReplay)({
  refCount: true,
  bufferSize: 1
}));
var globalPresence$ = allSessions$.pipe((0, _operators.map)(sessions => {
  var grouped = (0, _groupBy2.default)(sessions.map(s => s.session), e => e.userId);
  return Object.keys(grouped).map(userId => {
    var _sessions$find;

    return {
      user: (_sessions$find = sessions.find(s => s.user.id === userId)) === null || _sessions$find === void 0 ? void 0 : _sessions$find.user,
      sessions: grouped[userId]
    };
  });
}), (0, _operators.withLatestFrom)(debugIntrospect$), (0, _operators.map)(_ref3 => {
  var _ref4 = _slicedToArray(_ref3, 2),
      userAndSessions = _ref4[0],
      debugIntrospect = _ref4[1];

  return userAndSessions.filter(userAndSession => {
    if (debugIntrospect) {
      return true;
    }

    var isCurrent = userAndSession.sessions.some(sess => sess.sessionId === SESSION_ID);
    return !isCurrent;
  });
}), (0, _operators.map)(userAndSessions => userAndSessions.map(userAndSession => {
  var _userAndSession$sessi;

  return {
    user: userAndSession.user,
    status: 'online',
    lastActiveAt: (_userAndSession$sessi = userAndSession.sessions.sort()[0]) === null || _userAndSession$sessi === void 0 ? void 0 : _userAndSession$sessi.lastActiveAt,
    locations: (0, _flatten2.default)((userAndSession.sessions || []).map(session => session.locations || [])).map(location => ({
      type: location.type,
      documentId: location.documentId,
      path: location.path,
      lastActiveAt: location.lastActiveAt
    })).reduce((prev, curr) => prev.concat(curr), [])
  };
})));
exports.globalPresence$ = globalPresence$;

var documentPresence = documentId => {
  return allSessions$.pipe((0, _operators.withLatestFrom)(debugIntrospect$), (0, _operators.switchMap)(_ref5 => {
    var _ref6 = _slicedToArray(_ref5, 2),
        userAndSessions = _ref6[0],
        debugIntrospect = _ref6[1];

    return (0, _rxjs.from)(userAndSessions).pipe((0, _operators.filter)(userAndSession => debugIntrospect || userAndSession.session.sessionId !== SESSION_ID), (0, _operators.flatMap)(userAndSession => (userAndSession.session.locations || []).filter(item => item.documentId === documentId).map(location => ({
      user: userAndSession.user,
      lastActiveAt: userAndSession.session.lastActiveAt,
      path: location.path || []
    }))), (0, _operators.toArray)());
  }));
};

exports.documentPresence = documentPresence;