"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createUserColorManager = createUserColorManager;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _color = require("@sanity/color");

var defaultCurrentUserHue = 'purple'; // Exclude green and red because they can be confused with "add" and "remove"
// Exclude gray because it looks like "color not found"

var USER_COLOR_EXCLUDE_HUES = ['green', 'red', 'gray'];

var defaultHues = _color.COLOR_HUES.filter(hue => !USER_COLOR_EXCLUDE_HUES.includes(hue));

var defaultColors = defaultHues.reduce((colors, hue) => {
  colors[hue] = {
    name: hue,
    background: _color.hues[hue][100].hex,
    border: _color.hues[hue][300].hex,
    text: _color.hues[hue][700].hex,
    tints: _color.hues[hue]
  };
  return colors;
}, {});
var defaultAnonymousColor = {
  name: 'gray',
  background: _color.hues.gray[100].hex,
  border: _color.hues.gray[300].hex,
  text: _color.hues.gray[700].hex,
  tints: _color.hues.gray
};

function createUserColorManager(options) {
  var userColors = options && options.colors || defaultColors;
  var anonymousColor = (options === null || options === void 0 ? void 0 : options.anonymousColor) || defaultAnonymousColor;
  var currentUserColor = options && options.currentUserColor || defaultCurrentUserHue;

  if (!userColors.hasOwnProperty(currentUserColor)) {
    throw new Error("'colors' must contain 'currentUserColor' (".concat(currentUserColor, ")"));
  }

  var userColorKeys = Object.keys(userColors);
  var subscriptions = new Map();
  var previouslyAssigned = new Map();
  var assignedCounts = userColorKeys.reduce((counts, color) => {
    counts[color] = 0;
    return counts;
  }, {}); // This isn't really needed because we're reusing subscriptions,
  // but is useful for debugging and poses a minimal overhead

  var assigned = new Map();
  var currentUserId;

  if (options !== null && options !== void 0 && options.userStore) {
    options.userStore.me.subscribe(user => setCurrentUser(user ? user.id : null));
  }

  return {
    get,
    listen
  };

  function get(userId) {
    if (!userId) {
      return anonymousColor;
    }

    return userColors[getUserHue(userId)];
  }

  function getUserHue(userId) {
    if (userId === currentUserId) {
      return currentUserColor;
    }

    var assignedHue = assigned.get(userId);

    if (assignedHue) {
      return assignedHue;
    } // Prefer to reuse the color previously assigned, BUT:
    // ONLY if it's unused -or- there are no other unused colors


    var prevHue = previouslyAssigned.get(userId);

    if (prevHue && (assignedCounts[prevHue] === 0 || !hasUnusedColor())) {
      return assignHue(userId, prevHue);
    } // Prefer "static" color based on user ID if unused


    var preferredHue = getPreferredHue(userId);

    if (assignedCounts[preferredHue] === 0) {
      return assignHue(userId, preferredHue);
    } // Fall back to least used color, with a preference on the previous
    // used color if there are ties for least used


    return assignHue(userId, getLeastUsedHue(prevHue));
  }

  function listen(userId) {
    var subscription = subscriptions.get(userId);

    if (subscription) {
      return subscription;
    }

    var hue = getUserHue(userId);
    subscription = getObservableColor(userId, hue);
    subscriptions.set(userId, subscription);
    return subscription;
  }

  function assignHue(userId, hue) {
    assigned.set(userId, hue);
    previouslyAssigned.set(userId, hue);
    assignedCounts[hue]++;
    return hue;
  }

  function unassignHue(userId, hue) {
    assigned.delete(userId);
    assignedCounts[hue]--;
  }

  function getUnusedColor() {
    return userColorKeys.find(colorHue => assignedCounts[colorHue] === 0);
  }

  function hasUnusedColor() {
    return Boolean(getUnusedColor());
  }

  function getLeastUsedHue(tieBreakerPreference) {
    var leastUses = +Infinity;
    var leastUsed = [];
    userColorKeys.forEach(colorHue => {
      var uses = assignedCounts[colorHue];

      if (uses === leastUses) {
        leastUsed.push(colorHue);
      } else if (uses < leastUses) {
        leastUses = uses;
        leastUsed = [colorHue];
      }
    });
    return tieBreakerPreference && leastUsed.includes(tieBreakerPreference) ? tieBreakerPreference : leastUsed[0];
  }

  function getObservableColor(userId, hue) {
    return new _rxjs.Observable(subscriber => {
      var userColor = userColors[hue];
      subscriber.next(userColor);
      return () => {
        subscriptions.delete(userId);
        unassignHue(userId, hue);
      };
    }).pipe((0, _operators.shareReplay)({
      refCount: true
    }));
  }

  function setCurrentUser(userId) {
    currentUserId = userId;
    assignedCounts[currentUserColor] += userId ? 1 : -1;
  }

  function getPreferredHue(userId) {
    var hash = 0;

    for (var i = 0; i < userId.length; i++) {
      // eslint-disable-next-line no-bitwise
      hash = (hash << 5) - hash + userId.charCodeAt(i) | 0;
    }

    return userColorKeys[Math.abs(hash) % userColorKeys.length];
  }
}