"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _paths = require("@sanity/util/paths");

var _types = require("@sanity/types");

var _defaultStyle = _interopRequireDefault(require("part:@sanity/components/fieldsets/default-style"));

var _arrowDropDown = _interopRequireDefault(require("part:@sanity/base/arrow-drop-down"));

var _default = _interopRequireDefault(require("part:@sanity/components/labels/default"));

var _status = _interopRequireDefault(require("part:@sanity/components/validation/status"));

var _changeIndicators = require("../../../../change-indicators");

var _presence = require("../../../../presence");

var _FieldStatus = _interopRequireDefault(require("./FieldStatus"));

var _excluded = ["fieldset", "legend", "description", "columns", "level", "className", "isCollapsible", "isCollapsed", "changeIndicator", "children", "tabIndex", "transparent", "markers", "presence"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EMPTY_ARRAY = [];

class Fieldset extends _react.default.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "_focusElement", null);

    _defineProperty(this, "handleToggle", () => {
      this.setState(prevState => ({
        isCollapsed: !prevState.isCollapsed,
        hasBeenToggled: true
      }));
    });

    _defineProperty(this, "handleFocus", event => {
      // Make sure we don't trigger onFocus for child elements
      if (event.target === this._focusElement) {
        if (this.props.onFocus) this.props.onFocus([_paths.FOCUS_TERMINATOR]);
      }
    });

    _defineProperty(this, "setFocusElement", el => {
      this._focusElement = el;
    });

    this.state = {
      isCollapsed: props.isCollapsed || false,
      hasBeenToggled: false
    };
  }

  focus() {
    if (this._focusElement) this._focusElement.focus();
  }

  render() {
    var _this$props = this.props,
        fieldset = _this$props.fieldset,
        legend = _this$props.legend,
        description = _this$props.description,
        columns = _this$props.columns,
        _this$props$level = _this$props.level,
        level = _this$props$level === void 0 ? 1 : _this$props$level,
        className = _this$props.className,
        isCollapsible = _this$props.isCollapsible,
        _ignore = _this$props.isCollapsed,
        changeIndicator = _this$props.changeIndicator,
        children = _this$props.children,
        tabIndex = _this$props.tabIndex,
        transparent = _this$props.transparent,
        _this$props$markers = _this$props.markers,
        markers = _this$props$markers === void 0 ? [] : _this$props$markers,
        presence = _this$props.presence,
        rest = _objectWithoutProperties(_this$props, _excluded);

    var _this$state = this.state,
        isCollapsed = _this$state.isCollapsed,
        hasBeenToggled = _this$state.hasBeenToggled;

    var styles = _objectSpread(_objectSpread({}, _defaultStyle.default), this.props.styles);

    var validation = markers.filter(_types.isValidationMarker);
    var rootClassName = (0, _classnames.default)(styles.root, styles["columns".concat(columns)], styles["level".concat(level)], transparent && styles.transparent, this.props.onFocus && styles.canFocus, className); // Only show a summary of validation issues if field is collapsible and has been collapsed

    var showSummary = isCollapsible && isCollapsed; // Hide the tooltip if field is collapsible, but field is not collapsed

    var hideTooltip = isCollapsible && !isCollapsed;
    var childPresence = isCollapsible && isCollapsed ? presence : [];
    return /*#__PURE__*/_react.default.createElement("div", _extends({}, rest, {
      onFocus: isCollapsible && isCollapsed ? this.handleFocus : null,
      tabIndex: isCollapsible && isCollapsed ? tabIndex : -1,
      ref: this.setFocusElement,
      className: rootClassName
    }), /*#__PURE__*/_react.default.createElement("fieldset", {
      className: styles.fieldset
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.inner
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.header
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.headerMain
    }, /*#__PURE__*/_react.default.createElement("legend", {
      className: "".concat(styles.legend, " ").concat(isCollapsed ? '' : styles.isOpen) // Uses the tabIndex 0 and -1 here to avoid focus state on click
      ,
      tabIndex: isCollapsible ? 0 : undefined,
      onKeyDown: event => event.key === 'Enter' ? this.handleToggle() : false
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.labelContainer,
      onClick: isCollapsible ? this.handleToggle : undefined,
      tabIndex: -1
    }, isCollapsible && /*#__PURE__*/_react.default.createElement("div", {
      className: "".concat(styles.arrow, " ").concat(isCollapsed ? '' : styles.isOpen)
    }, /*#__PURE__*/_react.default.createElement(_arrowDropDown.default, null)), /*#__PURE__*/_react.default.createElement(_default.default, {
      className: styles.label,
      level: 1
    }, legend || fieldset.legend)), /*#__PURE__*/_react.default.createElement(_status.default, {
      className: styles.validationStatus,
      markers: showSummary ? validation.filter(marker => marker.path.length <= level) : validation.filter(marker => marker.path.length < 1),
      showSummary: showSummary,
      hideTooltip: hideTooltip
    })), (description || fieldset.description) && /*#__PURE__*/_react.default.createElement("p", {
      className: "".concat(styles.description, " ").concat(isCollapsed ? '' : styles.isOpen)
    }, description || fieldset.description)), isCollapsible && /*#__PURE__*/_react.default.createElement(_FieldStatus.default, null, /*#__PURE__*/_react.default.createElement(_presence.FieldPresence, {
      maxAvatars: 4,
      presence: childPresence
    }))), isCollapsible && !isCollapsed && /*#__PURE__*/_react.default.createElement("div", {
      className: styles.content
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.fieldWrapper,
      "data-columns": columns && columns > 1
    }, (hasBeenToggled || !isCollapsed) && children)), !isCollapsible && /*#__PURE__*/_react.default.createElement("div", {
      className: styles.content
    }, changeIndicator ? /*#__PURE__*/_react.default.createElement(_changeIndicators.ChangeIndicator, changeIndicator, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.fieldWrapper,
      "data-columns": columns && columns > 1
    }, children)) : /*#__PURE__*/_react.default.createElement("div", {
      className: styles.fieldWrapper,
      "data-columns": columns && columns > 1
    }, children)))));
  }

}

exports.default = Fieldset;

_defineProperty(Fieldset, "defaultProps", {
  children: undefined,
  className: '',
  columns: undefined,
  description: undefined,
  level: 1,
  fieldset: {},
  isCollapsed: false,
  isCollapsible: false,
  // can collapsing be toggled by user?
  markers: EMPTY_ARRAY,
  onFocus: undefined,
  styles: undefined,
  tabIndex: undefined,
  transparent: undefined,
  changeIndicator: true,
  presence: EMPTY_ARRAY
});