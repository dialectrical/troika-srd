"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveParts = resolveParts;
Object.defineProperty(exports, "resolvePlugin", {
  enumerable: true,
  get: function get() {
    return _resolvePlugins.resolvePlugin;
  }
});
exports.resolveProjectRoot = exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _generateHelpUrl = _interopRequireDefault(require("@sanity/generate-help-url"));

var _flattenTree = _interopRequireDefault(require("./flattenTree"));

var _readManifest = _interopRequireDefault(require("./readManifest"));

var _resolvePlugins = require("./resolvePlugins");

var _resolveProjectRoot = _interopRequireDefault(require("./resolveProjectRoot"));

var _removeDuplicatePlugins = _interopRequireDefault(require("./removeDuplicatePlugins"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _default = resolveTree;
exports.default = _default;
var resolveProjectRoot = _resolveProjectRoot.default;
exports.resolveProjectRoot = resolveProjectRoot;

function resolveParts() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = Object.assign({
    basePath: process.cwd()
  }, opts);

  if (options.sync) {
    return mergeResult(resolveTree(options), options);
  }

  return resolveTree(options).then(plugins => mergeResult(plugins, options));
}

function resolveTreeSync(options) {
  var basePath = options.basePath || process.cwd();
  var manifest = (0, _readManifest.default)(options);
  var plugins = (0, _resolvePlugins.resolvePlugins)(manifest.plugins || [], options).concat([getProjectRootPlugin(basePath, manifest)]);
  return plugins.reduce(_flattenTree.default, plugins.slice());
}

function resolveTreeAsync(_x) {
  return _resolveTreeAsync.apply(this, arguments);
}

function _resolveTreeAsync() {
  _resolveTreeAsync = _asyncToGenerator(function* (options) {
    var projectManifest = yield (0, _readManifest.default)(options);
    var plugins = yield (0, _resolvePlugins.resolvePlugins)(projectManifest.plugins || [], options);
    var withRoot = plugins.concat([getProjectRootPlugin(options.basePath, projectManifest)]);
    var flattened = withRoot.reduce(_flattenTree.default, withRoot);
    var deduped = (0, _removeDuplicatePlugins.default)(flattened);
    return deduped;
  });
  return _resolveTreeAsync.apply(this, arguments);
}

function resolveTree() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = Object.assign({
    basePath: process.cwd()
  }, opts);

  if (options.resolveProjectRoot) {
    // @todo Sync vs async
    var resolveOpts = Object.assign({}, options, {
      sync: true
    });
    options.basePath = (0, _resolveProjectRoot.default)(resolveOpts);
  }

  return options.sync ? resolveTreeSync(options) : resolveTreeAsync(options);
}

function getProjectRootPlugin(basePath, manifest) {
  return {
    name: '(project root)',
    path: basePath,
    manifest: manifest,
    plugins: []
  };
}

function mergeResult(plugins) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var definitions = {};
  var implementations = {};
  var result = {
    definitions,
    implementations,
    plugins
  }; // Find plugins that define parts, and do a basic validation on the syntax

  var partPlugins = plugins.map(plugin => {
    if (!plugin.manifest.parts) {
      return false;
    }

    if (!Array.isArray(plugin.manifest.parts)) {
      var help = "See ".concat((0, _generateHelpUrl.default)('plugin-parts-syntax'));
      throw new Error("Plugin \"".concat(plugin.name, "\" has a \"parts\" property which is not an array\n").concat(help));
    }

    return {
      parts: plugin.manifest.parts,
      plugin: plugin
    };
  }).filter(Boolean).reverse();
  partPlugins.forEach(_ref => {
    var parts = _ref.parts,
        plugin = _ref.plugin;
    parts.forEach(part => {
      if (part.name && part.path) {
        assignNonOverridablePart(plugin, part, implementations, definitions, options);
      } else if (part.name) {
        assignDefinitionForAbstractPart(plugin, part, definitions);
      }

      if (part.implements) {
        assignPartImplementation(plugin, part, implementations, definitions, options);
      }
    });
  });
  return result;
}

function assignNonOverridablePart(plugin, part, implementations, definitions, options) {
  // Actual, non-overridable part
  var prevDefinition = definitions[part.name];

  if (prevDefinition) {
    // Part already exists, non-overridable parts can't be redefined
    var existing = "\"".concat(prevDefinition.plugin, "\" (").concat(prevDefinition.path, ")");
    var current = "\"".concat(plugin.name, "\" (").concat(plugin.path, ")");
    throw new Error("".concat("Plugins ".concat(existing, " and ").concat(current, " both define part \"").concat(part.name, "\"") + ' - did you mean to use "implements"?\n' + 'See ').concat((0, _generateHelpUrl.default)('part-declare-vs-implement')));
  }

  definitions[part.name] = getDefinitionDeclaration(plugin, part);
  implementations[part.name] = [getImplementationDeclaration(plugin, part, options)];
}

function assignDefinitionForAbstractPart(plugin, part, definitions) {
  var prevDefinition = definitions[part.name];

  if (prevDefinition && !prevDefinition.loose) {
    // Part already exists, non-overridable parts can't be redefined
    var existing = "\"".concat(prevDefinition.plugin, "\" (").concat(prevDefinition.path, ")");
    var current = "\"".concat(plugin.name, "\" (").concat(plugin.path, ")");
    throw new Error("".concat("Plugins ".concat(existing, " and ").concat(current, " both define part \"").concat(part.name, "\"") + ' - did you mean to use "implements"?\n' + 'See ').concat((0, _generateHelpUrl.default)('part-declare-vs-implement')));
  }

  definitions[part.name] = getDefinitionDeclaration(plugin, part);
}

function assignPartImplementation(plugin, part, implementations, definitions, options) {
  var partName = part.implements;

  if (!part.path) {
    var current = "\"".concat(plugin.name, "\" (").concat(plugin.path, ")");
    throw new Error("".concat("Plugin ".concat(current, " tries to implement a part \"").concat(partName, "\",") + ' but did not define a path. Did you mean to use "name"?\n' + 'See ').concat((0, _generateHelpUrl.default)('part-declare-vs-implement')));
  }

  var prevDefinition = definitions[partName];

  if (prevDefinition && !prevDefinition.isAbstract) {
    var existing = "\"".concat(prevDefinition.plugin, "\" (").concat(prevDefinition.path, ")");

    var _current = "\"".concat(plugin.name, "\" (").concat(plugin.path, ")");

    throw new Error("".concat("Plugin ".concat(_current, " tried to implement part \"").concat(partName, "\", which is already declared") + " as a non-overridable part by ".concat(existing, " - ") + 'See ').concat((0, _generateHelpUrl.default)('implement-non-overridable-part')));
  } else if (!prevDefinition) {
    // In some cases, a user might want to declare a new part name and
    // assign it a non-overridable implementation, while simulatenously
    // fulfilling an existing part using `implements`. In this case,
    // `name`, `implements` and `path` are all set, and we want the part
    // referenced in `implements` to be treated as a non-abstract part.
    // This is why we're explicitly setting `isAbstract` to true below
    // `loose` means that this declaration is "implicit" - the part isn't
    // defined as a `name` + `description` combination, so if we come across
    // a plugin that declares the part outright, we want to use that over this
    definitions[partName] = getDefinitionDeclaration(plugin, part, {
      isAbstract: true,
      loose: true
    });
  }

  if (!implementations[partName]) {
    implementations[partName] = [];
  }

  implementations[partName].push(getImplementationDeclaration(plugin, part, options));
}

function getDefinitionDeclaration(plugin, part) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var isAbstract = typeof options.isAbstract === 'undefined' ? typeof part.path === 'undefined' : options.isAbstract;
  return {
    plugin: plugin.name,
    path: plugin.path,
    description: part.description,
    isAbstract: isAbstract,
    loose: options.loose
  };
}

function getImplementationDeclaration(plugin, part, options) {
  var paths = plugin.manifest.paths || {};
  var pluginPath = plugin.path;

  if (options.isSanityMonorepo) {
    pluginPath = tryResolvePath(pluginPath);
  }

  var isLib = pluginPath.split(_path.default.sep).indexOf('node_modules') !== -1;
  var isDotPath = /^\.{1,2}[\\/]/.test(part.path);
  var useCompiled = options.useCompiledPaths || isLib;
  var basePath = isDotPath ? pluginPath : _path.default.join(pluginPath, (useCompiled ? paths.compiled : paths.source) || '');
  var filePath = _path.default.isAbsolute(part.path) ? part.path : _path.default.resolve(_path.default.join(basePath, part.path));
  return {
    plugin: plugin.name,
    path: filePath
  };
}

function tryResolvePath(dstPath) {
  try {
    return _fs.default.realpathSync(dstPath);
  } catch (err) {
    return dstPath;
  }
}