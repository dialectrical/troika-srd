'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/**
 * Default crop (equals to "whole image")
 */
var DEFAULT_CROP = /*#__PURE__*/Object.freeze({
  left: 0,
  top: 0,
  bottom: 0,
  right: 0
});
/**
 * Default hotspot (equals to horizontal/vertical center, full size of image)
 */

var DEFAULT_HOTSPOT = /*#__PURE__*/Object.freeze({
  x: 0.5,
  y: 0.5,
  height: 1,
  width: 1
});
/**
 * Returns cloned version of the default crop (prevents accidental mutations)
 *
 * @returns Default image crop object
 */

var getDefaultCrop = function getDefaultCrop() {
  return _extends({}, DEFAULT_CROP);
};
/**
 * Returns cloned version of the default hotspot (prevents accidental mutations)
 *
 * @returns Default image hotspot object
 */

var getDefaultHotspot = function getDefaultHotspot() {
  return _extends({}, DEFAULT_HOTSPOT);
};
/**
 * Returns whether or not the passed crop has the default values for a crop region
 *
 * @param crop The crop to return whether or not is the default crop
 * @returns True if passed crop matches default, false otherwise
 */

var isDefaultCrop = function isDefaultCrop(crop) {
  var top = crop.top,
      bottom = crop.bottom,
      left = crop.left,
      right = crop.right;
  var defaultTop = DEFAULT_CROP.top,
      defaultBottom = DEFAULT_CROP.bottom,
      defaultLeft = DEFAULT_CROP.left,
      defaultRight = DEFAULT_CROP.right;
  return top === defaultTop && bottom === defaultBottom && left === defaultLeft && right === defaultRight;
};
/**
 * Returns whether or not the passed hotspot has the default values for a hotspot region
 *
 * @param hotspot The hotspot to return whether or not is the default hotspot
 * @returns True if passed hotspot matches default, false otherwise
 */

var isDefaultHotspot = function isDefaultHotspot(hotspot) {
  var x = hotspot.x,
      y = hotspot.y,
      width = hotspot.width,
      height = hotspot.height;
  var defaultX = DEFAULT_HOTSPOT.x,
      defaultY = DEFAULT_HOTSPOT.y,
      defaultWidth = DEFAULT_HOTSPOT.width,
      defaultHeight = DEFAULT_HOTSPOT.height;
  return x === defaultX && y === defaultY && width === defaultWidth && height === defaultHeight;
};

/**
 * Error type thrown when the library fails to resolve a value, such as an asset ID,
 * filename or project ID/dataset information.
 *
 * The `input` property holds the value passed as the input, which failed to be
 * resolved to something meaningful.
 */
var UnresolvableError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(UnresolvableError, _Error);

  function UnresolvableError(inputSource, message) {
    var _this;

    if (message === void 0) {
      message = 'Failed to resolve asset ID from source';
    }

    _this = _Error.call(this, message) || this;
    _this.unresolvable = true;
    _this.input = inputSource;
    return _this;
  }

  return UnresolvableError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Checks whether or not an error instance is of type UnresolvableError
 *
 * @param err - Error to check for unresolvable error type
 * @returns True if the passed error instance appears to be an unresolveable error
 */

function isUnresolvableError(err) {
  var error = err;
  return Boolean(error.unresolvable && 'input' in error);
}
/**
 * Returns a getter which returns `undefined` instead of throwing,
 * if encountering an `UnresolvableError`
 *
 * @param method - Function to use as resolver
 * @returns Function that returns `undefined` if passed resolver throws UnresolvableError
 * @internal
 */

function getForgivingResolver(method) {
  return function () {
    try {
      return method.apply(void 0, arguments);
    } catch (err) {
      if (isUnresolvableError(err)) {
        return undefined;
      }

      throw err;
    }
  };
}

/**
 * @internal
 */
var cdnUrl = 'https://cdn.sanity.io';
/**
 * @internal
 */

var fileAssetFilenamePattern = /^([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+\.[a-z0-9]+$/;
/**
 * @internal
 */

var fileAssetIdPattern = /^file-[a-zA-Z0-9_]+-[a-z0-9]+$/;
/**
 * @internal
 */

var imageAssetFilenamePattern = /^([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})-\d+x\d+\.[a-z0-9]+$/;
/**
 * @internal
 */

var imageAssetIdPattern = /^image-[a-zA-Z0-9_]+-\d+x\d+-[a-z0-9]+$/;
/**
 * @internal
 */

var pathPattern = /^(?:images|files)\/([a-z0-9]+)\/([a-z0-9][-\w]*)\//;
/**
 * @internal
 */

var idPattern = /^(?:image-[a-zA-Z0-9_]+-\d+x\d+-[a-z0-9]+|file-[a-zA-Z0-9_]+-[a-z0-9]+)$/;
/**
 * For use in cases where the project and dataset doesn't really matter
 *
 * @internal
 */

var dummyProject = {
  projectId: 'a',
  dataset: 'b'
};

/**
 * Checks whether or not the given source is a Sanity reference
 * (an object containing _ref string key)
 *
 * @param ref - Possible reference
 * @returns Whether or not the passed object is a reference
 */
function isReference(ref) {
  return isObject(ref) && typeof ref._ref === 'string';
}
/**
 * Checks whether or not the given source is an asset ID stub
 * (an object containing an `_id` property)
 *
 * @param stub - Possible asset id stub
 * @returns Whether or not the passed object is an object id stub
 */

function isAssetIdStub(stub) {
  return isObject(stub) && typeof stub._id === 'string';
}
/**
 * Checks whether or not the given source is an asset path stub
 * (an object containing a `path` property)
 *
 * @param stub - Possible asset path stub
 * @returns Whether or not the passed object is an object path stub
 */

function isAssetPathStub(stub) {
  return isObject(stub) && typeof stub.path === 'string';
}
/**
 * Checks whether or not the given source is an asset URL stub
 * (an object containing a `url` property)
 *
 * @param stub - Possible asset url stub
 * @returns Whether or not the passed object is an object url stub
 */

function isAssetUrlStub(stub) {
  return isObject(stub) && typeof stub.url === 'string';
}
/**
 * Checks whether or not the given source is a (partial) sanity file asset document.
 * Only checks the `_type` property, all other properties _may_ be missing
 *
 * @param src - Source to check
 * @returns Whether or not the given source is a file asset
 */

function isSanityFileAsset(src) {
  return isObject(src) && src._type === 'sanity.fileAsset';
}
/**
 * Checks whether or not the given source is an asset object stub
 *
 * @param stub - Possible asset object stub
 * @returns Whether or not the passed object is an object stub
 */

function isAssetObjectStub(stub) {
  var item = stub;
  return isObject(item) && item.asset && typeof item.asset === 'object';
}
/**
 * Checks whether or not the passed object is an object (and not `null`)
 *
 * @param obj Item to check whether or not is an object
 * @returns Whether or not `obj` is an object
 * @internal
 */

function isObject(obj) {
  return obj !== null && !Array.isArray(obj) && typeof obj === 'object';
}

/**
 * Builds the base image path from the minimal set of parts required to assemble it
 *
 * @param asset - An asset-like shape defining ID, dimensions and extension
 * @param project - Project ID and dataset the image belongs to
 * @return string
 */

function buildImagePath(asset, project) {
  if (!project) {
    throw new Error('Project details (projectId and dataset) required to resolve path for image');
  }

  var projectId = project.projectId,
      dataset = project.dataset;
  var assetId = asset.assetId,
      extension = asset.extension,
      metadata = asset.metadata,
      originalFilename = asset.originalFilename,
      vanityFilename = asset.vanityFilename;
  var _metadata$dimensions = metadata.dimensions,
      width = _metadata$dimensions.width,
      height = _metadata$dimensions.height;
  var vanity = vanityFilename || originalFilename;
  vanity = vanity ? "/" + vanity : '';
  return "images/" + projectId + "/" + dataset + "/" + assetId + "-" + width + "x" + height + "." + extension + vanity;
}
/**
 * Builds the base image URL from the minimal set of parts required to assemble it
 *
 * @param asset - An asset-like shape defining ID, dimensions and extension
 * @param project - Project ID and dataset the image belongs to
 * @return string
 */

function buildImageUrl(asset, project) {
  return cdnUrl + "/" + buildImagePath(asset, project);
}
/**
 * Builds the base file path from the minimal set of parts required to assemble it
 *
 * @param asset - An asset-like shape defining ID, dimensions and extension
 * @param project - Project ID and dataset the file belongs to
 * @return string
 */

function buildFilePath(asset, project) {
  if (!project) {
    throw new Error('Project details (projectId and dataset) required to resolve path for file');
  }

  var projectId = project.projectId,
      dataset = project.dataset;
  var assetId = asset.assetId,
      extension = asset.extension,
      vanityFilename = asset.vanityFilename,
      originalFilename = asset.originalFilename;
  var vanity = vanityFilename || originalFilename;
  vanity = vanity ? "/" + vanity : '';
  return "files/" + projectId + "/" + dataset + "/" + assetId + "." + extension + vanity;
}
/**
 * Builds the base file URL from the minimal set of parts required to assemble it
 *
 * @param asset - An asset-like shape defining ID and extension
 * @param project - Project ID and dataset the file belongs to
 * @return string
 */

function buildFileUrl(asset, project) {
  return cdnUrl + "/" + buildFilePath(asset, project);
}
/**
 * Checks whether or not the given URL contains an asset path
 *
 * @param url - URL or path name
 * @returns Whether or not it contained an asset path
 */

function hasPath(urlOrPath) {
  return pathPattern.test(tryGetUrlPath(urlOrPath) || '');
}
/**
 * Tries to get the asset path from a given asset source
 *
 * @param src - The source image to infer an asset path from
 * @returns A path if resolvable, undefined otherwise
 */


function tryGetAssetPath(src) {
  if (isAssetObjectStub(src)) {
    return tryGetAssetPath(src.asset);
  }

  if (isReference(src)) {
    return undefined;
  }

  if (typeof src === 'string') {
    return hasPath(src) ? getUrlPath(src) : undefined;
  }

  if (isAssetPathStub(src)) {
    return src.path;
  }

  if (isAssetUrlStub(src)) {
    return getUrlPath(src.url);
  }

  return undefined;
}
/**
 * Strips the CDN URL and query params from a URL, eg:
 * `https://cdn.sanity.io/images/project/dataset/filename-200x200.jpg?foo=bar` =>
 * `images/project/dataset/filename-200x200.jpg`
 *
 * @param url - URL to get path name from
 * @returns The path of a CDN URL
 * @throws If URL is not a valid Sanity asset URL
 */

function getUrlPath(url) {
  if (pathPattern.test(url)) {
    // Already just a path
    return url;
  }

  if (!url.startsWith(cdnUrl + "/")) {
    throw new UnresolvableError("Failed to resolve path from URL \"" + url + "\"");
  }

  var qsPos = url.indexOf('?');
  var toIndex = qsPos === -1 ? undefined : qsPos;
  return url.slice(cdnUrl.length + 1, toIndex);
}
/**
 * See {@link getUrlPath}
 *
 * @inheritFrom {@link getUrlPath}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetUrlPath = /*#__PURE__*/getForgivingResolver(getUrlPath);
/**
 * Strips the CDN URL, path and query params from a URL, eg:
 * `https://cdn.sanity.io/images/project/dataset/filename-200x200.jpg?foo=bar` =>
 * `filename-200x200.jpg`
 *
 * @param url - URL to get filename from
 * @returns The filename of an URL, if URL matches the CDN URL
 * @throws If URL is not a valid Sanity asset URL
 */

function getUrlFilename(url) {
  var path = tryGetUrlPath(url) || url;
  var filename = path.replace(/^(images|files)\/[a-z0-9]+\/[a-z0-9][-\w]\/*/, '');

  if (!isValidFilename(filename)) {
    throw new UnresolvableError("Failed to resolve filename from URL \"" + url + "\"");
  }

  return filename;
}
/**
 * See {@link getUrlFilename}
 *
 * @inheritFrom {@link getUrlFilename}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetUrlFilename = /*#__PURE__*/getForgivingResolver(getUrlFilename);
/**
 * Checks whether or not a given filename matches the expected Sanity asset filename pattern
 *
 * @param filename - Filename to check for validity
 * @returns Whether or not the specified filename is valid
 */

function isValidFilename(filename) {
  return fileAssetFilenamePattern.test(filename) || imageAssetFilenamePattern.test(filename);
}

/**
 * @internal
 */

var exampleFileId = 'file-027401f31c3ac1e6d78c5d539ccd1beff72b9b11-pdf';
/**
 * @internal
 */

var exampleImageId = 'image-027401f31c3ac1e6d78c5d539ccd1beff72b9b11-2000x3000-jpg';
/**
 * Parses a Sanity asset document ID into individual parts (type, id, extension, width/height etc)
 *
 * @param documentId - Document ID to parse into named parts
 * @returns Object of named properties
 * @throws If document ID is invalid
 */

function parseAssetId(documentId) {
  if (imageAssetIdPattern.test(documentId)) {
    return parseImageAssetId(documentId);
  }

  if (fileAssetIdPattern.test(documentId)) {
    return parseFileAssetId(documentId);
  }

  throw new Error("Invalid image/file asset ID: " + documentId);
}
/**
 * Parses a Sanity file asset document ID into individual parts (type, id, extension)
 *
 * @param documentId - File asset document ID to parse into named parts
 * @returns Object of named properties
 * @throws If document ID invalid
 */

function parseFileAssetId(documentId) {
  if (!fileAssetIdPattern.test(documentId)) {
    throw new Error("Malformed file asset ID '" + documentId + "'. Expected an id like \"" + exampleFileId + "\"");
  }

  var _documentId$split = documentId.split('-'),
      assetId = _documentId$split[1],
      extension = _documentId$split[2];

  return {
    type: 'file',
    assetId: assetId,
    extension: extension
  };
}
/**
 * Parses a Sanity image asset document ID into individual parts (type, id, extension, width, height)
 *
 * @param documentId - Image asset document ID to parse into named parts
 * @returns Object of named properties
 * @throws If document ID invalid
 */

function parseImageAssetId(documentId) {
  var _documentId$split2 = documentId.split('-'),
      assetId = _documentId$split2[1],
      dimensionString = _documentId$split2[2],
      extension = _documentId$split2[3];

  var _split$map = (dimensionString || '').split('x').map(Number),
      width = _split$map[0],
      height = _split$map[1];

  if (!assetId || !dimensionString || !extension || !(width > 0) || !(height > 0)) {
    throw new Error("Malformed asset ID '" + documentId + "'. Expected an id like \"" + exampleImageId + "\".");
  }

  return {
    type: 'image',
    assetId: assetId,
    width: width,
    height: height,
    extension: extension
  };
}
/**
 * Parses a Sanity asset filename into individual parts (type, id, extension, width, height)
 *
 * @param filename - Filename to parse into named parts
 * @returns Object of named properties
 * @throws If image/filename is invalid
 */

function parseAssetFilename(filename) {
  var file = tryGetUrlFilename(filename) || '';

  if (!isValidFilename(file)) {
    throw new Error("Invalid image/file asset filename: " + filename);
  }

  try {
    var type = imageAssetFilenamePattern.test(file) ? 'image' : 'file';
    var assetId = file.replace(/\.([a-z0-9+]+)$/i, '-$1');
    return parseAssetId(type + "-" + assetId);
  } catch (err) {
    throw new Error("Invalid image/file asset filename: " + filename);
  }
}

/**
 * Returns the width, height and aspect ratio of a passed image asset, from any
 * inferrable structure (id, url, path, asset document, image object etc)
 *
 * @param src - Input source (image object, asset, reference, id, url, path)
 * @returns Object with width, height and aspect ratio properties
 *
 * @throws {@link UnresolvableError}
 * Throws if passed image source could not be resolved to an asset ID
 */

function getImageDimensions(src) {
  var imageId = getAssetDocumentId(src);

  var _parseImageAssetId = parseImageAssetId(imageId),
      width = _parseImageAssetId.width,
      height = _parseImageAssetId.height;

  var aspectRatio = width / height;
  return {
    width: width,
    height: height,
    aspectRatio: aspectRatio
  };
}
/**
 * See {@link getImageDimensions}
 *
 * @inheritFrom {@link getImageDimensions}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetImageDimensions = /*#__PURE__*/getForgivingResolver(getImageDimensions);
/**
 * Returns the file extension for a given asset
 *
 * @param src - Input source (file/image object, asset, reference, id, url, path)
 * @returns The file extension, if resolvable (no `.` included)
 *
 * @throws {@link UnresolvableError}
 * Throws if passed asset source could not be resolved to an asset ID
 */

function getExtension(src) {
  return isFileSource(src) ? getFile(src, dummyProject).asset.extension : getImage(src, dummyProject).asset.extension;
}
/**
 * See {@link getExtension}
 *
 * @inheritFrom {@link getExtension}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetExtension = /*#__PURE__*/getForgivingResolver(getExtension);
/**
 * Tries to resolve an image object with as much information as possible,
 * from any inferrable structure (id, url, path, image object etc)
 *
 * @param src - Input source (image object, asset, reference, id, url, path)
 * @param project Project ID and dataset the image belongs to
 * @returns Image object
 *
 * @throws {@link UnresolvableError}
 * Throws if passed image source could not be resolved to an asset ID
 */

function getImage(src, project) {
  var projectDetails = project || tryGetProject(src);
  var asset = getImageAsset(src, projectDetails);
  var img = src;
  return {
    asset: asset,
    crop: img.crop || getDefaultCrop(),
    hotspot: img.hotspot || getDefaultHotspot()
  };
}
/**
 * See {@link getImage}
 *
 * @inheritFrom {@link getImage}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetImage = /*#__PURE__*/getForgivingResolver(getImage);
/**
 * Tries to resolve a (partial) image asset document with as much information as possible,
 * from any inferrable structure (id, url, path, image object etc)
 *
 * @param src - Input source (image object, asset, reference, id, url, path)
 * @param project - Project ID and dataset the image belongs to
 * @returns Image asset document
 *
 * @throws {@link UnresolvableError}
 * Throws if passed image source could not be resolved to an asset ID
 */

function getImageAsset(src, project) {
  var projectDetails = project || getProject(src);

  var _id = getAssetDocumentId(src);

  var sourceObj = src;
  var source = sourceObj.asset || src;
  var metadata = source.metadata || {};

  var _parseImageAssetId2 = parseImageAssetId(_id),
      assetId = _parseImageAssetId2.assetId,
      width = _parseImageAssetId2.width,
      height = _parseImageAssetId2.height,
      extension = _parseImageAssetId2.extension;

  var aspectRatio = width / height;
  var baseAsset = {
    _id: _id,
    _type: 'sanity.imageAsset',
    assetId: assetId,
    extension: extension,
    metadata: _extends({}, metadata, {
      dimensions: {
        width: width,
        height: height,
        aspectRatio: aspectRatio
      }
    }),
    // Placeholders, overwritten below
    url: '',
    path: ''
  };
  return _extends({}, baseAsset, {
    path: buildImagePath(baseAsset, projectDetails),
    url: buildImageUrl(baseAsset, projectDetails)
  });
}
/**
 * See {@link getImageAsset}
 *
 * @inheritFrom {@link getImageAsset}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetImageAsset = /*#__PURE__*/getForgivingResolver(getImageAsset);
/**
 * Tries to resolve an file object with as much information as possible,
 * from any inferrable structure (id, url, path, file object etc)
 *
 * @param src - Input source (file object, asset, reference, id, url, path)
 * @param project Project ID and dataset the file belongs to
 * @returns File object
 *
 * @throws {@link UnresolvableError}
 * Throws if passed file source could not be resolved to an asset ID
 */

function getFile(src, project) {
  var projectDetails = project || tryGetProject(src);
  var asset = getFileAsset(src, projectDetails);
  return {
    asset: asset
  };
}
/**
 * See {@link getFile}
 *
 * @inheritFrom {@link getFile}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetFile = /*#__PURE__*/getForgivingResolver(getFile);
/**
 * Tries to resolve a (partial) file asset document with as much information as possible,
 * from any inferrable structure (id, url, path, file object etc)
 *
 * @param src - Input source (file object, asset, reference, id, url, path)
 * @param project - Project ID and dataset the file belongs to
 * @returns File asset document
 *
 * @throws {@link UnresolvableError}
 * Throws if passed file source could not be resolved to an asset ID
 */

function getFileAsset(src, project) {
  var projectDetails = project || getProject(src);

  var _id = getAssetDocumentId(src);

  var sourceObj = src;
  var source = sourceObj.asset || src;

  var _parseFileAssetId = parseFileAssetId(_id),
      assetId = _parseFileAssetId.assetId,
      extension = _parseFileAssetId.extension;

  var baseAsset = {
    _id: _id,
    _type: 'sanity.fileAsset',
    assetId: assetId,
    extension: extension,
    metadata: source.metadata || {},
    // Placeholders, overwritten below
    url: '',
    path: ''
  };
  return _extends({}, baseAsset, {
    path: buildFilePath(baseAsset, projectDetails),
    url: buildFileUrl(baseAsset, projectDetails)
  });
}
/**
 * See {@link getFileAsset}
 *
 * @inheritFrom {@link getFileAsset}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetFileAsset = /*#__PURE__*/getForgivingResolver(getFileAsset);
/**
 * Tries to resolve the asset document ID from any inferrable structure
 *
 * @param src - Input source (image/file object, asset, reference, id, url, path)
 * @returns The asset document ID
 *
 * @throws {@link UnresolvableError}
 * Throws if passed asset source could not be resolved to an asset document ID
 */

function getAssetDocumentId(src) {
  var source = isAssetObjectStub(src) ? src.asset : src;
  var id = '';

  if (typeof source === 'string') {
    id = getIdFromString(source);
  } else if (isReference(source)) {
    id = source._ref;
  } else if (isAssetIdStub(source)) {
    id = source._id;
  } else if (isAssetPathStub(source)) {
    id = idFromUrl(cdnUrl + "/" + source.path);
  } else if (isAssetUrlStub(source)) {
    id = idFromUrl(source.url);
  }

  var hasId = id && idPattern.test(id);

  if (!hasId) {
    throw new UnresolvableError(src);
  }

  return id;
}
/**
 * See {@link getAssetDocumentId}
 *
 * @inheritFrom {@link getAssetDocumentId}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetAssetDocumentId = /*#__PURE__*/getForgivingResolver(getAssetDocumentId);
/**
 * Tries to cooerce a string (ID, URL or path) to an image asset ID
 *
 * @param str - Input string (ID, URL or path)
 * @returns string
 *
 *
 * @throws {@link UnresolvableError}
 * Throws if passed image source could not be resolved to an asset ID
 */

function getIdFromString(str) {
  if (idPattern.test(str)) {
    // Already an ID
    return str;
  }

  if (str.indexOf(cdnUrl + "/images") === 0 || str.indexOf(cdnUrl + "/files") === 0) {
    // Full URL
    return idFromUrl(str);
  }

  if (pathPattern.test(str)) {
    // Path
    return idFromUrl(cdnUrl + "/" + str);
  }

  if (isFileAssetFilename(str)) {
    // Just a filename (projectId/dataset irrelevant: just need asset ID)
    return idFromUrl(cdnUrl + "/files/a/b/" + str);
  }

  if (isImageAssetFilename(str)) {
    // Just a filename (projectId/dataset irrelevant: just need asset ID)
    return idFromUrl(cdnUrl + "/images/a/b/" + str);
  }

  throw new UnresolvableError(str);
}
/**
 * See {@link getIdFromString}
 *
 * @inheritFrom {@link getIdFromString}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetIdFromString = /*#__PURE__*/getForgivingResolver(getIdFromString);
/**
 * Converts from a full asset URL to just the asset document ID
 *
 * @param url - A full asset URL to convert
 * @returns string
 */

function idFromUrl(url) {
  var path = getUrlPath(url);

  var _path$split = path.split('/'),
      type = _path$split[0],
      fileName = _path$split[3];

  var prefix = type.replace(/s$/, '');
  return prefix + "-" + fileName.replace(/\./g, '-');
}
/**
 * Resolves project ID and dataset the image belongs to, based on full URL or path
 * @param source - Image URL or path
 * @returns object | undefined
 *
 * @throws {@link UnresolvableError}
 * Throws if passed image source could not be resolved to an asset ID
 */


function getProject(src) {
  var path = tryGetAssetPath(src);

  if (!path) {
    throw new UnresolvableError(src, 'Failed to resolve project ID and dataset from source');
  }

  var _ref = path.match(pathPattern) || [],
      projectId = _ref[1],
      dataset = _ref[2];

  if (!projectId || !dataset) {
    throw new UnresolvableError(src, 'Failed to resolve project ID and dataset from source');
  }

  return {
    projectId: projectId,
    dataset: dataset
  };
}
/**
 * See {@link getProject}
 *
 * @inheritFrom {@link getProject}
 * @returns Returns `undefined` instead of throwing if a value cannot be resolved
 */

var tryGetProject = /*#__PURE__*/getForgivingResolver(getProject);
/**
 * Returns whether or not the passed filename is a valid image asset filename
 *
 * @param filename - Filename to validate
 * @returns Whether or not the filename is an image asset filename
 */

function isImageAssetFilename(filename) {
  return imageAssetFilenamePattern.test(filename);
}
/**
 * Returns whether or not the passed filename is a valid file asset filename
 *
 * @param filename - Filename to validate
 * @returns Whether or not the filename is a file asset filename
 */

function isFileAssetFilename(filename) {
  return fileAssetFilenamePattern.test(filename);
}
/**
 * Returns whether or not the passed filename is a valid file or image asset filename
 *
 * @param filename - Filename to validate
 * @returns Whether or not the filename is an asset filename
 */

function isAssetFilename(filename) {
  return isImageAssetFilename(filename) || isFileAssetFilename(filename);
}
/**
 * Return whether or not the passed source is a file source
 *
 * @param src - Source to check
 * @returns Whether or not the given source is a file source
 */

function isFileSource(src) {
  var assetId = getAssetDocumentId(src);
  return assetId.startsWith('file-');
}
/**
 * Return whether or not the passed source is an image source
 *
 * @param src - Source to check
 * @returns Whether or not the given source is an image source
 */

function isImageSource(src) {
  var assetId = getAssetDocumentId(src);
  return assetId.startsWith('image-');
}

exports.DEFAULT_CROP = DEFAULT_CROP;
exports.DEFAULT_HOTSPOT = DEFAULT_HOTSPOT;
exports.buildFilePath = buildFilePath;
exports.buildFileUrl = buildFileUrl;
exports.buildImagePath = buildImagePath;
exports.buildImageUrl = buildImageUrl;
exports.getAssetDocumentId = getAssetDocumentId;
exports.getDefaultCrop = getDefaultCrop;
exports.getDefaultHotspot = getDefaultHotspot;
exports.getExtension = getExtension;
exports.getFile = getFile;
exports.getFileAsset = getFileAsset;
exports.getIdFromString = getIdFromString;
exports.getImage = getImage;
exports.getImageAsset = getImageAsset;
exports.getImageDimensions = getImageDimensions;
exports.getProject = getProject;
exports.getUrlFilename = getUrlFilename;
exports.getUrlPath = getUrlPath;
exports.isAssetFilename = isAssetFilename;
exports.isAssetIdStub = isAssetIdStub;
exports.isAssetObjectStub = isAssetObjectStub;
exports.isAssetPathStub = isAssetPathStub;
exports.isAssetUrlStub = isAssetUrlStub;
exports.isDefaultCrop = isDefaultCrop;
exports.isDefaultHotspot = isDefaultHotspot;
exports.isFileAssetFilename = isFileAssetFilename;
exports.isFileSource = isFileSource;
exports.isImageAssetFilename = isImageAssetFilename;
exports.isImageSource = isImageSource;
exports.isObject = isObject;
exports.isReference = isReference;
exports.isSanityFileAsset = isSanityFileAsset;
exports.isValidFilename = isValidFilename;
exports.parseAssetFilename = parseAssetFilename;
exports.parseAssetId = parseAssetId;
exports.parseFileAssetId = parseFileAssetId;
exports.parseImageAssetId = parseImageAssetId;
exports.tryGetAssetDocumentId = tryGetAssetDocumentId;
exports.tryGetAssetPath = tryGetAssetPath;
exports.tryGetExtension = tryGetExtension;
exports.tryGetFile = tryGetFile;
exports.tryGetFileAsset = tryGetFileAsset;
exports.tryGetIdFromString = tryGetIdFromString;
exports.tryGetImage = tryGetImage;
exports.tryGetImageAsset = tryGetImageAsset;
exports.tryGetImageDimensions = tryGetImageDimensions;
exports.tryGetProject = tryGetProject;
exports.tryGetUrlFilename = tryGetUrlFilename;
exports.tryGetUrlPath = tryGetUrlPath;
//# sourceMappingURL=asset-utils.cjs.development.js.map
