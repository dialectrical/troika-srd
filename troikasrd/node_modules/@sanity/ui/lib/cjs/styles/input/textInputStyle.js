var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  textInputBaseStyle: () => textInputBaseStyle,
  textInputFontSizeStyle: () => textInputFontSizeStyle,
  textInputRepresentationStyle: () => textInputRepresentationStyle,
  textInputRootStyle: () => textInputRootStyle
});
var import_styled_components = __toModule(require("styled-components"));
var import_focusRing = __toModule(require("../focusRing"));
var import_helpers = __toModule(require("../helpers"));
const ROOT_STYLE = import_styled_components.css`
  &:not([hidden]) {
    display: flex;
  }
`;
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const { theme, $weight } = props;
  const font = theme.sanity.fonts.text;
  const color = theme.sanity.color.input;
  return import_styled_components.css`
    --input-fg-color: ${color.default.enabled.fg};
    --input-placeholder-color: ${color.default.enabled.placeholder};

    appearance: none;
    background: none;
    border: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.family};
    font-weight: ${$weight && font.weights[$weight] || font.weights.regular};
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;
    color: var(--input-fg-color);

    /* NOTE: This is a hack to disable Chromeâ€™s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    &::placeholder {
      color: var(--input-placeholder-color);
    }

    /* &:is(textarea) */
    &[data-as='textarea'] {
      resize: none;
    }

    /* enabled */
    &:not(:invalid):not(:disabled):not(:read-only) {
      --input-fg-color: ${color.default.enabled.fg};
      --input-placeholder-color: ${color.default.enabled.placeholder};
    }

    /* disabled */
    &:not(:invalid):disabled {
      --input-fg-color: ${color.default.disabled.fg};
      --input-placeholder-color: ${color.default.disabled.placeholder};
    }

    /* invalid */
    &:invalid {
      --input-fg-color: ${color.invalid.enabled.fg};
      --input-placeholder-color: ${color.invalid.enabled.placeholder};
    }

    /* readOnly */
    &:read-only {
      --input-fg-color: ${color.default.readOnly.fg};
      --input-placeholder-color: ${color.default.readOnly.placeholder};
    }
  `;
}
function textInputFontSizeStyle(props) {
  const { theme } = props;
  const { fonts, media } = theme.sanity;
  return (0, import_helpers.responsive)(media, (0, import_helpers.getResponsiveProp)(props.$fontSize, [2]), (sizeIndex) => {
    const size = fonts.text.sizes[sizeIndex] || fonts.text.sizes[2];
    return {
      fontSize: (0, import_helpers.rem)(size.fontSize),
      lineHeight: size.lineHeight / size.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const { $border, $hasPrefix, $hasSuffix, theme } = props;
  const { focusRing, input } = theme.sanity;
  const color = theme.sanity.color.input;
  return import_styled_components.css`
    --card-bg-color: ${color.default.enabled.bg};
    --card-fg-color: ${color.default.enabled.fg};
    --input-box-shadow: none;

    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: block;
    pointer-events: none;
    z-index: 0;
    background-color: var(--card-bg-color);
    box-shadow: var(--input-box-shadow);

    border-top-left-radius: ${$hasPrefix ? 0 : void 0};
    border-bottom-left-radius: ${$hasPrefix ? 0 : void 0};
    border-top-right-radius: ${$hasSuffix ? 0 : void 0};
    border-bottom-right-radius: ${$hasSuffix ? 0 : void 0};

    /* enabled */
    *:not(:disabled) + && {
      --input-box-shadow: ${$border ? (0, import_focusRing.focusRingBorderStyle)({ color: color.default.enabled.border, width: input.border.width }) : void 0};
    }

    /* invalid */
    *:not(:disabled):invalid + && {
      --card-bg-color: ${color.invalid.enabled.bg};
      --card-fg-color: ${color.invalid.enabled.fg};
      --input-box-shadow: ${$border ? (0, import_focusRing.focusRingBorderStyle)({ color: color.invalid.enabled.border, width: input.border.width }) : "none"};
    }

    /* focused */
    *:not(:disabled):focus + && {
      --input-box-shadow: ${(0, import_focusRing.focusRingStyle)({
    border: $border ? { color: color.default.enabled.border, width: input.border.width } : void 0,
    focusRing
  })};
    }

    /* disabled */
    *:disabled + && {
      --card-bg-color: ${color.default.disabled.bg};
      --card-fg-color: ${color.default.disabled.fg};
      --input-box-shadow: ${$border ? (0, import_focusRing.focusRingBorderStyle)({
    color: color.default.disabled.border,
    width: input.border.width
  }) : "none"};
    }

    /* hovered */
    @media (hover: hover) {
      *:not(:disabled):not(:read-only):not(:invalid):hover + && {
        --card-bg-color: ${color.default.hovered.bg};
        --card-fg-color: ${color.default.hovered.fg};
      }

      *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + && {
        --input-box-shadow: ${$border ? (0, import_focusRing.focusRingBorderStyle)({
    color: color.default.hovered.border,
    width: input.border.width
  }) : "none"};
      }
    }

    /* readOnly */
    *:read-only + && {
      --card-bg-color: ${color.default.readOnly.bg};
      --card-fg-color: ${color.default.readOnly.fg};
    }
  `;
}
