"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _zlib = _interopRequireDefault(require("zlib"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _tarFs = _interopRequireDefault(require("tar-fs"));

var _lazyRequire = _interopRequireDefault(require("@sanity/util/lib/lazyRequire"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _default = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (args, context) {
    var apiClient = context.apiClient,
        workDir = context.workDir,
        chalk = context.chalk,
        output = context.output,
        prompt = context.prompt;
    var flags = Object.assign({
      build: true
    }, args.extOptions);

    var sourceDir = _path.default.resolve(process.cwd(), args.argsWithoutOptions[0] || _path.default.join(workDir, 'dist'));

    if (args.argsWithoutOptions[0] === 'graphql') {
      throw new Error('Did you mean `sanity graphql deploy`?');
    } else if (args.argsWithoutOptions[0]) {
      var relativeOutput = _path.default.relative(process.cwd(), sourceDir);

      if (relativeOutput[0] !== '.') {
        relativeOutput = "./".concat(relativeOutput);
      }

      var isEmpty = yield dirIsEmptyOrNonExistent(sourceDir);
      var shouldProceed = isEmpty || (yield prompt.single({
        type: 'confirm',
        message: "\"".concat(relativeOutput, "\" is not empty, do you want to proceed?"),
        default: false
      }));

      if (!shouldProceed) {
        output.print('Cancelled.');
        return;
      }

      output.print("Building to ".concat(relativeOutput, "\n"));
    }

    var client = apiClient({
      requireUser: true,
      requireProject: true
    }); // Check that the project has a studio hostname

    var spinner = output.spinner('Checking project info').start();
    var project = yield client.projects.getById(client.config().projectId);
    var studioHostname = project && (project.studioHostname || project.studioHost);
    spinner.succeed();

    if (!studioHostname) {
      output.print('Your project has not been assigned a studio hostname.');
      output.print('To deploy your Sanity Studio to our hosted Sanity.Studio service,');
      output.print('you will need one. Please enter the part you want to use.');
      studioHostname = yield prompt.single({
        type: 'input',
        filter: inp => inp.replace(/\.sanity\.studio$/i, ''),
        message: 'Studio hostname (<value>.sanity.studio):',
        validate: name => validateHostname(name, client)
      });
    } // Always build the project, unless --no-build is passed


    var shouldBuild = flags.build;

    if (shouldBuild) {
      var overrides = {
        project: {
          basePath: undefined
        }
      };
      var buildStaticAssets = (0, _lazyRequire.default)(require.resolve('../build/buildStaticAssets'));
      var buildArgs = [args.argsWithoutOptions[0]].filter(Boolean);
      yield buildStaticAssets({
        extOptions: flags,
        argsWithoutOptions: buildArgs,
        overrides
      }, context);
    } // Ensure that the directory exists, is a directory and seems to have valid content


    spinner = output.spinner('Verifying local content').start();

    try {
      yield checkDir(sourceDir);
      spinner.succeed();
    } catch (err) {
      spinner.fail();
      throw err;
    } // Now create a tarball of the given directory


    var parentDir = _path.default.dirname(sourceDir);

    var base = _path.default.basename(sourceDir);

    var tarball = _tarFs.default.pack(parentDir, {
      entries: [base]
    }).pipe(_zlib.default.createGzip());

    spinner = output.spinner('Deploying to Sanity.Studio').start();

    try {
      var response = yield client.request({
        method: 'POST',
        url: '/deploy',
        body: tarball,
        maxRedirects: 0
      });
      spinner.succeed(); // And let the user know we're done

      output.print("\nSuccess! Studio deployed to ".concat(chalk.cyan(response.location)));
    } catch (err) {
      spinner.fail();
      throw err;
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.default = _default;

function dirIsEmptyOrNonExistent(_x3) {
  return _dirIsEmptyOrNonExistent.apply(this, arguments);
}

function _dirIsEmptyOrNonExistent() {
  _dirIsEmptyOrNonExistent = _asyncToGenerator(function* (sourceDir) {
    try {
      var stats = yield _fsExtra.default.stat(sourceDir);

      if (!stats.isDirectory()) {
        throw new Error("Directory ".concat(sourceDir, " is not a directory"));
      }
    } catch (err) {
      if (err.code === 'ENOENT') {
        return true;
      }

      throw err;
    }

    var content = yield _fsExtra.default.readdir(sourceDir);
    return content.length === 0;
  });
  return _dirIsEmptyOrNonExistent.apply(this, arguments);
}

function checkDir(_x4) {
  return _checkDir.apply(this, arguments);
}

function _checkDir() {
  _checkDir = _asyncToGenerator(function* (sourceDir) {
    try {
      var stats = yield _fsExtra.default.stat(sourceDir);

      if (!stats.isDirectory()) {
        throw new Error("Directory ".concat(sourceDir, " is not a directory"));
      }
    } catch (err) {
      var error = err.code === 'ENOENT' ? new Error("Directory \"".concat(sourceDir, "\" does not exist")) : err;
      throw error;
    }

    try {
      yield _fsExtra.default.stat(_path.default.join(sourceDir, 'index.html'));
    } catch (err) {
      var _error = err.code === 'ENOENT' ? new Error(["\"".concat(sourceDir, "/index.html\" does not exist -"), '[SOURCE_DIR] must be a directory containing', 'a Sanity studio built using "sanity build"'].join(' ')) : err;

      throw _error;
    }
  });
  return _checkDir.apply(this, arguments);
}

function validateHostname(value, client) {
  var projectId = client.config().projectId;
  var uri = "/projects/".concat(projectId);
  var studioHost = value || ''; // Check that it matches allowed character range

  if (!/^[a-z0-9_-]+$/i.test(studioHost)) {
    return 'Hostname can contain only A-Z, 0-9, _ and -';
  } // Check that the hostname is not already taken


  return client.request({
    uri,
    method: 'PATCH',
    body: {
      studioHost
    }
  }).then(() => true).catch(() => 'Hostname already taken');
}