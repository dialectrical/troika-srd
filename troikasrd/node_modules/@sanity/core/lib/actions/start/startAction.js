"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _es6Promisify = require("es6-promisify");

var _server = require("@sanity/server");

var _getConfig = _interopRequireDefault(require("@sanity/util/lib/getConfig"));

var _chooseDatasetPrompt = _interopRequireDefault(require("../dataset/chooseDatasetPrompt"));

var _reinitializePluginConfigs = require("../../actions/config/reinitializePluginConfigs");

var _checkStudioDependencyVersions = _interopRequireDefault(require("../../util/checkStudioDependencyVersions"));

var _debug = _interopRequireDefault(require("../../debug"));

var _formatMessage = require("./formatMessage");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _default = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (args, context) {
    var flags = args.extOptions;
    var output = context.output,
        workDir = context.workDir;
    yield ensureProjectConfig(context);
    var sanityConfig = (0, _getConfig.default)(workDir);
    var config = sanityConfig.get('server');
    var port = config.port,
        hostname = config.hostname;
    var httpHost = flags.host === 'all' ? '0.0.0.0' : flags.host || hostname;
    var httpPort = flags.port || port;
    var serverOptions = {
      staticPath: resolveStaticPath(workDir, config),
      basePath: workDir,
      httpHost,
      httpPort,
      context,
      project: sanityConfig.get('project')
    };
    (0, _checkStudioDependencyVersions.default)(workDir);
    var compileSpinner;
    var configSpinner = output.spinner('Checking configuration files...');
    yield (0, _reinitializePluginConfigs.tryInitializePluginConfigs)({
      workDir,
      output,
      env: 'development'
    });
    configSpinner.succeed();
    var server = (0, _server.getDevServer)(serverOptions);
    var compiler = server.locals.compiler; // "invalid" doesn't mean the bundle is invalid, but that it is *invalidated*,
    // in other words, it's recompiling

    compiler.plugin('invalid', () => {
      output.clear();
      resetSpinner();
    }); // Start the server and try to create more user-friendly errors if we encounter issues

    try {
      yield (0, _es6Promisify.promisify)(server.listen.bind(server))(httpPort, httpHost);
    } catch (err) {
      gracefulDeath(httpHost, config, err);
    } // Hold off on showing the spinner until compilation has started


    compiler.plugin('compile', () => resetSpinner()); // "done" event fires when Webpack has finished recompiling the bundle.
    // Whether or not you have warnings or errors, you will get this event.

    compiler.plugin('done', stats => {
      if (compileSpinner) {
        compileSpinner.succeed();
      }

      var hasErrors = stats.hasErrors();
      var hasWarnings = stats.hasWarnings();

      if (!hasErrors && !hasWarnings) {
        output.print(_chalk.default.green("Content Studio successfully compiled! Go to http://".concat(httpHost, ":").concat(httpPort)) // eslint-disable-line max-len
        );
        return;
      }

      var _stats$toJson = stats.toJson({}, true),
          errors = _stats$toJson.errors,
          warnings = _stats$toJson.warnings;

      if (hasErrors) {
        printErrors(output, errors);
        return; // If errors exist, ignore warnings.
      }

      if (hasWarnings) {
        printWarnings(output, warnings);
      }

      output.print(_chalk.default.green("Content Studio listening on http://".concat(httpHost, ":").concat(httpPort)));
    });

    function resetSpinner() {
      if (compileSpinner) {
        compileSpinner.stop();
      }

      compileSpinner = output.spinner('Compiling...').start();
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.default = _default;

function ensureProjectConfig(_x3) {
  return _ensureProjectConfig.apply(this, arguments);
}

function _ensureProjectConfig() {
  _ensureProjectConfig = _asyncToGenerator(function* (context) {
    var workDir = context.workDir,
        output = context.output;

    var manifestPath = _path.default.join(workDir, 'sanity.json');

    var projectManifest = yield _fsExtra.default.readJson(manifestPath);
    var apiConfig = projectManifest.api || {};

    if (!(0, _isPlainObject2.default)(apiConfig)) {
      throw new Error('Invalid `api` property in `sanity.json` - should be an object');
    } // The API client wrapper extracts information from environment variables,
    // which means it could potentially hold any missing project ID / dataset


    var _context$apiClient$co = context.apiClient({
      requireProject: false,
      requireUser: false
    }).config(),
        projectId = _context$apiClient$co.projectId,
        dataset = _context$apiClient$co.dataset; // The client wrapper returns `~dummy-placeholder-dataset-` in the case where
    // no dataset is configured, to be able to do non-dataset requests without
    // having the client complain. We don't want to use this as an _actual_ value.


    dataset = dataset === '~dummy-placeholder-dataset-' ? undefined : dataset; // Let the user know why these values are being used

    if (projectId && projectId !== apiConfig.projectId) {
      output.print("Using project ID from environment config (".concat(projectId, ")"));
    }

    if (dataset && dataset !== apiConfig.dataset) {
      output.print("Using dataset from environment config (".concat(dataset, ")"));
    } // If we're still missing information, prompt the user to provide them


    var configMissing = !projectId || !dataset;

    if (!configMissing) {
      validateAllowedDataset(dataset);
      return;
    }

    output.print('Project configuration required before starting studio');
    output.print('');
    var displayName = (0, _get2.default)(projectManifest, 'project.displayName');

    if (!projectId) {
      var selected = yield getOrCreateProject(context);
      projectId = selected.projectId;
      displayName = selected.displayName;
    }

    if (!dataset) {
      var client = context.apiClient({
        requireUser: true,
        requireProject: false
      }).config({
        projectId,
        useProjectHostname: true
      });

      var apiClient = () => client;

      var projectContext = _objectSpread(_objectSpread({}, context), {}, {
        apiClient
      });

      dataset = yield (0, _chooseDatasetPrompt.default)(projectContext, {
        allowCreation: true
      });
    } // Rewrite project manifest (sanity.json)


    var projectInfo = projectManifest.project || {};
    var newProps = {
      root: true,
      api: _objectSpread(_objectSpread({}, apiConfig), {}, {
        projectId,
        dataset
      }),
      project: _objectSpread(_objectSpread({}, projectInfo), {}, {
        // Keep original name if present
        name: projectInfo.name || displayName
      })
    };
    yield _fsExtra.default.outputJSON(manifestPath, _objectSpread(_objectSpread(_objectSpread({}, newProps), projectManifest), newProps), {
      spaces: 2
    });
    output.print("Project ID + dataset written to \"".concat(manifestPath, "\""));
  });
  return _ensureProjectConfig.apply(this, arguments);
}

function resolveStaticPath(rootDir, config) {
  var staticPath = config.staticPath;
  return _path.default.isAbsolute(staticPath) ? staticPath : _path.default.resolve(_path.default.join(rootDir, staticPath));
}

function gracefulDeath(httpHost, config, err) {
  if (err.code === 'EADDRINUSE') {
    throw new Error('Port number is already in use, configure `server.port` in `sanity.json`');
  }

  if (err.code === 'EACCES') {
    var help = config.port < 1024 ? 'port numbers below 1024 requires root privileges' : "do you have access to listen to the given host (".concat(httpHost, ")?");
    throw new Error("The Content Studio server does not have access to listen to given port - ".concat(help)); // eslint-disable-line max-len
  }

  throw err;
}

function printErrors(output, errors) {
  output.print(_chalk.default.red('Failed to compile.'));
  output.print('');
  var formattedErrors = (errors.some(_formatMessage.isLikelyASyntaxError) ? errors.filter(_formatMessage.isLikelyASyntaxError) : errors).map(message => "Error in ".concat((0, _formatMessage.formatMessage)(message)));
  formattedErrors.forEach(message => {
    output.print(message);
    output.print('');
  });
}

function printWarnings(output, warnings) {
  output.print(_chalk.default.yellow('Compiled with warnings.'));
  output.print();
  warnings.map(message => "Warning in ".concat((0, _formatMessage.formatMessage)(message))).forEach(message => {
    output.print(message);
    output.print();
  });
}

function getOrCreateProject(_x4) {
  return _getOrCreateProject.apply(this, arguments);
}

function _getOrCreateProject() {
  _getOrCreateProject = _asyncToGenerator(function* (context) {
    var prompt = context.prompt,
        apiClient = context.apiClient;
    var projects;

    try {
      projects = yield apiClient({
        requireProject: false
      }).projects.list();
    } catch (err) {
      throw new Error("Failed to communicate with the Sanity API:\n".concat(err.message));
    }

    if (projects.length === 0) {
      (0, _debug.default)('No projects found for user, prompting for name');
      var projectName = yield prompt.single({
        message: 'Project name'
      });
      return createProject(apiClient, {
        displayName: projectName
      });
    }

    (0, _debug.default)("User has ".concat(projects.length, " project(s) already, showing list of choices"));
    var projectChoices = projects.map(project => ({
      value: project.id,
      name: "".concat(project.displayName, " [").concat(project.id, "]")
    }));
    var selected = yield prompt.single({
      message: 'Select project to use',
      type: 'list',
      choices: [{
        value: 'new',
        name: 'Create new project'
      }, new prompt.Separator(), ...projectChoices]
    });

    if (selected === 'new') {
      (0, _debug.default)('User wants to create a new project, prompting for name');
      return createProject(apiClient, {
        displayName: yield prompt.single({
          message: 'Informal name for your project'
        })
      });
    }

    (0, _debug.default)("Returning selected project (".concat(selected, ")"));
    return {
      projectId: selected,
      displayName: projects.find(proj => proj.id === selected).displayName
    };
  });
  return _getOrCreateProject.apply(this, arguments);
}

function createProject(apiClient, options) {
  return apiClient({
    requireUser: true,
    requireProject: false
  }).request({
    method: 'POST',
    uri: '/projects',
    body: options
  }).then(response => ({
    projectId: response.projectId || response.id,
    displayName: options.displayName || ''
  }));
}

function validateAllowedDataset(datasetName) {
  if (datasetName.startsWith('~')) {
    throw new Error('Dataset aliases cannot be used in a studio context');
  }
}