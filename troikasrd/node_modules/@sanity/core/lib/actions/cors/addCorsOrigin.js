"use strict";

var _templateObject, _templateObject2, _templateObject3, _templateObject4;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var url = require('url');

var logSymbols = require('log-symbols');

var oneline = require('oneline');

var wildcardReplacement = 'a-wild-card-r3pl4c3m3n7-a';
var portReplacement = ':7777777';

module.exports = /*#__PURE__*/function () {
  var _addCorsOrigin = _asyncToGenerator(function* (givenOrigin, flags, context) {
    var apiClient = context.apiClient,
        prompt = context.prompt,
        output = context.output;
    var origin = yield givenOrigin ? filterAndValidateOrigin(givenOrigin) : promptForOrigin(prompt);
    var hasWildcard = origin.includes('*');

    if (hasWildcard && !(yield promptForWildcardConfirmation(origin, context))) {
      return false;
    }

    var allowCredentials = typeof flags.credentials === 'undefined' ? yield promptForCredentials(hasWildcard, context) : Boolean(flags.credentials);

    if (givenOrigin !== origin) {
      output.print("Normalized origin to ".concat(origin));
    }

    var client = apiClient({
      requireUser: true,
      requireProject: true
    });
    return client.request({
      method: 'POST',
      url: '/cors',
      body: {
        origin,
        allowCredentials
      },
      maxRedirects: 0
    });
  });

  function addCorsOrigin(_x, _x2, _x3) {
    return _addCorsOrigin.apply(this, arguments);
  }

  return addCorsOrigin;
}();

function promptForCredentials(hasWildcard, context) {
  var prompt = context.prompt,
      output = context.output,
      chalk = context.chalk;
  output.print('');

  if (hasWildcard) {
    output.print(oneline(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      ", "\n      We ", " recommend NOT allowing credentials\n      on origins containing wildcards. If you are logged in to a studio, people will\n      be able to send requests ", " to read and modify\n      data, from any matching origin. Please tread carefully!\n    "])), chalk.yellow("".concat(logSymbols.warning, " Warning:")), chalk.red(chalk.underline('HIGHLY')), chalk.underline('on your behalf')));
  } else {
    output.print(oneline(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n      ", "\n      Should this origin be allowed to send requests using authentication tokens or\n      session cookies? Be aware that any script on this origin will be able to send\n      requests ", " to read and modify data if you\n      are logged in to a Sanity studio. If this origin hosts a studio, you will need\n      this, otherwise you should probably answer \"No\" (n).\n    "])), chalk.yellow("".concat(logSymbols.warning, " Warning:")), chalk.underline('on your behalf')));
  }

  output.print('');
  return prompt.single({
    type: 'confirm',
    message: oneline(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n      Allow credentials to be sent from this origin? Please read the warning above.\n    "]))),
    default: false
  });
}

function promptForWildcardConfirmation(origin, context) {
  var prompt = context.prompt,
      output = context.output,
      chalk = context.chalk;
  output.print('');
  output.print(chalk.yellow("".concat(logSymbols.warning, " Warning: Examples of allowed origins:")));

  if (origin === '*') {
    output.print('- http://www.some-malicious.site');
    output.print('- https://not.what-you-were-expecting.com');
    output.print('- https://high-traffic-site.com');
    output.print('- http://192.168.1.1:8080');
  } else {
    output.print("- ".concat(origin.replace(/:\*/, ':1234').replace(/\*/g, 'foo')));
    output.print("- ".concat(origin.replace(/:\*/, ':3030').replace(/\*/g, 'foo.bar')));
  }

  output.print('');
  return prompt.single({
    type: 'confirm',
    message: oneline(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n      Using wildcards can be ", ".\n      Are you ", " you want to allow this origin?"])), chalk.red('risky'), chalk.underline('absolutely sure')),
    default: false
  });
}

function promptForOrigin(prompt) {
  return prompt.single({
    type: 'input',
    message: 'Origin (including protocol):',
    filter: filterOrigin,
    validate: validateOrigin
  });
}

function filterOrigin(origin) {
  if (origin === '*' || origin === 'file:///*') {
    return origin;
  }

  try {
    var example = origin.replace(/([^:])\*/g, "$1".concat(wildcardReplacement)).replace(/:\*/, portReplacement);
    var parsed = url.parse(example);
    var host = parsed.host;

    if (/^https?:$/.test(parsed.protocol || '')) {
      host = parsed.host.replace(/:(80|443)$/, '');
    }

    host = host.replace(portReplacement, ':*').replace(new RegExp(wildcardReplacement, 'g'), '*');
    return "".concat(parsed.protocol, "//").concat(host);
  } catch (err) {
    return null;
  }
}

function validateOrigin(origin, givenOrigin) {
  if (origin === '*' || origin === 'file:///*') {
    return true;
  }

  try {
    url.parse(origin || 0); // Use 0 to trigger error for unset values

    return true;
  } catch (err) {// Fall-through to error
  }

  if (/^file:\/\//.test(givenOrigin)) {
    return "Only a local file wildcard is currently allowed: file:///*";
  }

  return "Invalid origin \"".concat(givenOrigin, "\", must include protocol (https://some.host)");
}

function filterAndValidateOrigin(givenOrigin) {
  var origin = filterOrigin(givenOrigin);
  var result = validateOrigin(origin, givenOrigin);

  if (result !== true) {
    throw new Error(result);
  }

  return origin;
}