"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var spawn = require('child_process').spawn;

var path = require('path');

var fse = require('fs-extra');

var yargs = require('yargs/yargs');

var _require = require('yargs/helpers'),
    hideBin = _require.hideBin;

function parseCliFlags(args) {
  return yargs(hideBin(args.argv || process.argv)).command('exec [script]', 'executes given script', cmd => cmd.positional('script', {
    type: 'string',
    demandOption: true
  }).option('with-user-token', {
    type: 'boolean',
    default: false
  }).option('mock-browser-env', {
    type: 'boolean',
    default: false
  })).argv;
}

module.exports = /*#__PURE__*/function () {
  var _execScript = _asyncToGenerator(function* (args, context) {
    // Reparsing CLI flags for better control of binary flags
    var _parseCliFlags = parseCliFlags(args),
        withUserToken = _parseCliFlags.withUserToken,
        mockBrowserEnv = _parseCliFlags.mockBrowserEnv,
        script = _parseCliFlags.script;

    var workDir = context.workDir;
    var scriptPath = path.resolve(script || '');

    if (!script) {
      throw new Error('SCRIPT must be provided. `sanity exec <script>`');
    }

    if (!(yield fse.exists(scriptPath))) {
      throw new Error("".concat(scriptPath, " does not exist"));
    }

    var babel = require.resolve('./babel');

    var loader = require.resolve('./pluginLoader');

    var requireContextPath = require.resolve('./requireContext');

    var browserEnvPath = require.resolve('./registerBrowserEnv');

    var configClientPath = require.resolve('./configClient');

    var baseArgs = mockBrowserEnv ? ['-r', browserEnvPath] : ['-r', babel, '-r', loader, '-r', requireContextPath];
    var nodeArgs = baseArgs.concat(withUserToken ? ['-r', configClientPath] : []).concat(scriptPath).concat(args.extraArguments || []);
    var proc = spawn(process.argv[0], nodeArgs, {
      stdio: 'inherit',
      env: _objectSpread(_objectSpread({}, process.env), {}, {
        SANITY_BASE_PATH: workDir
      })
    });
    proc.on('close', process.exit);
  });

  function execScript(_x, _x2) {
    return _execScript.apply(this, arguments);
  }

  return execScript;
}();