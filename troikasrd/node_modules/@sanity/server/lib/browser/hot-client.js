"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-env browser */

/* eslint-disable complexity, no-console, camelcase, no-case-declarations, max-depth */
var strip = require('strip-ansi');

var clientOverlay = require('webpack-hot-middleware/client-overlay');

var processUpdate = require('./process-update');

var polyfilledEventSource = require('@sanity/eventsource');

var TIMEOUT = 20 * 1000;
var RECONNECT_TIMEOUT = 2500;
var HEARTBEAT = '\uD83D\uDC93';
var HMR_PATH = '/__webpack_hmr';
var REPORTER_KEY = '__webpack_hot_middleware_reporter__';
var EVENTBUS_KEY = '__webpack_hot_middleware_eventbus__';
var EVENT_CONNECTED = 'connected';
var EVENT_CONNECTING = 'connecting';
var EVENT_DISCONNECTED = 'disconnected';
var EVENT_BUILDING = 'building';
var EVENT_BUILT = 'built';
var EVENT_SYNC = 'sync';
var EVENT_CHECKING_FOR_UPDATES = 'checking-for-updates';
var EVENT_NOTHING_UPDATED = 'nothing-updated';
var EVENT_APPLY_ERROR = 'apply-error';
var EVENT_UNACCEPTED = 'unaccepted';
var EVENT_UPDATE_CHECK_FAILED = 'update-check-failed';
var EVENT_UPDATED = 'updated';
var EVENT_UPDATE_NOT_FOUND = 'update-not-found';
var EVENT_UP_TO_DATE = 'up-to-date';
var REQUIRES_RELOAD = [EVENT_UPDATE_NOT_FOUND, EVENT_UNACCEPTED, EVENT_APPLY_ERROR, EVENT_UPDATE_CHECK_FAILED];
var REPORTER_STYLES = {
  errors: 'color: #ff0000;',
  warnings: 'color: #999933;'
};

(function hotMiddlewareClient() {
  if (typeof window === 'undefined') {
    // Do nothing if not in a browser context
    return;
  }

  var es;
  var _isConnected = false;
  var lastActivity = new Date();
  var timeoutCheckTimer;
  window[EVENTBUS_KEY] = window[EVENTBUS_KEY] || createEventBus({
    isConnected: () => _isConnected
  });
  window[REPORTER_KEY] = window[REPORTER_KEY] || createReporter();
  var reporter = window[REPORTER_KEY];
  var eventBus = window[EVENTBUS_KEY];

  var getEventPublisher = type => function () {
    var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    eventBus.publish(_objectSpread(_objectSpread({}, evt), {}, {
      type,
      requiresReload: REQUIRES_RELOAD.includes(type)
    }));
  };

  var hmrHandlers = {
    handleCheckUpdate: getEventPublisher(EVENT_CHECKING_FOR_UPDATES),
    handleError: getEventPublisher(EVENT_APPLY_ERROR),
    handleNothingUpdated: getEventPublisher(EVENT_NOTHING_UPDATED),
    handleUnaccepted: getEventPublisher(EVENT_UNACCEPTED),
    handleUpdateCheckFailed: getEventPublisher(EVENT_UPDATE_CHECK_FAILED),
    handleUpdated: getEventPublisher(EVENT_UPDATED),
    handleUpdateNotFound: getEventPublisher(EVENT_UPDATE_NOT_FOUND),
    handleUpToDate: getEventPublisher(EVENT_UP_TO_DATE)
  };
  connect();

  function connect() {
    eventBus.publish({
      type: EVENT_CONNECTING
    });
    var EventSource = window.EventSource || polyfilledEventSource;
    es = new EventSource(HMR_PATH);
    es.onopen = handleOnline;
    es.onerror = handleDisconnect;
    es.onmessage = handleMessage;
    timeoutCheckTimer = setInterval(handleCheckTimeout, TIMEOUT / 2);
  }

  function handleOnline() {
    console.log('[HMR] connected');
    eventBus.publish({
      type: EVENT_CONNECTED
    });
    lastActivity = new Date();
    _isConnected = true;
  }

  function handleMessage(event) {
    lastActivity = new Date();

    if (event.data === HEARTBEAT) {
      return;
    }

    processMessage(parseMessage(event));
  }

  function handleCheckTimeout() {
    if (new Date() - lastActivity > TIMEOUT) {
      handleDisconnect();
    }
  }

  function handleDisconnect() {
    clearInterval(timeoutCheckTimer);
    es.close();
    _isConnected = false;
    eventBus.publish({
      type: EVENT_DISCONNECTED
    });
    setTimeout(connect, RECONNECT_TIMEOUT);
  }

  function parseMessage(event) {
    try {
      return JSON.parse(event.data);
    } catch (ex) {
      console.warn("Invalid HMR message: ".concat(event.data, "\n").concat(ex));
    }

    return false;
  }

  function processMessage(evt) {
    if (!evt) {
      return;
    }

    eventBus.publish(_objectSpread(_objectSpread({}, evt), {}, {
      type: evt.action
    }));

    switch (evt.action) {
      case EVENT_BUILDING:
        console.log("[HMR] bundle rebuilding");
        break;

      case EVENT_BUILT:
        console.log("[HMR] bundle rebuilt in ".concat(evt.time, " ms"));
      // fall through

      case EVENT_SYNC:
        var applyUpdate = true;
        var hasWarnings = evt.warnings.length > 0;
        var hasErrors = evt.errors.length > 0;

        if (hasErrors) {
          reporter.problems('errors', evt);
          applyUpdate = false;
        } else if (hasWarnings) {
          var overlayShown = reporter.problems('warnings', evt);
          applyUpdate = overlayShown;
        } else if (!hasWarnings) {
          reporter.cleanProblemsCache();
          reporter.success();
        }

        if (applyUpdate) {
          processUpdate(evt.hash, evt.modules, hmrHandlers);
        }

        break;

      default:
    }
  }
})();

function createReporter() {
  var overlay = clientOverlay({
    ansiColors: {},
    overlayStyles: {}
  });

  function formatProblems(type, obj) {
    return obj[type].map(msg => strip(msg)).join('\n');
  }

  var previousProblems = null;

  function log(type, obj) {
    var newProblems = formatProblems(type, obj);

    if (previousProblems === newProblems) {
      return;
    }

    previousProblems = newProblems;
    var style = REPORTER_STYLES[type];
    var title = "[HMR] bundle has ".concat(obj[type].length, " ").concat(type); // NOTE: console.warn or console.error will print the stack trace
    // which isn't helpful here, so using console.log to escape it.

    if (console.group && console.groupEnd) {
      console.group("%c".concat(title), style);
      console.log("%c".concat(newProblems), style);
      console.groupEnd();
    } else {
      console.log("%c".concat(title, "\n\t%c").concat(newProblems.replace(/\n/g, '\n\t')), "".concat(style, "font-aweight: bold;"), "".concat(style, "font-weight: normal;"));
    }
  }

  return {
    cleanProblemsCache() {
      previousProblems = null;
    },

    problems(type, obj) {
      log(type, obj);

      if (overlay) {
        if (type === 'errors') {
          overlay.showProblems(type, obj[type]);
          return false;
        }

        overlay.clear();
      }

      return true;
    },

    success() {
      if (overlay) {
        overlay.clear();
      }
    }

  };
}

function createEventBus(_ref) {
  var isConnected = _ref.isConnected;
  var listeners = [];
  return {
    publish: msg => listeners.forEach(listener => listener(msg)),
    subscribe: fn => {
      listeners.push(fn);

      if (isConnected()) {
        fn({
          type: EVENT_CONNECTED
        });
      }

      return () => listeners.splice(listeners.indexOf(fn), 1);
    },
    eventTypes: {
      EVENT_CONNECTED,
      EVENT_CONNECTING,
      EVENT_DISCONNECTED,
      EVENT_BUILDING,
      EVENT_BUILT,
      EVENT_SYNC,
      EVENT_CHECKING_FOR_UPDATES,
      EVENT_NOTHING_UPDATED,
      EVENT_APPLY_ERROR,
      EVENT_UNACCEPTED,
      EVENT_UPDATE_CHECK_FAILED,
      EVENT_UPDATED,
      EVENT_UPDATE_NOT_FOUND,
      EVENT_UP_TO_DATE
    }
  };
}