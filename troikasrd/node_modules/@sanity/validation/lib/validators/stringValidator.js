"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _genericValidator = _interopRequireDefault(require("./genericValidator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DUMMY_ORIGIN = 'http://sanity';
var emailRegex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

var isRelativeUrl = url => /^\.*\//.test(url);

var stringValidators = _objectSpread(_objectSpread({}, _genericValidator.default), {}, {
  min: (minLength, value, message) => {
    if (!value || value.length >= minLength) {
      return true;
    }

    return message || "Must be at least ".concat(minLength, " characters long");
  },
  max: (maxLength, value, message) => {
    if (!value || value.length <= maxLength) {
      return true;
    }

    return message || "Must be at most ".concat(maxLength, " characters long");
  },
  length: (wantedLength, value, message) => {
    var strValue = value || '';

    if (strValue.length === wantedLength) {
      return true;
    }

    return message || "Must be exactly ".concat(wantedLength, " characters long");
  },
  uri: (constraints, value, message) => {
    var strValue = value || '';
    var options = constraints.options;
    var allowCredentials = options.allowCredentials,
        relativeOnly = options.relativeOnly;
    var allowRelative = options.allowRelative || relativeOnly;
    var url;

    try {
      // WARNING: Safari checks for a given `base` param by looking at the length of arguments passed
      // to new URL(str, base), and will fail if invoked with new URL(strValue, undefined)
      url = allowRelative ? new URL(strValue, DUMMY_ORIGIN) : new URL(strValue);
    } catch (err) {
      return message || 'Not a valid URL';
    }

    if (relativeOnly && url.origin !== DUMMY_ORIGIN) {
      return message || 'Only relative URLs are allowed';
    }

    if (!allowRelative && url.origin === DUMMY_ORIGIN && isRelativeUrl(strValue)) {
      return message || 'Relative URLs are not allowed';
    }

    if (!allowCredentials && (url.username || url.password)) {
      return message || "Username/password not allowed";
    }

    var urlScheme = url.protocol.replace(/:$/, '');
    var matchesAllowedScheme = options.scheme.some(scheme => scheme.test(urlScheme));

    if (!matchesAllowedScheme) {
      return message || 'Does not match allowed protocols/schemes';
    }

    return true;
  },
  stringCasing: (casing, value, message) => {
    var strValue = value || '';

    if (casing === 'uppercase' && strValue !== strValue.toLocaleUpperCase()) {
      return message || "Must be all uppercase letters";
    }

    if (casing === 'lowercase' && strValue !== strValue.toLocaleLowerCase()) {
      return message || "Must be all lowercase letters";
    }

    return true;
  },
  presence: (flag, value, message) => {
    if (flag === 'required' && !value) {
      return message || 'Required';
    }

    return true;
  },
  regex: (options, value, message) => {
    var pattern = options.pattern,
        name = options.name,
        invert = options.invert;
    var regName = name || "\"".concat(pattern.toString(), "\"");
    var strValue = value || '';
    var matches = pattern.test(strValue);

    if (!invert && !matches || invert && matches) {
      var defaultMessage = invert ? "Should not match ".concat(regName, "-pattern") : "Does not match ".concat(regName, "-pattern");
      return message || defaultMessage;
    }

    return true;
  },
  email: (_unused, value, message) => {
    var strValue = "".concat(value || '').trim();

    if (!strValue || emailRegex.test(strValue)) {
      return true;
    }

    return message || 'Must be a valid email address';
  }
});

var _default = stringValidators;
exports.default = _default;