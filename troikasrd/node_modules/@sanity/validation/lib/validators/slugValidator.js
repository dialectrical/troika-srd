"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slugValidator = void 0;

var _memoize2 = _interopRequireDefault(require("lodash/memoize"));

var _types = require("@sanity/types");

var _getClient = _interopRequireDefault(require("../getClient"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var memoizedWarnOnArraySlug = (0, _memoize2.default)(warnOnArraySlug);

function getDocumentIds(id) {
  var isDraft = id.indexOf('drafts.') === 0;
  return {
    published: isDraft ? id.slice('drafts.'.length) : id,
    draft: isDraft ? id : "drafts.".concat(id)
  };
}

function serializePath(path) {
  return path.reduce((target, part, i) => {
    var isIndex = typeof part === 'number';
    var isKey = (0, _types.isKeyedObject)(part);
    var separator = i === 0 ? '' : '.';
    var add = isIndex || isKey ? '[]' : "".concat(separator).concat(part);
    return "".concat(target).concat(add);
  }, '');
}

var defaultIsUnique = (slug, context) => {
  var document = context.document,
      path = context.path,
      type = context.type;
  var schemaOptions = type === null || type === void 0 ? void 0 : type.options;

  if (!document) {
    throw new Error("`document` was not provided in validation context.");
  }

  if (!path) {
    throw new Error("`path` was not provided in validation context.");
  }

  var disableArrayWarning = (schemaOptions === null || schemaOptions === void 0 ? void 0 : schemaOptions.disableArrayWarning) || false;

  var _getDocumentIds = getDocumentIds(document._id),
      published = _getDocumentIds.published,
      draft = _getDocumentIds.draft;

  var docType = document._type;
  var atPath = serializePath(path.concat('current'));

  if (!disableArrayWarning && atPath.includes('[]')) {
    memoizedWarnOnArraySlug(serializePath(path));
  }

  var constraints = ['_type == $docType', "!(_id in [$draft, $published])", "".concat(atPath, " == $slug")].join(' && ');
  return (0, _getClient.default)().fetch("!defined(*[".concat(constraints, "][0]._id)"), {
    docType,
    draft,
    published,
    slug
  }, {
    tag: 'validation.slug-is-unique'
  });
};

function warnOnArraySlug(serializedPath) {
  /* eslint-disable no-console */
  console.warn(["Slug field at path ".concat(serializedPath, " is within an array and cannot be automatically checked for uniqueness"), "If you need to check for uniqueness, provide your own \"isUnique\" method", "To disable this message, set `disableArrayWarning: true` on the slug `options` field"].join('\n'));
  /* eslint-enable no-console */
}
/**
 * Validates slugs values by querying for uniqueness from the client.
 *
 * This is a custom rule implementation (e.g. `Rule.custom(slugValidator)`)
 * that's populated in `inferFromSchemaType` when the type name is `slug`
 */


var slugValidator = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (value, context) {
    var _context$type;

    if (!value) {
      return true;
    }

    if (typeof value !== 'object') {
      return 'Slug must be an object';
    }

    var slugValue = value.current;

    if (!slugValue) {
      return 'Slug must have a value';
    }

    var options = context === null || context === void 0 ? void 0 : (_context$type = context.type) === null || _context$type === void 0 ? void 0 : _context$type.options;
    var isUnique = (options === null || options === void 0 ? void 0 : options.isUnique) || defaultIsUnique;
    var wasUnique = yield isUnique(slugValue, _objectSpread(_objectSpread({}, context), {}, {
      defaultIsUnique
    }));

    if (wasUnique) {
      return true;
    }

    return 'Slug is already in use';
  });

  return function slugValidator(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.slugValidator = slugValidator;