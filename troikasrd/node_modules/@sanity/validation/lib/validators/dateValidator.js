"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRecord = isRecord;
exports.default = void 0;

var _format = _interopRequireDefault(require("date-fns/format"));

var _genericValidator = _interopRequireDefault(require("./genericValidator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function isRecord(obj) {
  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
} // eslint-disable-next-line no-useless-escape


var isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/; // eslint-disable-next-line no-warning-comments
// TODO (eventually): move these to schema type package

var getFormattedDate = function getFormattedDate() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var value = arguments.length > 1 ? arguments[1] : undefined;
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var format = 'yyyy-MM-dd';

  if (options && options.dateFormat) {
    format = options.dateFormat;
  }

  if (type === 'date') {
    // If the type is date only
    return (0, _format.default)(value, format);
  } // If the type is datetime


  if (options && options.timeFormat) {
    format += " ".concat(options.timeFormat);
  } else {
    format += ' HH:mm';
  }

  return (0, _format.default)(value, format);
};

function parseDate(date) {
  var throwOnError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!date) return null;
  if (date === 'now') return new Date(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

  var parsed = new Date(date);
  var isInvalid = isNaN(parsed.getTime());

  if (isInvalid && throwOnError) {
    throw new Error("Unable to parse \"".concat(date, "\" to a date"));
  }

  return isInvalid ? null : parsed;
}

var dateValidators = _objectSpread(_objectSpread({}, _genericValidator.default), {}, {
  type: (_unused, value, message) => {
    var strVal = "".concat(value);

    if (!strVal || isoDate.test(value)) {
      return true;
    }

    return message || 'Must be a valid ISO-8601 formatted date string';
  },
  min: (minDate, value, message, context) => {
    var dateVal = parseDate(value);

    if (!dateVal) {
      return true; // `type()` should catch parse errors
    }

    if (!value || dateVal >= parseDate(minDate, true)) {
      return true;
    }

    if (!context.type) {
      throw new Error("`type` was not provided in validation context.");
    }

    var dateTimeOptions = isRecord(context.type.options) ? context.type.options : {};
    var date = getFormattedDate(context.type.name, minDate, dateTimeOptions);
    return message || "Must be at or after ".concat(date);
  },
  max: (maxDate, value, message, context) => {
    var dateVal = parseDate(value);

    if (!dateVal) {
      return true; // `type()` should catch parse errors
    }

    if (!value || dateVal <= parseDate(maxDate, true)) {
      return true;
    }

    if (!context.type) {
      throw new Error("`type` was not provided in validation context.");
    }

    var dateTimeOptions = isRecord(context.type.options) ? context.type.options : {};
    var date = getFormattedDate(context.type.name, maxDate, dateTimeOptions);
    return message || "Must be at or before ".concat(date);
  }
});

var _default = dateValidators;
exports.default = _default;