"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNonNullable = isNonNullable;
exports.default = convertToValidationMarker;

var _ValidationError = _interopRequireDefault(require("../ValidationError"));

var _pathToString = _interopRequireDefault(require("../util/pathToString"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isNonNullable(t) {
  return t !== null || t !== undefined;
}

function convertToValidationMarker(validatorResult, level, context) {
  var _validatorResult$path;

  if (validatorResult === true) return [];

  if (Array.isArray(validatorResult)) {
    return validatorResult.flatMap(child => convertToValidationMarker(child, level, context)).filter(isNonNullable);
  }

  if (typeof validatorResult === 'string') {
    return convertToValidationMarker(new _ValidationError.default(validatorResult), level, context);
  }

  if (!(validatorResult instanceof _ValidationError.default)) {
    // in order to accept the `ValidationErrorLike`, it at least needs to have
    // a `message` in the object
    if (typeof (validatorResult === null || validatorResult === void 0 ? void 0 : validatorResult.message) !== 'string') {
      throw new Error("".concat((0, _pathToString.default)(context.path), ": Validator must return 'true' if valid or an error message as a string on errors"));
    } // this is the occurs when an object is returned that wasn't created with the
    // `ValidationErrorClass`. in this case, we want to convert it to a class


    return convertToValidationMarker(new _ValidationError.default(validatorResult.message, validatorResult), level, context);
  }

  var results = []; // the validator result does not include any item-level relative paths,
  // then just return the top-level path with the validation result

  if (!((_validatorResult$path = validatorResult.paths) !== null && _validatorResult$path !== void 0 && _validatorResult$path.length)) {
    return [{
      type: 'validation',
      level: level || 'error',
      item: validatorResult,
      path: context.path || []
    }];
  } // if the validator result did include item-level relative paths, then for
  // each item-level relative path, create a validation marker that concatenates
  // the relative path with the path from the validation context


  return results.concat(validatorResult.paths.map(path => ({
    type: 'validation',
    path: (context.path || []).concat(path),
    level: level || 'error',
    item: validatorResult
  })));
}