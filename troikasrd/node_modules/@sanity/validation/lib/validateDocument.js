"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveTypeForArrayItem = resolveTypeForArrayItem;
exports.default = validateDocument;
exports.validateItem = validateItem;

var _types = require("@sanity/types");

var _typeString = _interopRequireDefault(require("./util/typeString"));

var _ValidationError = _interopRequireDefault(require("./ValidationError"));

var _Rule = _interopRequireDefault(require("./Rule"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var appendPath = (base, next) => base.concat(next);

function resolveTypeForArrayItem(item, candidates) {
  // if there is only one type available, assume that it's the correct one
  if (candidates.length === 1) {
    return candidates[0];
  }

  var itemType = (0, _types.isTypedObject)(item) && item._type;

  var primitive = item === undefined || item === null || !itemType && (0, _typeString.default)(item).toLowerCase();

  if (primitive && primitive !== 'object') {
    return candidates.find(candidate => candidate.jsonType === primitive);
  }

  return candidates.find(candidate => {
    var _candidate$type;

    return ((_candidate$type = candidate.type) === null || _candidate$type === void 0 ? void 0 : _candidate$type.name) === itemType;
  }) || candidates.find(candidate => candidate.name === itemType) || candidates.find(candidate => candidate.name === 'object' && primitive === 'object');
}

function validateDocument(_x, _x2) {
  return _validateDocument.apply(this, arguments);
}

function _validateDocument() {
  _validateDocument = _asyncToGenerator(function* (doc, schema) {
    var documentType = schema.get(doc._type);

    if (!documentType) {
      console.warn('Schema type for object type "%s" not found, skipping validation', doc._type);
      return [];
    }

    try {
      return yield validateItem(doc, documentType, [], {
        document: doc
      });
    } catch (err) {
      console.error(err);
      return [{
        type: 'validation',
        level: 'error',
        path: [],
        item: new _ValidationError.default(err.message)
      }];
    }
  });
  return _validateDocument.apply(this, arguments);
}

function validateItem(item, type, path, context) {
  if (Array.isArray(item) && (type === null || type === void 0 ? void 0 : type.jsonType) === 'array') {
    return validateArray(item, type, path, context);
  }

  if (typeof item === 'object' && item !== null && (type === null || type === void 0 ? void 0 : type.jsonType) === 'object') {
    return validateObject(item, type, path, context);
  }

  return validatePrimitive(item, type, path, context);
}

function validateObject(_x3, _x4, _x5, _x6) {
  return _validateObject.apply(this, arguments);
}

function _validateObject() {
  _validateObject = _asyncToGenerator(function* (obj, type, path, context) {
    if (!type) {
      return [];
    }

    if (typeof type.validation === 'function') {
      throw new Error("Schema type \"".concat(type.name, "\"'s `validation` was not run though `inferFromSchema`"));
    } // Run validation for the object itself


    var objChecks = (type.validation || []).map(rule => rule.validate(obj, {
      parent: context.parent,
      document: context.document,
      path,
      type
    })); // Run validation for rules set at the object level with `Rule.fields({/* ... */})`

    var fieldRules = (type.validation || []).map(rule => rule._fieldRules).filter(Boolean) // TODO: this seems like a bug, what if multiple rules touch the same field key?
    .reduce(Object.assign, {});
    var fieldChecks = type.fields.map(field => {
      // field validation from the enclosing object type
      var fieldValidation = fieldRules[field.name];

      if (!fieldValidation) {
        return [];
      }

      var fieldPath = appendPath(path, field.name);
      var fieldValue = obj[field.name];
      return fieldValidation(new _Rule.default()).validate(fieldValue, {
        parent: obj,
        document: context.document,
        path: fieldPath,
        type: field.type
      });
    }); // Run validation from each field's schema `validation: Rule => {/* ... */}` function

    var fieldTypeChecks = type.fields.map(field => {
      var _field$type;

      // field validation from field type
      var fieldPath = appendPath(path, field.name);
      var fieldValue = obj[field.name];

      if (!((_field$type = field.type) !== null && _field$type !== void 0 && _field$type.validation)) {
        return [];
      }

      return validateItem(fieldValue, field.type, fieldPath, {
        parent: obj,
        document: context.document,
        path: fieldPath,
        type: field.type
      });
    });
    var results = yield Promise.all([...objChecks, ...fieldChecks, ...fieldTypeChecks]);
    return results.flat();
  });
  return _validateObject.apply(this, arguments);
}

function validateArray(_x7, _x8, _x9, _x10) {
  return _validateArray.apply(this, arguments);
}

function _validateArray() {
  _validateArray = _asyncToGenerator(function* (items, type, path, options) {
    if (!type) {
      return [{
        type: 'validation',
        level: 'error',
        path,
        item: new _ValidationError.default('Unable to resolve type for array')
      }];
    }

    if (typeof type.validation === 'function') {
      throw new Error("Schema type \"".concat(type.name, "\"'s `validation` was not run though `inferFromSchema`"));
    } // Validate actual array itself


    var arrayChecks = (type.validation || []).map(rule => rule.validate(items, {
      parent: options.parent,
      document: options.document,
      path,
      type
    })); // Validate items within array

    var itemChecks = items.map((item, i) => {
      var pathSegment = (0, _types.isKeyedObject)(item) ? {
        _key: item._key
      } : i;
      var itemType = resolveTypeForArrayItem(item, type.of);
      var itemPath = appendPath(path, [pathSegment]);
      return validateItem(item, itemType, itemPath, {
        parent: items,
        document: options.document,
        path: itemPath
      });
    });
    var result = yield Promise.all([...arrayChecks, ...itemChecks]);
    return result.flat();
  });
  return _validateArray.apply(this, arguments);
}

function validatePrimitive(_x11, _x12, _x13, _x14) {
  return _validatePrimitive.apply(this, arguments);
}

function _validatePrimitive() {
  _validatePrimitive = _asyncToGenerator(function* (item, type, path, context) {
    if (!type) {
      return [{
        type: 'validation',
        level: 'error',
        path,
        item: new _ValidationError.default('Unable to resolve type for item')
      }];
    }

    if (typeof type.validation === 'function') {
      throw new Error("Schema type \"".concat(type.name, "\"'s `validation` was not run though `inferFromSchema`"));
    }

    var resolved = yield Promise.all((type.validation || []).map(rule => rule.validate(item, {
      parent: context.parent,
      document: context.document,
      path
    })));
    return resolved.flat();
  });
  return _validatePrimitive.apply(this, arguments);
}