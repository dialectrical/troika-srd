"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeBlock;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _randomKey = _interopRequireDefault(require("./randomKey"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// For a block with _type 'block' (text), join spans where possible
function normalizeBlock(block) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var newIndex = 0;

  if (!block._key) {
    block._key = (0, _randomKey.default)(12);
  }

  if (block._type !== (options.blockTypeName || 'block')) {
    return block;
  }

  if (!block.children) {
    block.children = [];
  }

  if (!block.markDefs) {
    block.markDefs = [];
  }

  var lastChild = block.children.slice(-1)[0];

  if (!lastChild) {
    // A block must at least have an empty span type child
    block.children = [{
      _type: 'span',
      _key: "".concat(block._key, 0),
      text: '',
      marks: []
    }];
    return block;
  }

  var usedMarkDefs = [];
  var allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) && options.allowedDecorators;
  block.children = block.children.reduce((acc, child) => {
    var previousChild = acc.slice(-1)[0];

    if (previousChild && child._type === 'span' && previousChild._type === 'span' && (0, _isEqual2.default)(previousChild.marks, child.marks)) {
      if (lastChild && lastChild === child && child.text === '' && block.children.length > 1) {
        return acc;
      }

      previousChild.text += child.text;
      return acc;
    }

    acc.push(child);
    return acc;
  }, []).map(child => {
    child._key = "".concat(block._key).concat(newIndex++);

    if (child._type === 'span' && !child.marks) {
      child.marks = [];
    }

    if (allowedDecorators && child._type === 'span') {
      child.marks = child.marks.filter(mark => allowedDecorators.includes(mark) || block.markDefs.find(def => def._key));
    }

    usedMarkDefs = usedMarkDefs.concat(child.marks);
    return child;
  }); // Remove leftover markDefs

  block.markDefs = block.markDefs.filter(markDef => usedMarkDefs.includes(markDef._key));
  return block;
}