"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _resolveJsType = _interopRequireDefault(require("../util/resolveJsType"));

var _helpers = require("./helpers");

var _rules = _interopRequireDefault(require("./rules"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A internal variable to keep track of annotation mark definitions
 *
 */

/**
 * HTML Deserializer
 *
 */
class HtmlDeserializer {
  /**
   * Create a new serializer respecting a Sanity block content type's schema
   *
   * @param {Object} options
   *   @property {Object} blockContentType
   *      A compiled version of the block content schema type
   *   @property {Array} rules
   *      Optional rules working on the HTML (will be ruled first)
   *   @property {Function} parseHtml
   *      API compatible model as returned from DOMParser for using server side.
   */
  constructor(blockContentType) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _defineProperty(this, "blockContentType", void 0);

    _defineProperty(this, "rules", void 0);

    _defineProperty(this, "parseHtml", void 0);

    _defineProperty(this, "_markDefs", []);

    _defineProperty(this, "deserialize", html => {
      this._markDefs = [];
      var parseHtml = this.parseHtml;
      var fragment = parseHtml(html);
      var children = Array.from(fragment.childNodes); // Ensure that there are no blocks within blocks, and trim whitespace

      var blocks = (0, _helpers.trimWhitespace)((0, _helpers.flattenNestedBlocks)((0, _helpers.ensureRootIsBlocks)(this.deserializeElements(children))));

      if (this._markDefs.length > 0) {
        blocks.filter(block => block._type === 'block').forEach(block => {
          block.markDefs = block.markDefs || [];
          block.markDefs = block.markDefs.concat(this._markDefs.filter(def => {
            return (0, _flatten2.default)(block.children.map(child => child.marks || [])).includes(def._key);
          }));
        });
      } // Set back the potentially hoisted block type


      var type = this.blockContentType.of.find(findBlockType);
      return blocks.map(block => {
        if (block._type === 'block') {
          block._type = type.name;
        }

        return block;
      });
    });

    _defineProperty(this, "deserializeElements", function () {
      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var nodes = [];
      elements.forEach((element, index) => {
        var node = _this.deserializeElement(element);

        switch ((0, _resolveJsType.default)(node)) {
          case 'array':
            nodes = nodes.concat(node);
            break;

          case 'object':
            nodes.push(node);
            break;

          default:
            throw new Error("Don't know what to do with: ".concat(JSON.stringify(node)));
        }
      });
      return nodes;
    });

    _defineProperty(this, "deserializeElement", element => {
      var node;

      if (!element.tagName) {
        element.tagName = '';
      }

      var next = elements => {
        var _elements = elements;

        if (Object.prototype.toString.call(_elements) == '[object NodeList]') {
          _elements = Array.from(_elements);
        }

        switch ((0, _resolveJsType.default)(_elements)) {
          case 'array':
            return this.deserializeElements(_elements);

          case 'object':
            return this.deserializeElement(_elements);

          case 'null':
          case 'undefined':
            return undefined;

          default:
            throw new Error("The `next` argument was called with invalid children: \"".concat(_elements, "\"."));
        }
      };

      var block = props => {
        return {
          _type: '__block',
          block: props
        };
      };

      var _loop = function _loop(i) {
        var rule = _this.rules[i];

        if (!rule.deserialize) {
          return "continue";
        }

        var ret = rule.deserialize(element, next, block);
        var type = (0, _resolveJsType.default)(ret);

        if (type != 'array' && type != 'object' && type != 'null' && type != 'undefined') {
          throw new Error("A rule returned an invalid deserialized representation: \"".concat(node, "\"."));
        }

        if (ret === undefined) {
          return "continue";
        } else if (ret === null) {
          return {
            v: null
          };
        } else if (ret._type === '__decorator') {
          node = _this.deserializeDecorator(ret);
        } else if (ret._type === '__annotation') {
          node = _this.deserializeAnnotation(ret);
        } else {
          node = ret;
        } // Set list level on list item


        if (ret && ret._type === 'block' && ret.listItem) {
          var parent = element.parentNode.parentNode;

          while ((0, _helpers.tagName)(parent) === 'li') {
            parent = parent.parentNode.parentNode;
            ret.level++;
          }
        } // Set newlines on spans orginating from a block element within a blockquote


        if (ret && ret._type === 'block' && ret.style === 'blockquote') {
          ret.children.forEach((child, index) => {
            if (child._type === 'span' && child.text === '\r') {
              child.text = '\n\n';

              if (index === 0 || index === ret.children.length - 1) {
                ret.children.splice(index, 1);
              }
            }
          });
        }

        return "break";
      };

      for (var i = 0; i < this.rules.length; i++) {
        var _ret = _loop(i);

        if (_ret === "continue") continue;
        if (_ret === "break") break;
        if (typeof _ret === "object") return _ret.v;
      }

      return node || next(element.childNodes);
    });

    _defineProperty(this, "deserializeDecorator", decorator => {
      var name = decorator.name;

      var applyDecorator = node => {
        if (node._type === '__decorator') {
          return this.deserializeDecorator(node);
        } else if (node._type === 'span') {
          node.marks = node.marks || [];

          if (node.text.trim()) {
            // Only apply marks if this is an actual text
            node.marks.unshift(name);
          }
        } else if (node.children) {
          node.children = node.children.map(applyDecorator);
        }

        return node;
      };

      return decorator.children.reduce((children, node) => {
        var ret = applyDecorator(node);

        if (Array.isArray(ret)) {
          return children.concat(ret);
        }

        children.push(ret);
        return children;
      }, []);
    });

    _defineProperty(this, "deserializeAnnotation", annotation => {
      var markDef = annotation.markDef;

      this._markDefs.push(markDef);

      var applyAnnotation = node => {
        if (node._type === '__annotation') {
          return this.deserializeAnnotation(node);
        } else if (node._type === 'span') {
          node.marks = node.marks || [];

          if (node.text.trim()) {
            // Only apply marks if this is an actual text
            node.marks.unshift(markDef._key);
          }
        } else if (node.children) {
          node.children = node.children.map(applyAnnotation);
        }

        return node;
      };

      return annotation.children.reduce((children, node) => {
        var ret = applyAnnotation(node);

        if (Array.isArray(ret)) {
          return children.concat(ret);
        }

        children.push(ret);
        return children;
      }, []);
    });

    var _options$rules = options.rules,
        rules = _options$rules === void 0 ? [] : _options$rules;

    if (!blockContentType) {
      throw new Error("Parameter 'blockContentType' is required");
    }

    var standardRules = (0, _rules.default)(blockContentType, (0, _helpers.createRuleOptions)(blockContentType));
    this.rules = [...rules, ...standardRules];

    var _parseHtml = options.parseHtml || (0, _helpers.defaultParseHtml)();

    this.blockContentType = blockContentType;

    this.parseHtml = html => {
      var doc = (0, _helpers.preprocess)(html, _parseHtml);
      return doc.body;
    };
  }
  /**
   * Deserialize HTML.
   *
   * @param {String} html
   * @return {Array}
   */


}

exports.default = HtmlDeserializer;

function findBlockType(type) {
  if (type.type) {
    return findBlockType(type.type);
  }

  if (type.name === 'block') {
    return type;
  }

  return null;
}