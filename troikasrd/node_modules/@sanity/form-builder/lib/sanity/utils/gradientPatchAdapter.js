"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toGradient = toGradient;
exports.toFormBuilder = toFormBuilder;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _assert = _interopRequireDefault(require("assert"));

var _mutator = require("@sanity/mutator");

var convertPath = _interopRequireWildcard(require("./convertPath"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toGradient(patches) {
  return patches.map(toGradientPatch);
}

function toFormBuilder(origin, patches) {
  return (0, _flatten2.default)(patches.map(patch => toFormBuilderPatches(origin, patch)));
}

var notIn = values => value => !values.includes(value);

function toFormBuilderPatches(origin, patch) {
  return (0, _flatten2.default)(Object.keys(patch).filter(notIn(['id', 'ifRevisionID', 'query'])).map(type => {
    if (type === 'unset') {
      return patch.unset.map(path => {
        return {
          type: 'unset',
          path: convertPath.toFormBuilder(path),
          origin
        };
      });
    }

    if (type === 'insert') {
      var position = 'before' in patch.insert ? 'before' : 'after';
      return {
        type: 'insert',
        position: position,
        path: convertPath.toFormBuilder(patch.insert[position]),
        items: patch.insert.items,
        origin
      };
    }

    return Object.keys(patch[type]).map(gradientPath => {
      if (type === 'set') {
        return {
          type: 'set',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'inc' || type === 'dec') {
        return {
          type: type,
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'setIfMissing') {
        return {
          type: 'setIfMissing',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'diffMatchPatch') {
        return {
          type: 'diffMatchPatch',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      } // eslint-disable-next-line no-console


      console.warn(new Error("Unsupported patch type: ".concat(type)));
      return null;
    }).filter(Boolean);
  }));
}

function toGradientPatch(patch) {
  var matchPath = (0, _mutator.arrayToJSONMatchPath)(patch.path || []);

  if (patch.type === 'insert') {
    var position = patch.position,
        items = patch.items;
    return {
      insert: {
        [position]: matchPath,
        items: items
      }
    };
  }

  if (patch.type === 'unset') {
    return {
      unset: [matchPath]
    };
  }

  (0, _assert.default)(patch.type, "Missing patch type in patch ".concat(JSON.stringify(patch)));

  if (matchPath) {
    return {
      [patch.type]: {
        [matchPath]: patch.value
      }
    };
  }

  return {
    [patch.type]: patch.value
  };
}