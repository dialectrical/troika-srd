"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withMaxConcurrency = withMaxConcurrency;
exports.createThrottler = createThrottler;

var _operators = require("rxjs/operators");

var _rxjs = require("rxjs");

// Takes a observable-returning function and returns a new function that limits on the number of
// concurrent observables.
var DEFAULT_CONCURRENCY = 4;

function remove(array, item) {
  var index = array.indexOf(item);

  if (index > -1) {
    array.splice(index, 1);
  }

  return array;
}

function withMaxConcurrency(func) {
  var concurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CONCURRENCY;
  var throttler = createThrottler(concurrency);
  return function () {
    return (0, _rxjs.from)(throttler(func(...arguments)));
  };
}

function createThrottler() {
  var concurrency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_CONCURRENCY;
  var currentSubscriptions = [];
  var pendingObservables = [];
  var ready$ = new _rxjs.Subject();
  return request;

  function request(observable) {
    return new _rxjs.Observable(observer => {
      if (currentSubscriptions.length >= concurrency) {
        return scheduleAndWait(observable).pipe((0, _operators.mergeMap)(request)).subscribe(observer);
      }

      var subscription = observable.subscribe(observer);
      currentSubscriptions.push(subscription);
      return () => {
        remove(currentSubscriptions, subscription);
        remove(pendingObservables, observable);
        subscription.unsubscribe();
        check();
      };
    });
  }

  function scheduleAndWait(observable) {
    pendingObservables.push(observable);
    return ready$.asObservable().pipe((0, _operators.first)(obs => obs === observable));
  }

  function check() {
    while (pendingObservables.length > 0 && currentSubscriptions.length < concurrency) {
      ready$.next(pendingObservables.shift());
    }
  }
}