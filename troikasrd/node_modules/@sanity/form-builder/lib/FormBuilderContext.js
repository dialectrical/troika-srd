"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _nanoPubsub = _interopRequireDefault(require("nano-pubsub"));

var _fallbackInputs = require("./fallbackInputs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var RESOLVE_NULL = arg => null;

function resolve(type) {
  var providedResolve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RESOLVE_NULL;
  var itType = type;

  while (itType) {
    var resolved = providedResolve(itType);

    if (resolved) {
      return resolved;
    }

    itType = itType.type;
  }

  return undefined;
} // Memoize return values from a method that takes a single arg
// memoized as a map of argument => return value


function memoizeMap(method) {
  var map = new WeakMap();
  return function memoizedMap(arg) {
    if (map.has(arg)) {
      return map.get(arg);
    }

    var val = method.call(this, arg);

    if (arg) {
      map.set(arg, val);
    }

    return val;
  };
} // Memoize return value from method that takes no args


function memoize(method) {
  var called = false;
  var val;
  return function memoized() {
    if (called) {
      return val;
    }

    val = method.call(this);
    called = true;
    return val;
  };
}

class FormBuilderContext extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "getDocument", () => {
      return this.props.value;
    });

    _defineProperty(this, "resolveInputComponent", memoizeMap(type => {
      var resolveInputComponent = this.props.resolveInputComponent;
      return resolve(type, resolveInputComponent) || _fallbackInputs.fallbackInputs[type.jsonType];
    }));

    _defineProperty(this, "resolvePreviewComponent", memoizeMap(type => {
      var resolvePreviewComponent = this.props.resolvePreviewComponent;
      return resolve(type, resolvePreviewComponent);
    }));

    _defineProperty(this, "getChildContext", memoize(() => {
      var _this$props = this.props,
          schema = _this$props.schema,
          filterField = _this$props.filterField,
          patchChannel = _this$props.patchChannel;
      return {
        filterField: filterField,
        getValuePath: () => [],
        formBuilder: {
          onPatch: patchChannel ? patchChannel.onPatch : () => {
            // eslint-disable-next-line no-console
            console.warn('No patch channel provided to form-builder. If you need input based patch updates, please provide one');
            return () => {// no-op
            };
          },
          schema,
          resolveInputComponent: this.resolveInputComponent,
          resolvePreviewComponent: this.resolvePreviewComponent,
          getDocument: this.getDocument
        }
      };
    }));
  }

  render() {
    return this.props.children;
  }

}

exports.default = FormBuilderContext;

_defineProperty(FormBuilderContext, "createPatchChannel", () => {
  var channel = (0, _nanoPubsub.default)();
  return {
    onPatch: channel.subscribe,
    receivePatches: channel.publish
  };
});

_defineProperty(FormBuilderContext, "childContextTypes", {
  getValuePath: _propTypes.default.func,
  onPatch: _propTypes.default.func,
  filterField: _propTypes.default.func,
  formBuilder: _propTypes.default.shape({
    schema: _propTypes.default.object,
    resolveInputComponent: _propTypes.default.func,
    document: _propTypes.default.any
  })
});