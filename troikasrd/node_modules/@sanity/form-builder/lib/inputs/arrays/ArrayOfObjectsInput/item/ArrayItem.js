"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayItem = void 0;

var _changeIndicators = require("@sanity/base/change-indicators");

var _types = require("@sanity/types");

var _react = _interopRequireWildcard(require("react"));

var _paths = require("@sanity/util/paths");

var _empty = require("../../../../utils/empty");

var _focusUtils = require("../../../../utils/focusUtils");

var _useScrollIntoViewOnFocusWithin = require("../../../../hooks/useScrollIntoViewOnFocusWithin");

var _helpers = require("./helpers");

var _EditDialog = require("./EditDialog");

var _ItemRow = require("./ItemRow");

var _ItemCell = require("./ItemCell");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ArrayItem = /*#__PURE__*/(0, _react.memo)(function ArrayItem(props) {
  var _type$options, _type$options2;

  var value = props.value,
      markers = props.markers,
      type = props.type,
      index = props.index,
      itemKey = props.itemKey,
      readOnly = props.readOnly,
      presence = props.presence,
      focusPath = props.focusPath,
      onFocus = props.onFocus,
      onChange = props.onChange,
      onRemove = props.onRemove,
      onBlur = props.onBlur,
      filterField = props.filterField,
      compareValue = props.compareValue;
  var innerElementRef = (0, _react.useRef)(null);
  var hasFocusWithin = (0, _focusUtils.hasFocusWithinPath)(props.focusPath, props.value);
  (0, _useScrollIntoViewOnFocusWithin.useScrollIntoViewOnFocusWithin)(innerElementRef, hasFocusWithin);
  var itemPath = (0, _react.useMemo)(() => (0, _paths.pathFor)([itemKey ? {
    _key: itemKey
  } : index]), [index, itemKey]);
  var emitFocus = (0, _react.useCallback)(function () {
    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _empty.EMPTY_ARRAY;

    if (itemKey) {
      onFocus([{
        _key: itemKey
      }, ...path]);
    }
  }, [onFocus, itemKey]);
  var handleFocus = (0, _react.useCallback)(() => emitFocus(), [emitFocus]);
  var handleEditOpen = (0, _react.useCallback)(() => emitFocus([_paths.FOCUS_TERMINATOR]), [emitFocus]);
  var handleEditClose = (0, _react.useCallback)(() => {
    if ((0, _helpers.isEmpty)(value)) {
      onRemove(value);
    }

    emitFocus();
  }, [value, onRemove, emitFocus]);
  var handleChange = (0, _react.useCallback)((event, valueOverride) => onChange(event, typeof valueOverride === 'undefined' ? value : valueOverride), [onChange, value]);
  var handleRemove = (0, _react.useCallback)(() => onRemove(value), [onRemove, value]);
  var handleKeyPress = (0, _react.useCallback)(event => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleEditOpen();
    }
  }, [handleEditOpen]);
  var options = type.options || {};
  var isSortable = !readOnly && !type.readOnly && options.sortable !== false;
  var isEditing = (0, _focusUtils.hasFocusWithinPath)(focusPath, value);
  var itemType = (0, _helpers.getItemType)(type, value);
  var LayoutComponent = ((_type$options = type.options) === null || _type$options === void 0 ? void 0 : _type$options.layout) === 'grid' ? _ItemCell.ItemCell : _ItemRow.ItemRow;

  var itemMarkers = _react.default.useMemo(() => markers.filter(marker => (0, _paths.startsWith)(itemPath, marker.path)), [itemPath, markers]);

  var scopedValidation = (0, _react.useMemo)(() => itemMarkers.length === 0 ? _empty.EMPTY_ARRAY : itemMarkers.filter(_types.isValidationMarker).map(marker => {
    if (marker.path.length <= 1) {
      return marker;
    }

    var level = marker.level === 'error' ? 'errors' : 'warnings';
    return _objectSpread(_objectSpread({}, marker), {}, {
      item: marker.item.cloneWithMessage("Contains ".concat(level))
    });
  }), [itemMarkers]);
  var itemPresence = (0, _react.useMemo)(() => presence.filter(presenceItem => (0, _paths.startsWith)(itemPath, presenceItem.path)), [itemPath, presence]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_changeIndicators.ChangeIndicatorScope, {
    path: itemPath
  }, /*#__PURE__*/_react.default.createElement(_changeIndicators.ContextProvidedChangeIndicator, {
    compareDeep: true,
    disabled: isEditing
  }, /*#__PURE__*/_react.default.createElement(LayoutComponent, {
    "aria-selected": isEditing,
    value: value,
    readOnly: readOnly,
    type: itemType,
    presence: isEditing ? _empty.EMPTY_ARRAY : itemPresence,
    validation: scopedValidation,
    isSortable: isSortable,
    onFocus: handleFocus,
    onClick: itemType ? handleEditOpen : undefined,
    onRemove: handleRemove,
    onKeyPress: handleKeyPress,
    ref: innerElementRef
  }))), isEditing && itemType && /*#__PURE__*/_react.default.createElement(_EditDialog.EditDialog, {
    onChange: handleChange,
    onClose: handleEditClose,
    markers: itemMarkers,
    referenceElement: innerElementRef.current,
    filterField: filterField,
    focusPath: focusPath,
    onFocus: onFocus,
    onBlur: onBlur,
    type: itemType,
    dialogType: (type === null || type === void 0 ? void 0 : (_type$options2 = type.options) === null || _type$options2 === void 0 ? void 0 : _type$options2.editModal) || 'dialog',
    value: value,
    readOnly: readOnly || itemType.readOnly || false,
    presence: itemPresence,
    compareValue: compareValue
  }));
});
exports.ArrayItem = ArrayItem;