"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uploadTarget = uploadTarget;

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _ui = require("@sanity/ui");

var _react = _interopRequireDefault(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _fileTarget = require("../../../common/fileTarget");

var _DropMessage = require("../../../files/common/DropMessage");

var _styles = require("./styles");

var _excluded = ["children", "resolveUploader", "onUpload", "types"];

var _templateObject;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var Root = _styledComponents.default.div(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  position: relative;\n"])));

function getUploadCandidates(types, resolveUploader, file) {
  return types.map(memberType => ({
    type: memberType,
    uploader: resolveUploader(memberType, file)
  })).filter(member => member.uploader);
}

function uploadTarget(Component) {
  var FileTarget = (0, _fileTarget.fileTarget)(Component);
  return /*#__PURE__*/_react.default.forwardRef(function UploadTarget(props, forwardedRef) {
    var children = props.children,
        resolveUploader = props.resolveUploader,
        onUpload = props.onUpload,
        types = props.types,
        rest = _objectWithoutProperties(props, _excluded);

    var _useToast = (0, _ui.useToast)(),
        pushToast = _useToast.push;

    var uploadFile = _react.default.useCallback((file, resolvedUploader) => {
      var type = resolvedUploader.type,
          uploader = resolvedUploader.uploader;
      onUpload === null || onUpload === void 0 ? void 0 : onUpload({
        file,
        type,
        uploader
      });
    }, [onUpload]);

    var handleFiles = _react.default.useCallback(files => {
      if (!resolveUploader) {
        return;
      }

      var tasks = files.map(file => ({
        file,
        uploaderCandidates: getUploadCandidates(types, resolveUploader, file)
      }));
      var ready = tasks.filter(task => task.uploaderCandidates.length > 0);
      var rejected = tasks.filter(task => task.uploaderCandidates.length === 0);

      if (rejected.length > 0) {
        var plural = rejected.length > 1;
        pushToast({
          closable: true,
          status: 'warning',
          title: "The following item".concat(plural ? 's' : '', " can't be uploaded because there's no known conversion from content type").concat(plural ? 's' : '', " to array item:"),
          description: rejected.map((task, i) => /*#__PURE__*/_react.default.createElement(_ui.Flex, {
            key: i,
            padding: 2
          }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
            marginLeft: 1
          }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
            weight: "semibold"
          }, task.file.name)), /*#__PURE__*/_react.default.createElement(_ui.Box, {
            paddingLeft: 2
          }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
            size: 1
          }, "(", task.file.type, ")"))))
        });
      } // todo: consider if we should to ask the user here
      // the list of candidates is sorted by their priority and the first one is selected
      // const ambiguous = tasks
      //   .filter(task => task.uploaderCandidates.length > 1)


      ready.forEach(task => {
        uploadFile(task.file, // eslint-disable-next-line max-nested-callbacks
        (0, _sortBy2.default)(task.uploaderCandidates, candidate => candidate.uploader.priority)[0]);
      });
    }, [pushToast, resolveUploader, types, uploadFile]);

    var _React$useState = _react.default.useState([]),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        hoveringFiles = _React$useState2[0],
        setHoveringFiles = _React$useState2[1];

    var handleFilesOut = _react.default.useCallback(() => setHoveringFiles([]), []);

    return /*#__PURE__*/_react.default.createElement(Root, null, /*#__PURE__*/_react.default.createElement(FileTarget, _extends({}, rest, {
      ref: forwardedRef,
      onFiles: handleFiles,
      onFilesOver: setHoveringFiles,
      onFilesOut: handleFilesOut
    }), resolveUploader && hoveringFiles.length > 0 && /*#__PURE__*/_react.default.createElement(_styles.Overlay, {
      zOffset: 10
    }, /*#__PURE__*/_react.default.createElement(_DropMessage.DropMessage, {
      hoveringFiles: hoveringFiles,
      types: types,
      resolveUploader: resolveUploader
    })), children));
  });
}