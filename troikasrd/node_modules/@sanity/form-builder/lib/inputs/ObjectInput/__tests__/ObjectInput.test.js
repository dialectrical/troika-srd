"use strict";

require("@testing-library/jest-dom/extend-expect");

var _react = require("@testing-library/react");

var _userEvent = _interopRequireDefault(require("@testing-library/user-event"));

var _react2 = _interopRequireWildcard(require("react"));

var _ui = require("@sanity/ui");

var _schema = _interopRequireDefault(require("@sanity/schema"));

var _ObjectInput = require("../ObjectInput");

var _FormBuilderContext = _interopRequireDefault(require("../../../FormBuilderContext"));

var _is = _interopRequireDefault(require("../../../utils/is"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var schema = _schema.default.compile({
  name: 'test',
  types: [{
    title: 'Collapsible test',
    name: 'collapsibleTest',
    type: 'object',
    fields: [{
      name: 'collapsibleAndCollapsedByDefault',
      type: 'object',
      options: {
        collapsible: true,
        collapsed: true
      },
      fields: [{
        name: 'field1',
        type: 'string'
      }]
    }]
  }, {
    title: 'Focus test',
    name: 'focusTest',
    type: 'object',
    fields: [{
      name: 'title',
      type: 'string'
    }, {
      name: 'focusTest',
      type: 'object',
      fields: [{
        name: 'field1',
        type: 'string'
      }]
    }]
  }, {
    title: 'Hidden test',
    name: 'hiddenTest',
    type: 'object',
    fields: [{
      name: 'thisIsVisible',
      type: 'string'
    }, {
      name: 'thisIsHidden',
      type: 'string',
      hidden: true
    }, {
      name: 'thisMayBeVisible',
      type: 'string'
    }]
  }]
}); // eslint-disable-next-line no-empty-function,@typescript-eslint/no-empty-function


var noop = () => {};

var GenericInput = /*#__PURE__*/(0, _react2.forwardRef)(function GenericInput(props, ref) {
  return /*#__PURE__*/_react2.default.createElement("input", {
    type: "string",
    ref: ref,
    onFocus: props.onFocus
  });
});

var GenericPreview = function GenericPreview(props) {
  return /*#__PURE__*/_react2.default.createElement("div", null);
};

function inputResolver(type) {
  if ((0, _is.default)('object', type)) {
    return _ObjectInput.ObjectInput;
  }

  return GenericInput;
}

var DEFAULT_PROPS = {
  onFocus: jest.fn(),
  onBlur: jest.fn(),
  onChange: jest.fn(),
  markers: [],
  level: 0,
  presence: []
};
var ObjectInputTester = /*#__PURE__*/(0, _react2.forwardRef)(function ObjectInputTester(props, ref) {
  return /*#__PURE__*/_react2.default.createElement(_ui.ThemeProvider, {
    scheme: "light",
    theme: _ui.studioTheme
  }, /*#__PURE__*/_react2.default.createElement(_ui.LayerProvider, null, /*#__PURE__*/_react2.default.createElement(_FormBuilderContext.default, {
    value: undefined,
    patchChannel: {
      onPatch: noop
    },
    schema: schema,
    filterField: () => true,
    resolveInputComponent: inputResolver,
    resolvePreviewComponent: type => GenericPreview
  }, /*#__PURE__*/_react2.default.createElement(_ObjectInput.ObjectInput, _extends({}, DEFAULT_PROPS, props, {
    ref: ref
  })))));
});
var TOGGLE_BUTTON_SELECTOR = 'legend div';
describe('collapsible behavior', () => {
  it('does not render collapsible fields on objects configured with collapsed: true', () => {
    var _render = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('collapsibleTest'),
      focusPath: []
    })),
        queryByTestId = _render.queryByTestId;

    expect(queryByTestId('input-field1')).toBeNull();
  });
  it('renders collapsible fields with collapsed: true if given a focus path that targets it', () => {
    var _render2 = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('collapsibleTest'),
      focusPath: ['collapsibleAndCollapsedByDefault', 'field1']
    })),
        queryByTestId = _render2.queryByTestId;

    expect(queryByTestId('input-field1')).toBeVisible();
  });
  it('toggles the collapsible field when clicking the expand/collapse button', () => {
    var firstFieldPath = ['collapsibleAndCollapsedByDefault', 'field1'];
    var onFocus = jest.fn();

    var _render3 = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      level: 0,
      onFocus: onFocus,
      type: schema.get('collapsibleTest')
    })),
        container = _render3.container,
        queryByTestId = _render3.queryByTestId,
        rerender = _render3.rerender;

    expect(queryByTestId('input-field1')).toBeNull();
    var button = container.querySelector(TOGGLE_BUTTON_SELECTOR);

    _userEvent.default.click(button);

    expect(onFocus).toHaveBeenCalledTimes(1);
    expect(onFocus).toHaveBeenCalledWith(firstFieldPath);
    rerender( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      level: 0,
      focusPath: firstFieldPath,
      onFocus: onFocus,
      type: schema.get('collapsibleTest')
    }));
    expect(queryByTestId('input-field1')).toBeVisible();

    _userEvent.default.click(button);

    expect(onFocus).toHaveBeenCalledTimes(2);
    expect(onFocus).toHaveBeenLastCalledWith(['collapsibleAndCollapsedByDefault']);
    expect(queryByTestId('input-field1')).toBeNull();
  });
  it('does not show hidden fields', () => {
    var onFocus = jest.fn();

    var _render4 = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      onFocus: onFocus,
      type: schema.get('hiddenTest')
    })),
        queryByTestId = _render4.queryByTestId;

    expect(queryByTestId('input-thisIsVisible')).toBeVisible();
    expect(queryByTestId('input-thisIsHidden')).toBeNull();
    expect(queryByTestId('input-thisMayBeVisible')).toBeVisible();
  });
  it('supports filtering fields based on a predicate', () => {
    var onFocus = jest.fn();

    var _render5 = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      onFocus: onFocus,
      type: schema.get('hiddenTest'),
      filterField: (type, field) => field.name !== 'thisMayBeVisible'
    })),
        queryByTestId = _render5.queryByTestId;

    expect(queryByTestId('input-thisIsVisible')).toBeVisible();
    expect(queryByTestId('input-thisIsHidden')).toBeNull();
    expect(queryByTestId('input-thisMayBeVisible')).toBeNull();
  });
  it("expands a field that's been manually collapsed when receiving a focus path that targets it", () => {
    var firstFieldPath = ['collapsibleAndCollapsedByDefault', 'field1'];
    var onFocus = jest.fn();

    var _render6 = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      onFocus: onFocus,
      type: schema.get('collapsibleTest')
    })),
        container = _render6.container,
        queryByTestId = _render6.queryByTestId,
        rerender = _render6.rerender;

    expect(queryByTestId('input-field1')).toBeNull();
    var toggleButton = container.querySelector(TOGGLE_BUTTON_SELECTOR);

    _userEvent.default.click(toggleButton);

    expect(onFocus).toHaveBeenCalledTimes(1);
    expect(onFocus).toHaveBeenCalledWith(firstFieldPath);
    rerender( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('collapsibleTest'),
      focusPath: firstFieldPath,
      onFocus: onFocus
    }));
    expect(queryByTestId('input-field1')).toBeVisible();

    _userEvent.default.click(toggleButton);

    rerender( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('collapsibleTest'),
      focusPath: ['collapsibleAndCollapsedByDefault'],
      onFocus: onFocus
    }));
    expect(queryByTestId('input-field1')).toBeNull(); // Focus moves into the collapsed field (this happens when e.g. deep linking)

    rerender( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('collapsibleTest'),
      focusPath: ['collapsibleAndCollapsedByDefault', 'field1'],
      onFocus: onFocus
    }));
    expect(queryByTestId('input-field1')).toBeVisible(); // Note: if focus moves to another field we don't want to collapse the field again

    rerender( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('collapsibleTest'),
      focusPath: []
    }));
    expect(queryByTestId('input-field1')).toBeVisible();
  });
});
describe('focus handling', () => {
  it('calling .focus() on its ref puts focus on DOM node for its first field', () => {
    var _queryByTestId;

    var inputRef;

    var _render7 = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('focusTest'),
      ref: _ref => inputRef = _ref
    })),
        queryByTestId = _render7.queryByTestId;

    expect(inputRef).toBeDefined();
    inputRef.focus();
    expect((_queryByTestId = queryByTestId('input-title')) === null || _queryByTestId === void 0 ? void 0 : _queryByTestId.querySelector('input')).toHaveFocus();
  });
  it('updates input focus based on passed focusPath', () => {
    var _queryByTestId2;

    var _render8 = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('focusTest'),
      focusPath: ['focusTest', 'field1']
    })),
        queryByTestId = _render8.queryByTestId;

    expect((_queryByTestId2 = queryByTestId('input-field1')) === null || _queryByTestId2 === void 0 ? void 0 : _queryByTestId2.querySelector('input')).toHaveFocus();
  });
  it('emits an `onFocus()` event with the focus path of the first field when the imperative .focus() method is invoked', () => {
    // Note: this depends on the underlying native input component forwarding it's received onFocus prop
    var inputRef;
    var onFocus = jest.fn();
    (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ObjectInputTester, {
      type: schema.get('focusTest'),
      onFocus: onFocus,
      ref: _ref2 => inputRef = _ref2
    }));
    inputRef.focus();
    expect(onFocus).toHaveBeenCalledTimes(1);
    expect(onFocus).toHaveBeenCalledWith(['title']);
  });
});