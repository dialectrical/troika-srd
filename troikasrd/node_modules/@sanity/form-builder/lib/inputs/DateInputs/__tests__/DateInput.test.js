"use strict";

require("@testing-library/jest-dom/extend-expect");

var _react = require("@testing-library/react");

var _userEvent = _interopRequireDefault(require("@testing-library/user-event"));

var _react2 = _interopRequireDefault(require("react"));

var _ui = require("@sanity/ui");

var _DateInput = require("../DateInput");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function renderInput() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var onFocus = jest.fn();
  var onChange = jest.fn();

  var _render = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(_ui.ThemeProvider, {
    scheme: "light",
    theme: _ui.studioTheme
  }, /*#__PURE__*/_react2.default.createElement(_ui.LayerProvider, null, /*#__PURE__*/_react2.default.createElement(_DateInput.DateInput, _extends({
    type: {
      title: 'Date input test',
      name: 'date',
      options: {}
    },
    onFocus: onFocus,
    onChange: onChange,
    markers: [],
    level: 0
  }, props))))),
      container = _render.container;

  var textInput = container.querySelector('input');
  return {
    onChange,
    onFocus,
    textInput
  };
} // Note: for the tests to be deterministic we need this to ensure tests are run in a predefined timezone
// see globalSetup in jest config for details about how this is set up


test('timezone for the test environment should be set to America/Los_Angeles', () => {
  expect(new Date().getTimezoneOffset()).toBe(420);
});
test('does not emit onChange after invalid value has been typed', () => {
  var _renderInput = renderInput(),
      textInput = _renderInput.textInput,
      onChange = _renderInput.onChange;

  _userEvent.default.type(textInput, 'this is invalid');

  expect(textInput === null || textInput === void 0 ? void 0 : textInput.value).toBe('this is invalid');
  expect(onChange.mock.calls.length).toBe(0);

  _react.fireEvent.blur(textInput);

  expect(onChange.mock.calls.length).toBe(0);
});
test('emits onChange on correct format if a valid value has been typed', () => {
  var _renderInput2 = renderInput(),
      textInput = _renderInput2.textInput,
      onChange = _renderInput2.onChange; // note: the date is entered and displayed in local timezone


  _userEvent.default.type(textInput, '2021-03-28');

  expect(textInput === null || textInput === void 0 ? void 0 : textInput.value).toBe('2021-03-28');

  _react.fireEvent.blur(textInput); // note: the date is entered and displayed in local timezone but stored in utc


  expect(onChange.mock.calls).toMatchInlineSnapshot("\n    Array [\n      Array [\n        PatchEvent {\n          \"patches\": Array [\n            Object {\n              \"path\": Array [],\n              \"type\": \"set\",\n              \"value\": \"2021-03-28\",\n            },\n          ],\n        },\n      ],\n    ]\n  ");
});
test('formatting of deserialized value', () => {
  var _renderInput3 = renderInput({
    value: '2021-03-28'
  }),
      textInput = _renderInput3.textInput;

  expect(textInput === null || textInput === void 0 ? void 0 : textInput.value).toBe('2021-03-28');
});