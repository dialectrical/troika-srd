"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Calendar = void 0;

var _range2 = _interopRequireDefault(require("lodash/range"));

var _ui = require("@sanity/ui");

var _icons = require("@sanity/icons");

var _dateFns = require("date-fns");

var _react = _interopRequireWildcard(require("react"));

var _CalendarMonth = require("./CalendarMonth");

var _constants = require("./constants");

var _features = require("./features");

var _utils = require("./utils");

var _YearInput = require("./YearInput");

var _excluded = ["selectTime", "onFocusedDateChange", "selectedDate", "focusedDate", "timeStep", "onSelect"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// This is used to maintain focus on a child element of the calendar-grid between re-renders
// When using arrow keys to move focus from a day in one month to another we are setting focus at the button for the day
// after it has changed but *only* if we *already* had focus inside the calendar grid (e.g not if focus was on the "next
// year" button, or any of the other controls)
// When moving from the last day of a month that displays 6 weeks in the grid to a month that displays 5 weeks, current
// focus gets lost on render, so this provides us with a stable element to help us preserve focus on a child element of
// the calendar grid between re-renders
var PRESERVE_FOCUS_ELEMENT = /*#__PURE__*/_react.default.createElement("span", {
  "data-preserve-focus": true,
  style: {
    overflow: 'hidden',
    position: 'absolute',
    outline: 'none'
  },
  tabIndex: -1
});

var Calendar = /*#__PURE__*/(0, _react.forwardRef)(function Calendar(props, forwardedRef) {
  var selectTime = props.selectTime,
      onFocusedDateChange = props.onFocusedDateChange,
      _props$selectedDate = props.selectedDate,
      selectedDate = _props$selectedDate === void 0 ? new Date() : _props$selectedDate,
      _props$focusedDate = props.focusedDate,
      focusedDate = _props$focusedDate === void 0 ? selectedDate : _props$focusedDate,
      _props$timeStep = props.timeStep,
      timeStep = _props$timeStep === void 0 ? 1 : _props$timeStep,
      onSelect = props.onSelect,
      restProps = _objectWithoutProperties(props, _excluded);

  var setFocusedDate = (0, _react.useCallback)(date => onFocusedDateChange(date), [onFocusedDateChange]);
  var setFocusedDateMonth = (0, _react.useCallback)(month => setFocusedDate((0, _dateFns.setDate)((0, _dateFns.setMonth)(focusedDate, month), 1)), [focusedDate, setFocusedDate]);
  var handleFocusedMonthChange = (0, _react.useCallback)(e => setFocusedDateMonth(Number(e.currentTarget.value)), [setFocusedDateMonth]);
  var moveFocusedDate = (0, _react.useCallback)(by => setFocusedDate((0, _dateFns.addMonths)(focusedDate, by)), [focusedDate, setFocusedDate]);
  var setFocusedDateYear = (0, _react.useCallback)(year => setFocusedDate((0, _dateFns.setYear)(focusedDate, year)), [focusedDate, setFocusedDate]);
  var handleDateChange = (0, _react.useCallback)(date => {
    onSelect((0, _dateFns.setMinutes)((0, _dateFns.setHours)(date, selectedDate.getHours()), selectedDate.getMinutes()));
  }, [onSelect, selectedDate]);
  var handleMinutesChange = (0, _react.useCallback)(event => {
    var m = Number(event.currentTarget.value);
    onSelect((0, _dateFns.setMinutes)(selectedDate, m));
  }, [onSelect, selectedDate]);
  var handleHoursChange = (0, _react.useCallback)(event => {
    var m = Number(event.currentTarget.value);
    onSelect((0, _dateFns.setHours)(selectedDate, m));
  }, [onSelect, selectedDate]);
  var handleTimeChange = (0, _react.useCallback)((hours, mins) => {
    onSelect((0, _dateFns.setHours)((0, _dateFns.setMinutes)(selectedDate, mins), hours));
  }, [onSelect, selectedDate]);
  var ref = (0, _ui.useForwardedRef)(forwardedRef);
  var focusCurrentWeekDay = (0, _react.useCallback)(() => {
    var _ref$current, _ref$current$querySel;

    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : (_ref$current$querySel = _ref$current.querySelector("[data-focused=\"true\"]")) === null || _ref$current$querySel === void 0 ? void 0 : _ref$current$querySel.focus();
  }, [ref]);
  var handleKeyDown = (0, _react.useCallback)(event => {
    var _ref$current2, _ref$current2$querySe;

    if (!_constants.ARROW_KEYS.includes(event.key)) {
      return;
    }

    event.preventDefault();

    if (event.target.hasAttribute('data-calendar-grid')) {
      focusCurrentWeekDay();
      return;
    }

    if (event.key === 'ArrowUp') {
      onFocusedDateChange((0, _dateFns.addDays)(focusedDate, -7));
    }

    if (event.key === 'ArrowDown') {
      onFocusedDateChange((0, _dateFns.addDays)(focusedDate, 7));
    }

    if (event.key === 'ArrowLeft') {
      onFocusedDateChange((0, _dateFns.addDays)(focusedDate, -1));
    }

    if (event.key === 'ArrowRight') {
      onFocusedDateChange((0, _dateFns.addDays)(focusedDate, 1));
    } // set focus temporarily on this element to make sure focus is still inside the calendar-grid after re-render


    (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : (_ref$current2$querySe = _ref$current2.querySelector('[data-preserve-focus]')) === null || _ref$current2$querySe === void 0 ? void 0 : _ref$current2$querySe.focus();
  }, [ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate]);
  (0, _react.useEffect)(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]);
  (0, _react.useEffect)(() => {
    var _document$activeEleme;

    var currentFocusInCalendarGrid = (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.matches('[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]');

    if ( // Only move focus if it's currently in the calendar grid
    currentFocusInCalendarGrid) {
      focusCurrentWeekDay();
    }
  }, [ref, focusCurrentWeekDay, focusedDate]);
  var handleYesterdayClick = (0, _react.useCallback)(() => handleDateChange((0, _dateFns.addDays)(new Date(), -1)), [handleDateChange]);
  var handleTodayClick = (0, _react.useCallback)(() => handleDateChange(new Date()), [handleDateChange]);
  var handleTomorrowClick = (0, _react.useCallback)(() => handleDateChange((0, _dateFns.addDays)(new Date(), 1)), [handleDateChange]);
  var handleNowClick = (0, _react.useCallback)(() => onSelect(new Date()), [onSelect]);
  return /*#__PURE__*/_react.default.createElement(_ui.Box, _extends({
    "data-ui": "Calendar"
  }, restProps, {
    ref: ref
  }), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    padding: 2
  }, _features.features.dayPresets && /*#__PURE__*/_react.default.createElement(_ui.Grid, {
    columns: 3,
    "data-ui": "CalendaryDayPresets",
    gap: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: "Yesterday",
    mode: "bleed",
    fontSize: 1,
    onClick: handleYesterdayClick
  }), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: "Today",
    mode: "bleed",
    fontSize: 1,
    onClick: handleTodayClick
  }), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: "Tomorrow",
    mode: "bleed",
    fontSize: 1,
    onClick: handleTomorrowClick
  })), /*#__PURE__*/_react.default.createElement(_ui.Flex, null, /*#__PURE__*/_react.default.createElement(_ui.Box, {
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(CalendarMonthSelect, {
    moveFocusedDate: moveFocusedDate,
    onChange: handleFocusedMonthChange,
    value: focusedDate === null || focusedDate === void 0 ? void 0 : focusedDate.getMonth()
  })), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginLeft: 2
  }, /*#__PURE__*/_react.default.createElement(CalendarYearSelect, {
    moveFocusedDate: moveFocusedDate,
    onChange: setFocusedDateYear,
    value: focusedDate.getFullYear()
  }))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    "data-calendar-grid": true,
    onKeyDown: handleKeyDown,
    marginTop: 2,
    overflow: "hidden",
    tabIndex: 0
  }, /*#__PURE__*/_react.default.createElement(_CalendarMonth.CalendarMonth, {
    date: focusedDate,
    focused: focusedDate,
    onSelect: handleDateChange,
    selected: selectedDate
  }), PRESERVE_FOCUS_ELEMENT)), selectTime && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    padding: 2,
    style: {
      borderTop: '1px solid var(--card-border-color)'
    }
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    align: "center"
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    align: "center",
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Box, null, /*#__PURE__*/_react.default.createElement(_ui.Select, {
    "aria-label": "Select hour",
    value: selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.getHours(),
    onChange: handleHoursChange
  }, _constants.HOURS_24.map(h => /*#__PURE__*/_react.default.createElement("option", {
    key: h,
    value: h
  }, "".concat(h).padStart(2, '0'))))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    paddingX: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Text, null, ":")), /*#__PURE__*/_react.default.createElement(_ui.Box, null, /*#__PURE__*/_react.default.createElement(_ui.Select, {
    "aria-label": "Select minutes",
    value: selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.getMinutes(),
    onChange: handleMinutesChange
  }, (0, _range2.default)(0, 60, timeStep).map(m => /*#__PURE__*/_react.default.createElement("option", {
    key: m,
    value: m
  }, "".concat(m).padStart(2, '0')))))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginLeft: 2
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: "Set to current time",
    mode: "bleed",
    onClick: handleNowClick
  }))), _features.features.timePresets && /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    direction: "row",
    justify: "center",
    align: "center",
    style: {
      marginTop: 5
    }
  }, _constants.DEFAULT_TIME_PRESETS.map(_ref => {
    var _ref2 = _slicedToArray(_ref, 2),
        hours = _ref2[0],
        minutes = _ref2[1];

    return /*#__PURE__*/_react.default.createElement(CalendarTimePresetButton, {
      key: "".concat(hours, "-").concat(minutes),
      hours: hours,
      minutes: minutes,
      onTimeChange: handleTimeChange,
      selectedDate: selectedDate
    });
  }))));
});
exports.Calendar = Calendar;

function CalendarTimePresetButton(props) {
  var hours = props.hours,
      minutes = props.minutes,
      onTimeChange = props.onTimeChange,
      selectedDate = props.selectedDate;
  var formatted = (0, _utils.formatTime)(hours, minutes);
  var handleClick = (0, _react.useCallback)(() => {
    onTimeChange(hours, minutes);
  }, [hours, minutes, onTimeChange]);
  return /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: formatted,
    "aria-label": "".concat(formatted, " on ").concat(selectedDate.toDateString()),
    mode: "bleed",
    fontSize: 1,
    onClick: handleClick
  });
}

function CalendarMonthSelect(props) {
  var moveFocusedDate = props.moveFocusedDate,
      onChange = props.onChange,
      value = props.value;
  var handlePrevMonthClick = (0, _react.useCallback)(() => moveFocusedDate(-1), [moveFocusedDate]);
  var handleNextMonthClick = (0, _react.useCallback)(() => moveFocusedDate(1), [moveFocusedDate]);
  return /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Go to previous month",
    onClick: handlePrevMonthClick,
    mode: "bleed",
    icon: _icons.ChevronLeftIcon,
    paddingX: 2,
    radius: 0
  }), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Select, {
    radius: 0,
    value: value,
    onChange: onChange
  }, _constants.MONTH_NAMES.map((m, i) =>
  /*#__PURE__*/
  // eslint-disable-next-line react/no-array-index-key
  _react.default.createElement("option", {
    key: i,
    value: i
  }, m)))), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Go to next month",
    mode: "bleed",
    icon: _icons.ChevronRightIcon,
    onClick: handleNextMonthClick,
    paddingX: 2,
    radius: 0
  }));
}

function CalendarYearSelect(props) {
  var moveFocusedDate = props.moveFocusedDate,
      onChange = props.onChange,
      value = props.value;
  var handlePrevYearClick = (0, _react.useCallback)(() => moveFocusedDate(-12), [moveFocusedDate]);
  var handleNextYearClick = (0, _react.useCallback)(() => moveFocusedDate(12), [moveFocusedDate]);
  return /*#__PURE__*/_react.default.createElement(_ui.Flex, null, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Previous year",
    onClick: handlePrevYearClick,
    mode: "bleed",
    icon: _icons.ChevronLeftIcon,
    paddingX: 2,
    radius: 0
  }), /*#__PURE__*/_react.default.createElement(_YearInput.YearInput, {
    value: value,
    onChange: onChange,
    radius: 0,
    style: {
      width: 65
    }
  }), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Next year",
    onClick: handleNextYearClick,
    mode: "bleed",
    icon: _icons.ChevronRightIcon,
    paddingX: 2,
    radius: 0
  }));
}