"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateInitialObjectValue = validateInitialObjectValue;
exports.validateTemplates = validateTemplates;

var _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject"));

var _oneline = _interopRequireDefault(require("oneline"));

var _paths = require("@sanity/util/paths");

var _Schema = require("./parts/Schema");

var _templateObject;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var ALLOWED_REF_PROPS = ['_key', '_ref', '_weak', '_type'];
var REQUIRED_TEMPLATE_PROPS = ['id', 'title', 'schemaType', 'value'];

function validateTemplates(templates) {
  var idMap = new Map();
  templates.forEach((template, i) => {
    var id = templateId(template, i);

    if (typeof template.values !== 'undefined' && !template.value) {
      throw new Error("Template ".concat(id, " is missing \"value\" property, but contained \"values\". Typo?"));
    }

    var missing = REQUIRED_TEMPLATE_PROPS.filter(prop => !template[prop]);

    if (missing.length > 0) {
      throw new Error("Template ".concat(id, " is missing required properties: ").concat(missing.join(', ')));
    }

    if (typeof template.value !== 'function' && !(0, _isPlainObject2.default)(template.value)) {
      throw new Error("Template ".concat(id, " has an invalid \"value\" property; should be a function or an object"));
    }

    if (typeof template.parameters !== 'undefined') {
      if (Array.isArray(template.parameters)) {
        template.parameters.forEach((param, j) => validateParameter(param, template, j));
      } else {
        throw new Error("Template ".concat(id, " has an invalid \"parameters\" property; must be an array"));
      }
    }

    if (idMap.has(template.id)) {
      var dupeIndex = idMap.get(template.id);
      var dupe = "".concat(quote(templates[dupeIndex].title), " at index ").concat(dupeIndex);
      throw new Error("Template \"".concat(template.title, "\" at index ").concat(i, " has the same ID (\"").concat(template.id, "\") as template ").concat(dupe));
    }

    idMap.set(template.id, i);
  });
  return templates;
}

function templateId(template, i) {
  return quote(template.id || template.title) || typeof i === 'number' && "at index ".concat(i) || '';
}

function quote(str) {
  return str && str.length > 0 ? "\"".concat(str, "\"") : str;
}

function validateInitialObjectValue(value, template) {
  var contextError = msg => "Template \"".concat(template.id, "\" initial value: ").concat(msg);

  if (!(0, _isPlainObject2.default)(value)) {
    throw new Error(contextError("resolved to a non-object"));
  }

  if (value._type && template.schemaType !== value._type) {
    throw new Error(contextError((0, _oneline.default)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n        includes \"_type\"-property (", ")\n        that does not match template (", ")\n      "])), value._type, template.schemaType)));
  }

  try {
    return validateValue(value);
  } catch (err) {
    err.message = contextError(err.message);
    throw err;
  }
}

function validateValue(value) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var parentIsArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (Array.isArray(value)) {
    return value.map((item, i) => {
      if (Array.isArray(item)) {
        throw new Error("multidimensional arrays are not supported (at path \"".concat((0, _paths.toString)(path), "\")"));
      }

      return validateValue(item, path.concat(i), true);
    });
  }

  if (!(0, _isPlainObject2.default)(value)) {
    return value;
  } // Apply missing keys is the parent is an array


  var initial = parentIsArray && !value._key ? {
    _key: (0, _paths.randomKey)()
  } : {}; // Ensure non-root objects have _type

  if (path.length > 0 && !value._type) {
    if (value._ref) {
      // In the case of references, we know what the type should be, so apply it
      initial._type = 'reference';
    } else {// todo: consider if we need to re-instantiate this. It currently makes the valid case of having an initial object value for a field fail
      // throw new Error(`missing "_type" property at path "${pathToString(path)}"`)
    }
  }

  if (value._ref) {
    validateReference(value, path);
  } // Validate deeply


  return Object.keys(value).reduce((acc, key) => {
    acc[key] = validateValue(value[key], path.concat([key]));
    return acc;
  }, initial);
}

function validateParameter(parameter, template, index) {
  var schema = (0, _Schema.getDefaultSchema)();

  if (!parameter.name) {
    throw new Error("Template ".concat(template.id, " has a parameter at index ").concat(index, " that is missing its \"name\"-property"));
  } // I know, this is a weird one


  if (parameter.name === 'template') {
    throw new Error("Template parameters cannot be named \"template\", see parameter #".concat(index, " for template ").concat(template.id));
  }

  if (!schema.get(parameter.type)) {
    throw new Error("Template parameter \"".concat(parameter.name, "\" has an invalid/unknown type: \"").concat(parameter.type, "\""));
  }
}

function validateReference(value) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!value._type && value.type) {
    throw new Error("Reference is missing \"_type\", but has a \"type\" property at path \"".concat((0, _paths.toString)(path), "\""));
  }

  var disallowed = Object.keys(value).filter(key => !ALLOWED_REF_PROPS.includes(key));

  if (disallowed.length > 0) {
    var plural = disallowed.length > 1 ? 'properties' : 'property';
    throw new Error("Disallowed ".concat(plural, " found in reference: ").concat(disallowed.map(quote).join(', '), " at path \"").concat((0, _paths.toString)(path), "\""));
  }
}