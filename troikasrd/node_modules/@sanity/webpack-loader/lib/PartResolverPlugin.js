"use strict";

var qs = require('querystring');

var path = require('path');

var partResolver = require('@sanity/resolver');

var emptyPart = require.resolve('./emptyPart');

var debugPart = require.resolve('./debugPart');

var unimplementedPart = require.resolve('./unimplementedPart');

var partMatcher = /^(all:)?part:[@A-Za-z0-9_-]+\/[A-Za-z0-9_/-]+/;
var configMatcher = /^config:(@?[A-Za-z0-9_-]+\/[A-Za-z0-9_-]+|[A-Za-z0-9_-]+)$/;
var sanityMatcher = /^sanity:/;
var target = 'resolve';

var isSanityPart = request => [partMatcher, configMatcher, sanityMatcher].some(match => match.test(request.request));

var PartResolverPlugin = function PartResolverPlugin(options) {
  if (!options || !options.basePath) {
    throw new Error('`basePath` option must be specified in part resolver plugin constructor');
  }

  this.environment = options.env;
  this.basePath = options.basePath;
  this.additionalPlugins = options.additionalPlugins || [];
  this.configPath = path.join(this.basePath, 'config');
  this.extractCssCustomProperties = options.extractCssCustomProperties;
  this.isSanityMonorepo = options.isSanityMonorepo;
};

PartResolverPlugin.prototype.apply = function (compiler) {
  var env = this.environment;
  var basePath = this.basePath;
  var additionalPlugins = this.additionalPlugins;
  var configPath = this.configPath;
  var isSanityMonorepo = this.isSanityMonorepo;
  var extractCssCustomProperties = this.extractCssCustomProperties;
  compiler.plugin('watch-run', (watcher, cb) => {
    cacheParts(watcher).then(resolveCssCustomProperties).then(cb).catch(cb);
  });
  compiler.plugin('run', (params, cb) => {
    cacheParts(params).then(resolveCssCustomProperties).then(cb).catch(cb);
  });

  function cacheParts(params) {
    var instance = params.compiler || params;
    instance.sanity = compiler.sanity || {
      basePath: basePath
    };
    return partResolver.resolveParts({
      env,
      basePath,
      additionalPlugins,
      isSanityMonorepo
    }).then(parts => {
      instance.sanity.parts = parts;
      return {
        instance,
        parts
      };
    });
  }

  function resolveCssCustomProperties(_ref) {
    var instance = _ref.instance,
        parts = _ref.parts;
    var impl = parts.implementations['part:@sanity/base/theme/variables-style'];

    if (!impl || !impl[0] || !extractCssCustomProperties) {
      return Promise.resolve();
    }

    return extractCssCustomProperties(basePath, impl[0].path, isSanityMonorepo).then(cssCustomProperties => {
      instance.sanity.cssCustomProperties = cssCustomProperties;
    });
  }

  compiler.plugin('compilation', () => {
    // eslint-disable-next-line complexity
    compiler.resolvers.normal.plugin('module', function (request, callback) {
      // If it doesn't match the string pattern of a Sanity part, stop trying to resolve it
      if (!isSanityPart(request)) {
        return callback();
      }

      var parts = compiler.sanity.parts;
      var sanityPart = request.request.replace(/^all:/, '');

      if (request.request === 'sanity:css-custom-properties') {
        return this.doResolve(target, getResolveOptions({
          resolveTo: debugPart,
          request: request
        }), null, callback);
      } // The debug part should return the whole part/plugin tree


      if (request.request === 'sanity:debug') {
        return this.doResolve(target, getResolveOptions({
          resolveTo: debugPart,
          request: request
        }), null, callback);
      } // The versions part should return a list of module versions


      if (request.request === 'sanity:versions') {
        return this.doResolve(target, getResolveOptions({
          resolveTo: debugPart,
          request: request
        }), null, callback);
      } // Configuration files resolve to a specific path
      // Either the root sanity.json or a plugins JSON config


      var configMatch = request.request.match(configMatcher);

      if (configMatch) {
        var configFor = configMatch[1];
        var req = Object.assign({}, request, {
          request: configFor === 'sanity' ? path.join(basePath, 'sanity.json') : path.join(configPath, "".concat(configFor, ".json"))
        });
        req.query = "?".concat(qs.stringify({
          sanityPart: request.request
        }));
        return this.doResolve(target, req, null, callback);
      }

      var loadAll = request.request.indexOf('all:') === 0;
      var allowUnimplemented = request.query === '?';
      var part = parts.implementations[sanityPart]; // Imports throw if they are not implemented, except if they
      // are prefixed with `all:` (returns an empty array) or they
      // are postfixed with `?` (returns undefined)

      if (!part) {
        if (allowUnimplemented) {
          return this.doResolve(target, {
            request: unimplementedPart,
            path: unimplementedPart
          }, null, callback);
        }

        if (loadAll) {
          return this.doResolve(target, {
            request: emptyPart,
            path: emptyPart
          }, null, callback);
        }

        return callback(new Error("Part \"".concat(sanityPart, "\" not implemented by any plugins")));
      }

      var resolveOpts = getResolveOptions({
        resolveTo: part[0].path,
        request: request
      });
      return this.doResolve(target, resolveOpts, null, callback);
    });
  });
};

function getResolveOptions(options) {
  var reqQuery = (options.request.query || '').replace(/^\?/, '');
  var query = Object.assign({}, qs.parse(reqQuery) || {}, {
    sanityPart: options.request.request
  });
  return Object.assign({}, options.request, {
    request: options.resolveTo,
    query: "?".concat(qs.stringify(query))
  });
}

module.exports = PartResolverPlugin;